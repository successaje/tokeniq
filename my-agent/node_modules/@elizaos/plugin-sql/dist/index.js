var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/index.ts
import { logger as logger7 } from "@elizaos/core";

// src/pglite/adapter.ts
import { logger as logger2 } from "@elizaos/core";
import { drizzle } from "drizzle-orm/pglite";

// src/base.ts
import {
  ChannelType,
  DatabaseAdapter,
  logger
} from "@elizaos/core";
import {
  and,
  cosineDistance,
  count,
  desc,
  eq,
  gte,
  inArray,
  lt,
  lte,
  or,
  sql as sql16
} from "drizzle-orm";
import { v4 } from "uuid";

// src/schema/embedding.ts
import { sql as sql5 } from "drizzle-orm";
import { check as check2, foreignKey as foreignKey2, index as index2, pgTable as pgTable5, timestamp as timestamp5, uuid as uuid5, vector } from "drizzle-orm/pg-core";
import { VECTOR_DIMS } from "@elizaos/core";

// src/schema/memory.ts
import { relations, sql as sql4 } from "drizzle-orm";
import {
  boolean as boolean2,
  check,
  foreignKey,
  index,
  jsonb as jsonb4,
  pgTable as pgTable4,
  text as text4,
  timestamp as timestamp4,
  uuid as uuid4
} from "drizzle-orm/pg-core";

// src/schema/agent.ts
import { sql } from "drizzle-orm";
import { boolean, jsonb, pgTable, text, timestamp, unique, uuid } from "drizzle-orm/pg-core";
var agentTable = pgTable(
  "agents",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    enabled: boolean("enabled").default(true).notNull(),
    createdAt: timestamp("created_at", { withTimezone: true }).default(sql`now()`).notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true }).default(sql`now()`).notNull(),
    // Character
    name: text("name").notNull(),
    username: text("username"),
    system: text("system").default(""),
    bio: jsonb("bio").$type().default(sql`'[]'::jsonb`),
    messageExamples: jsonb("message_examples").$type().default(sql`'[]'::jsonb`).notNull(),
    postExamples: jsonb("post_examples").$type().default(sql`'[]'::jsonb`).notNull(),
    topics: jsonb("topics").$type().default(sql`'[]'::jsonb`).notNull(),
    adjectives: jsonb("adjectives").$type().default(sql`'[]'::jsonb`).notNull(),
    knowledge: jsonb("knowledge").$type().default(sql`'[]'::jsonb`).notNull(),
    plugins: jsonb("plugins").$type().default(sql`'[]'::jsonb`).notNull(),
    settings: jsonb("settings").$type().default(sql`'{}'::jsonb`).notNull(),
    style: jsonb("style").$type().default(sql`'{}'::jsonb`).notNull()
  },
  (table) => {
    return {
      nameUnique: unique("name_unique").on(table.name)
    };
  }
);

// src/schema/entity.ts
import { sql as sql2 } from "drizzle-orm";
import { jsonb as jsonb2, pgTable as pgTable2, text as text2, timestamp as timestamp2, unique as unique2, uuid as uuid2 } from "drizzle-orm/pg-core";
var entityTable = pgTable2(
  "entities",
  {
    id: uuid2("id").notNull().primaryKey(),
    agentId: uuid2("agent_id").notNull().references(() => agentTable.id, {
      onDelete: "cascade"
    }),
    createdAt: timestamp2("created_at").default(sql2`now()`).notNull(),
    names: text2("names").array().default(sql2`'{}'::text[]`).notNull(),
    metadata: jsonb2("metadata").default(sql2`'{}'::jsonb`).notNull()
  },
  (table) => {
    return {
      idAgentIdUnique: unique2("id_agent_id_unique").on(table.id, table.agentId)
    };
  }
);

// src/schema/room.ts
import { sql as sql3 } from "drizzle-orm";
import { jsonb as jsonb3, pgTable as pgTable3, text as text3, timestamp as timestamp3, uuid as uuid3 } from "drizzle-orm/pg-core";
var roomTable = pgTable3("rooms", {
  id: uuid3("id").notNull().primaryKey().default(sql3`gen_random_uuid()`),
  agentId: uuid3("agentId").references(() => agentTable.id, {
    onDelete: "cascade"
  }),
  source: text3("source").notNull(),
  type: text3("type").notNull(),
  serverId: text3("serverId"),
  worldId: uuid3("worldId"),
  // no guarantee that world exists, it is optional for now
  // .references(() => worldTable.id, {
  //   onDelete: 'cascade',
  // }),
  name: text3("name"),
  metadata: jsonb3("metadata"),
  channelId: text3("channelId"),
  createdAt: timestamp3("createdAt").default(sql3`now()`).notNull()
});

// src/schema/memory.ts
var memoryTable = pgTable4(
  "memories",
  {
    id: uuid4("id").primaryKey().notNull(),
    type: text4("type").notNull(),
    createdAt: timestamp4("createdAt").default(sql4`now()`).notNull(),
    content: jsonb4("content").notNull(),
    entityId: uuid4("entityId").references(() => entityTable.id, {
      onDelete: "cascade"
    }),
    agentId: uuid4("agentId").references(() => agentTable.id, {
      onDelete: "cascade"
    }).notNull(),
    roomId: uuid4("roomId").references(() => roomTable.id, {
      onDelete: "cascade"
    }),
    worldId: uuid4("worldId"),
    // .references(() => worldTable.id, {
    //   onDelete: 'set null',
    // }),
    unique: boolean2("unique").default(true).notNull(),
    metadata: jsonb4("metadata").default({}).notNull()
  },
  (table) => [
    index("idx_memories_type_room").on(table.type, table.roomId),
    index("idx_memories_world_id").on(table.worldId),
    foreignKey({
      name: "fk_room",
      columns: [table.roomId],
      foreignColumns: [roomTable.id]
    }).onDelete("cascade"),
    foreignKey({
      name: "fk_user",
      columns: [table.entityId],
      foreignColumns: [entityTable.id]
    }).onDelete("cascade"),
    foreignKey({
      name: "fk_agent",
      columns: [table.agentId],
      foreignColumns: [agentTable.id]
    }).onDelete("cascade"),
    // foreignKey({
    //   name: 'fk_world',
    //   columns: [table.worldId],
    //   foreignColumns: [worldTable.id],
    // }).onDelete('set null'),
    index("idx_memories_metadata_type").on(sql4`((metadata->>'type'))`),
    index("idx_memories_document_id").on(sql4`((metadata->>'documentId'))`),
    index("idx_fragments_order").on(
      sql4`((metadata->>'documentId'))`,
      sql4`((metadata->>'position'))`
    ),
    check(
      "fragment_metadata_check",
      sql4`
            CASE 
                WHEN metadata->>'type' = 'fragment' THEN
                    metadata ? 'documentId' AND 
                    metadata ? 'position'
                ELSE true
            END
        `
    ),
    check(
      "document_metadata_check",
      sql4`
            CASE 
                WHEN metadata->>'type' = 'document' THEN
                    metadata ? 'timestamp'
                ELSE true
            END
        `
    )
  ]
);
var memoryRelations = relations(memoryTable, ({ one }) => ({
  embedding: one(embeddingTable)
}));

// src/schema/embedding.ts
var DIMENSION_MAP = {
  [VECTOR_DIMS.SMALL]: "dim384",
  [VECTOR_DIMS.MEDIUM]: "dim512",
  [VECTOR_DIMS.LARGE]: "dim768",
  [VECTOR_DIMS.XL]: "dim1024",
  [VECTOR_DIMS.XXL]: "dim1536",
  [VECTOR_DIMS.XXXL]: "dim3072"
};
var embeddingTable = pgTable5(
  "embeddings",
  {
    id: uuid5("id").primaryKey().defaultRandom().notNull(),
    memoryId: uuid5("memory_id").references(() => memoryTable.id, { onDelete: "cascade" }),
    createdAt: timestamp5("created_at").default(sql5`now()`).notNull(),
    dim384: vector("dim_384", { dimensions: VECTOR_DIMS.SMALL }),
    dim512: vector("dim_512", { dimensions: VECTOR_DIMS.MEDIUM }),
    dim768: vector("dim_768", { dimensions: VECTOR_DIMS.LARGE }),
    dim1024: vector("dim_1024", { dimensions: VECTOR_DIMS.XL }),
    dim1536: vector("dim_1536", { dimensions: VECTOR_DIMS.XXL }),
    dim3072: vector("dim_3072", { dimensions: VECTOR_DIMS.XXXL })
  },
  (table) => [
    check2("embedding_source_check", sql5`"memory_id" IS NOT NULL`),
    index2("idx_embedding_memory").on(table.memoryId),
    foreignKey2({
      name: "fk_embedding_memory",
      columns: [table.memoryId],
      foreignColumns: [memoryTable.id]
    }).onDelete("cascade")
  ]
);

// src/schema/index.ts
var schema_exports = {};
__export(schema_exports, {
  agentTable: () => agentTable,
  cacheTable: () => cacheTable,
  channelParticipantsTable: () => channelParticipantsTable,
  channelTable: () => channelTable,
  componentTable: () => componentTable,
  embeddingTable: () => embeddingTable,
  entityTable: () => entityTable,
  logTable: () => logTable,
  memoryTable: () => memoryTable,
  messageServerTable: () => messageServerTable,
  messageTable: () => messageTable,
  participantTable: () => participantTable,
  relationshipTable: () => relationshipTable,
  roomTable: () => roomTable,
  serverAgentsTable: () => serverAgentsTable,
  taskTable: () => taskTable,
  worldTable: () => worldTable
});

// src/schema/cache.ts
import { sql as sql6 } from "drizzle-orm";
import { jsonb as jsonb5, pgTable as pgTable6, text as text5, primaryKey, timestamp as timestamp6, uuid as uuid6 } from "drizzle-orm/pg-core";
var cacheTable = pgTable6(
  "cache",
  {
    key: text5("key").notNull(),
    agentId: uuid6("agent_id").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
    value: jsonb5("value").notNull(),
    createdAt: timestamp6("created_at", { withTimezone: true }).default(sql6`now()`).notNull(),
    expiresAt: timestamp6("expires_at", { withTimezone: true })
  },
  (table) => ({
    pk: primaryKey({ columns: [table.key, table.agentId] })
  })
);

// src/schema/component.ts
import { sql as sql8 } from "drizzle-orm";
import { jsonb as jsonb7, pgTable as pgTable8, text as text7, timestamp as timestamp8, uuid as uuid8 } from "drizzle-orm/pg-core";

// src/schema/world.ts
import { sql as sql7 } from "drizzle-orm";
import { jsonb as jsonb6, pgTable as pgTable7, text as text6, timestamp as timestamp7, uuid as uuid7 } from "drizzle-orm/pg-core";
var worldTable = pgTable7("worlds", {
  id: uuid7("id").notNull().primaryKey().default(sql7`gen_random_uuid()`),
  agentId: uuid7("agentId").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
  name: text6("name").notNull(),
  metadata: jsonb6("metadata"),
  serverId: text6("serverId").notNull().default("local"),
  createdAt: timestamp7("createdAt").default(sql7`now()`).notNull()
});

// src/schema/component.ts
var componentTable = pgTable8("components", {
  id: uuid8("id").primaryKey().default(sql8`gen_random_uuid()`).notNull(),
  // Foreign keys
  entityId: uuid8("entityId").references(() => entityTable.id, { onDelete: "cascade" }).notNull(),
  agentId: uuid8("agentId").references(() => agentTable.id, { onDelete: "cascade" }).notNull(),
  roomId: uuid8("roomId").references(() => roomTable.id, { onDelete: "cascade" }).notNull(),
  worldId: uuid8("worldId").references(() => worldTable.id, { onDelete: "cascade" }),
  sourceEntityId: uuid8("sourceEntityId").references(() => entityTable.id, { onDelete: "cascade" }),
  // Data
  type: text7("type").notNull(),
  data: jsonb7("data").default(sql8`'{}'::jsonb`),
  // Timestamps
  createdAt: timestamp8("createdAt").default(sql8`now()`).notNull()
});

// src/schema/log.ts
import { sql as sql9 } from "drizzle-orm";
import { foreignKey as foreignKey3, jsonb as jsonb8, pgTable as pgTable9, text as text8, timestamp as timestamp9, uuid as uuid9 } from "drizzle-orm/pg-core";
var logTable = pgTable9(
  "logs",
  {
    id: uuid9("id").defaultRandom().notNull(),
    createdAt: timestamp9("created_at", { withTimezone: true }).default(sql9`now()`).notNull(),
    entityId: uuid9("entityId").notNull().references(() => entityTable.id, { onDelete: "cascade" }),
    body: jsonb8("body").notNull(),
    type: text8("type").notNull(),
    roomId: uuid9("roomId").notNull().references(() => roomTable.id, { onDelete: "cascade" })
  },
  (table) => [
    foreignKey3({
      name: "fk_room",
      columns: [table.roomId],
      foreignColumns: [roomTable.id]
    }).onDelete("cascade"),
    foreignKey3({
      name: "fk_user",
      columns: [table.entityId],
      foreignColumns: [entityTable.id]
    }).onDelete("cascade")
  ]
);

// src/schema/participant.ts
import { sql as sql10 } from "drizzle-orm";
import { foreignKey as foreignKey4, index as index3, pgTable as pgTable10, text as text9, timestamp as timestamp10, uuid as uuid10 } from "drizzle-orm/pg-core";
var participantTable = pgTable10(
  "participants",
  {
    id: uuid10("id").notNull().primaryKey().default(sql10`gen_random_uuid()`),
    createdAt: timestamp10("created_at", { withTimezone: true }).default(sql10`now()`).notNull(),
    entityId: uuid10("entityId").references(() => entityTable.id, {
      onDelete: "cascade"
    }),
    roomId: uuid10("roomId").references(() => roomTable.id, {
      onDelete: "cascade"
    }),
    agentId: uuid10("agentId").references(() => agentTable.id, {
      onDelete: "cascade"
    }),
    roomState: text9("roomState")
  },
  (table) => [
    // unique("participants_user_room_agent_unique").on(table.entityId, table.roomId, table.agentId),
    index3("idx_participants_user").on(table.entityId),
    index3("idx_participants_room").on(table.roomId),
    foreignKey4({
      name: "fk_room",
      columns: [table.roomId],
      foreignColumns: [roomTable.id]
    }).onDelete("cascade"),
    foreignKey4({
      name: "fk_user",
      columns: [table.entityId],
      foreignColumns: [entityTable.id]
    }).onDelete("cascade")
  ]
);

// src/schema/relationship.ts
import { sql as sql11 } from "drizzle-orm";
import {
  foreignKey as foreignKey5,
  index as index4,
  jsonb as jsonb9,
  pgTable as pgTable11,
  text as text10,
  timestamp as timestamp11,
  unique as unique3,
  uuid as uuid11
} from "drizzle-orm/pg-core";
var relationshipTable = pgTable11(
  "relationships",
  {
    id: uuid11("id").notNull().primaryKey().default(sql11`gen_random_uuid()`),
    createdAt: timestamp11("created_at", { withTimezone: true }).default(sql11`now()`).notNull(),
    sourceEntityId: uuid11("sourceEntityId").notNull().references(() => entityTable.id, { onDelete: "cascade" }),
    targetEntityId: uuid11("targetEntityId").notNull().references(() => entityTable.id, { onDelete: "cascade" }),
    agentId: uuid11("agentId").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
    tags: text10("tags").array(),
    metadata: jsonb9("metadata")
  },
  (table) => [
    index4("idx_relationships_users").on(table.sourceEntityId, table.targetEntityId),
    unique3("unique_relationship").on(table.sourceEntityId, table.targetEntityId, table.agentId),
    foreignKey5({
      name: "fk_user_a",
      columns: [table.sourceEntityId],
      foreignColumns: [entityTable.id]
    }).onDelete("cascade"),
    foreignKey5({
      name: "fk_user_b",
      columns: [table.targetEntityId],
      foreignColumns: [entityTable.id]
    }).onDelete("cascade")
  ]
);

// src/schema/tasks.ts
import { jsonb as jsonb10, pgTable as pgTable12, text as text11, timestamp as timestamp12, uuid as uuid12 } from "drizzle-orm/pg-core";
import { sql as sql12 } from "drizzle-orm";
var taskTable = pgTable12("tasks", {
  id: uuid12("id").primaryKey().defaultRandom(),
  name: text11("name").notNull(),
  description: text11("description"),
  roomId: uuid12("roomId"),
  worldId: uuid12("worldId"),
  entityId: uuid12("entityId"),
  agentId: uuid12("agent_id").notNull().references(() => agentTable.id, { onDelete: "cascade" }),
  tags: text11("tags").array().default(sql12`'{}'::text[]`),
  metadata: jsonb10("metadata").default(sql12`'{}'::jsonb`),
  createdAt: timestamp12("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp12("updated_at", { withTimezone: true }).defaultNow()
});

// src/schema/messageServer.ts
import { pgTable as pgTable13, text as text12, jsonb as jsonb11, timestamp as timestamp13, uuid as uuid13 } from "drizzle-orm/pg-core";
import { sql as sql13 } from "drizzle-orm";
var messageServerTable = pgTable13("message_servers", {
  id: uuid13("id").primaryKey(),
  name: text12("name").notNull(),
  sourceType: text12("source_type").notNull(),
  sourceId: text12("source_id"),
  metadata: jsonb11("metadata"),
  createdAt: timestamp13("created_at", { mode: "date" }).default(sql13`CURRENT_TIMESTAMP`).notNull(),
  updatedAt: timestamp13("updated_at", { mode: "date" }).default(sql13`CURRENT_TIMESTAMP`).notNull()
});

// src/schema/channel.ts
import { pgTable as pgTable14, text as text13, jsonb as jsonb12, timestamp as timestamp14, uuid as uuid14 } from "drizzle-orm/pg-core";
import { sql as sql14 } from "drizzle-orm";
var channelTable = pgTable14("channels", {
  id: text13("id").primaryKey(),
  // UUID stored as text
  messageServerId: uuid14("server_id").notNull().references(() => messageServerTable.id, { onDelete: "cascade" }),
  name: text13("name").notNull(),
  type: text13("type").notNull(),
  // Store ChannelType enum values as text
  sourceType: text13("source_type"),
  sourceId: text13("source_id"),
  topic: text13("topic"),
  metadata: jsonb12("metadata"),
  createdAt: timestamp14("created_at", { mode: "date" }).default(sql14`CURRENT_TIMESTAMP`).notNull(),
  updatedAt: timestamp14("updated_at", { mode: "date" }).default(sql14`CURRENT_TIMESTAMP`).notNull()
});

// src/schema/message.ts
import { pgTable as pgTable15, text as text14, jsonb as jsonb13, timestamp as timestamp15 } from "drizzle-orm/pg-core";
import { sql as sql15 } from "drizzle-orm";
var messageTable = pgTable15("central_messages", {
  id: text14("id").primaryKey(),
  // UUID stored as text
  channelId: text14("channel_id").notNull().references(() => channelTable.id, { onDelete: "cascade" }),
  authorId: text14("author_id").notNull(),
  content: text14("content").notNull(),
  rawMessage: jsonb13("raw_message"),
  inReplyToRootMessageId: text14("in_reply_to_root_message_id").references(() => messageTable.id, {
    onDelete: "set null"
  }),
  sourceType: text14("source_type"),
  sourceId: text14("source_id"),
  metadata: jsonb13("metadata"),
  createdAt: timestamp15("created_at", { mode: "date" }).default(sql15`CURRENT_TIMESTAMP`).notNull(),
  updatedAt: timestamp15("updated_at", { mode: "date" }).default(sql15`CURRENT_TIMESTAMP`).notNull()
});

// src/schema/channelParticipant.ts
import { pgTable as pgTable16, text as text15, primaryKey as primaryKey2 } from "drizzle-orm/pg-core";
var channelParticipantsTable = pgTable16(
  "channel_participants",
  {
    channelId: text15("channel_id").notNull().references(() => channelTable.id, { onDelete: "cascade" }),
    userId: text15("user_id").notNull()
    // This is a central UUID (can be an agentId or a dedicated central user ID)
  },
  (table) => ({
    pk: primaryKey2({ columns: [table.channelId, table.userId] })
  })
);

// src/schema/serverAgent.ts
import { pgTable as pgTable17, uuid as uuid15, primaryKey as primaryKey3 } from "drizzle-orm/pg-core";
var serverAgentsTable = pgTable17(
  "server_agents",
  {
    serverId: uuid15("server_id").notNull().references(() => messageServerTable.id, { onDelete: "cascade" }),
    agentId: uuid15("agent_id").notNull().references(() => agentTable.id, { onDelete: "cascade" })
  },
  (table) => ({
    pk: primaryKey3({ columns: [table.serverId, table.agentId] })
  })
);

// src/base.ts
var BaseDrizzleAdapter = class extends DatabaseAdapter {
  static {
    __name(this, "BaseDrizzleAdapter");
  }
  maxRetries = 3;
  baseDelay = 1e3;
  maxDelay = 1e4;
  jitterMax = 1e3;
  embeddingDimension = DIMENSION_MAP[384];
  /**
   * Initialize method that can be overridden by implementations
   */
  async initialize() {
    await this.init();
  }
  /**
   * Get the underlying database instance for testing purposes
   */
  getDatabase() {
    return this.db;
  }
  agentId;
  /**
   * Constructor for creating a new instance of Agent with the specified agentId.
   *
   * @param {UUID} agentId - The unique identifier for the agent.
   */
  constructor(agentId) {
    super();
    this.agentId = agentId;
  }
  /**
   * Executes the given operation with retry logic.
   * @template T
   * @param {() => Promise<T>} operation - The operation to be executed.
   * @returns {Promise<T>} A promise that resolves with the result of the operation.
   */
  async withRetry(operation) {
    let lastError = new Error("Unknown error");
    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (attempt < this.maxRetries) {
          const backoffDelay = Math.min(this.baseDelay * 2 ** (attempt - 1), this.maxDelay);
          const jitter = Math.random() * this.jitterMax;
          const delay = backoffDelay + jitter;
          logger.warn(`Database operation failed (attempt ${attempt}/${this.maxRetries}):`, {
            error: error instanceof Error ? error.message : String(error),
            nextRetryIn: `${(delay / 1e3).toFixed(1)}s`
          });
          await new Promise((resolve) => setTimeout(resolve, delay));
        } else {
          logger.error("Max retry attempts reached:", {
            error: error instanceof Error ? error.message : String(error),
            totalAttempts: attempt
          });
          throw error instanceof Error ? error : new Error(String(error));
        }
      }
    }
    throw lastError;
  }
  /**
   * Asynchronously ensures that the given embedding dimension is valid for the agent.
   *
   * @param {number} dimension - The dimension to ensure for the embedding.
   * @returns {Promise<void>} - Resolves once the embedding dimension is ensured.
   */
  async ensureEmbeddingDimension(dimension) {
    return this.withDatabase(async () => {
      const existingMemory = await this.db.select().from(memoryTable).innerJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id)).where(eq(memoryTable.agentId, this.agentId)).limit(1);
      if (existingMemory.length > 0) {
        Object.entries(DIMENSION_MAP).find(
          ([_, colName]) => existingMemory[0].embeddings[colName] !== null
        );
      }
      this.embeddingDimension = DIMENSION_MAP[dimension];
    });
  }
  /**
   * Asynchronously retrieves an agent by their ID from the database.
   * @param {UUID} agentId - The ID of the agent to retrieve.
   * @returns {Promise<Agent | null>} A promise that resolves to the retrieved agent or null if not found.
   */
  async getAgent(agentId) {
    return this.withDatabase(async () => {
      const rows = await this.db.select().from(agentTable).where(eq(agentTable.id, agentId)).limit(1);
      if (rows.length === 0) return null;
      const row = rows[0];
      return {
        ...row,
        username: row.username || "",
        id: row.id,
        system: !row.system ? void 0 : row.system,
        bio: !row.bio ? "" : row.bio,
        createdAt: row.createdAt.getTime(),
        updatedAt: row.updatedAt.getTime()
      };
    });
  }
  /**
   * Asynchronously retrieves a list of agents from the database.
   *
   * @returns {Promise<Partial<Agent>[]>} A Promise that resolves to an array of Agent objects.
   */
  async getAgents() {
    return this.withDatabase(async () => {
      const rows = await this.db.select({
        id: agentTable.id,
        name: agentTable.name,
        bio: agentTable.bio
      }).from(agentTable);
      return rows.map((row) => ({
        ...row,
        id: row.id,
        bio: row.bio === null ? "" : row.bio
      }));
    });
  }
  /**
   * Asynchronously creates a new agent record in the database.
   *
   * @param {Partial<Agent>} agent The agent object to be created.
   * @returns {Promise<boolean>} A promise that resolves to a boolean indicating the success of the operation.
   */
  async createAgent(agent) {
    return this.withDatabase(async () => {
      try {
        const conditions = [];
        if (agent.id) {
          conditions.push(eq(agentTable.id, agent.id));
        }
        if (agent.name) {
          conditions.push(eq(agentTable.name, agent.name));
        }
        const existing = conditions.length > 0 ? await this.db.select({ id: agentTable.id }).from(agentTable).where(or(...conditions)).limit(1) : [];
        if (existing.length > 0) {
          logger.warn("Attempted to create an agent with a duplicate ID or name.", {
            id: agent.id,
            name: agent.name
          });
          return false;
        }
        await this.db.transaction(async (tx) => {
          await tx.insert(agentTable).values({
            ...agent,
            createdAt: new Date(agent.createdAt || Date.now()),
            updatedAt: new Date(agent.updatedAt || Date.now())
          });
        });
        logger.debug("Agent created successfully:", {
          agentId: agent.id
        });
        return true;
      } catch (error) {
        logger.error("Error creating agent:", {
          error: error instanceof Error ? error.message : String(error),
          agentId: agent.id,
          agent
        });
        return false;
      }
    });
  }
  /**
   * Updates an agent in the database with the provided agent ID and data.
   * @param {UUID} agentId - The unique identifier of the agent to update.
   * @param {Partial<Agent>} agent - The partial agent object containing the fields to update.
   * @returns {Promise<boolean>} - A boolean indicating if the agent was successfully updated.
   */
  async updateAgent(agentId, agent) {
    return this.withDatabase(async () => {
      try {
        if (!agentId) {
          throw new Error("Agent ID is required for update");
        }
        await this.db.transaction(async (tx) => {
          if (agent?.settings) {
            agent.settings = await this.mergeAgentSettings(tx, agentId, agent.settings);
          }
          const updateData = { ...agent };
          if (updateData.createdAt) {
            if (typeof updateData.createdAt === "number") {
              updateData.createdAt = new Date(updateData.createdAt);
            } else {
              delete updateData.createdAt;
            }
          }
          if (updateData.updatedAt) {
            if (typeof updateData.updatedAt === "number") {
              updateData.updatedAt = new Date(updateData.updatedAt);
            } else {
              updateData.updatedAt = /* @__PURE__ */ new Date();
            }
          } else {
            updateData.updatedAt = /* @__PURE__ */ new Date();
          }
          await tx.update(agentTable).set(updateData).where(eq(agentTable.id, agentId));
        });
        logger.debug("Agent updated successfully:", {
          agentId
        });
        return true;
      } catch (error) {
        logger.error("Error updating agent:", {
          error: error instanceof Error ? error.message : String(error),
          agentId,
          agent
        });
        return false;
      }
    });
  }
  /**
   * Merges updated agent settings with existing settings in the database,
   * with special handling for nested objects like secrets.
   * @param tx - The database transaction
   * @param agentId - The ID of the agent
   * @param updatedSettings - The settings object with updates
   * @returns The merged settings object
   * @private
   */
  async mergeAgentSettings(tx, agentId, updatedSettings) {
    const currentAgent = await tx.select({ settings: agentTable.settings }).from(agentTable).where(eq(agentTable.id, agentId)).limit(1);
    const currentSettings = currentAgent.length > 0 && currentAgent[0].settings ? currentAgent[0].settings : {};
    const deepMerge = /* @__PURE__ */ __name((target, source) => {
      if (source === null) {
        return void 0;
      }
      if (Array.isArray(source) || typeof source !== "object") {
        return source;
      }
      const output = typeof target === "object" && target !== null && !Array.isArray(target) ? { ...target } : {};
      for (const key of Object.keys(source)) {
        const sourceValue = source[key];
        if (sourceValue === null) {
          delete output[key];
        } else if (typeof sourceValue === "object" && !Array.isArray(sourceValue)) {
          const nestedMergeResult = deepMerge(output[key], sourceValue);
          if (nestedMergeResult === void 0) {
            delete output[key];
          } else {
            output[key] = nestedMergeResult;
          }
        } else {
          output[key] = sourceValue;
        }
      }
      if (Object.keys(output).length === 0) {
        if (!(typeof source === "object" && source !== null && Object.keys(source).length === 0)) {
          return void 0;
        }
      }
      return output;
    }, "deepMerge");
    const finalSettings = deepMerge(currentSettings, updatedSettings);
    return finalSettings === void 0 ? {} : finalSettings;
  }
  /**
   * Asynchronously deletes an agent with the specified UUID and all related entries.
   *
   * @param {UUID} agentId - The UUID of the agent to be deleted.
   * @returns {Promise<boolean>} - A boolean indicating if the deletion was successful.
   */
  async deleteAgent(agentId) {
    logger.debug(`[DB] Deleting agent with ID: ${agentId}`);
    return this.withDatabase(async () => {
      try {
        const result = await this.db.delete(agentTable).where(eq(agentTable.id, agentId)).returning();
        if (result.length === 0) {
          logger.warn(`[DB] Agent ${agentId} not found`);
          return false;
        }
        logger.success(
          `[DB] Agent ${agentId} and all related data successfully deleted via cascade`
        );
        return true;
      } catch (error) {
        logger.error(`[DB] Failed to delete agent ${agentId}:`, error);
        if (error instanceof Error) {
          logger.error(`[DB] Error details: ${error.name} - ${error.message}`);
          logger.error(`[DB] Stack trace: ${error.stack}`);
        }
        throw error;
      }
    });
  }
  /**
   * Count all agents in the database
   * Used primarily for maintenance and cleanup operations
   */
  /**
   * Asynchronously counts the number of agents in the database.
   * @returns {Promise<number>} A Promise that resolves to the number of agents in the database.
   */
  async countAgents() {
    return this.withDatabase(async () => {
      try {
        const result = await this.db.select({ count: count() }).from(agentTable);
        return result[0]?.count || 0;
      } catch (error) {
        logger.error("Error counting agents:", {
          error: error instanceof Error ? error.message : String(error)
        });
        return 0;
      }
    });
  }
  /**
   * Clean up the agents table by removing all agents
   * This is used during server startup to ensure no orphaned agents exist
   * from previous crashes or improper shutdowns
   */
  async cleanupAgents() {
    return this.withDatabase(async () => {
      try {
        await this.db.delete(agentTable);
        logger.success("Successfully cleaned up agent table");
      } catch (error) {
        logger.error("Error cleaning up agent table:", {
          error: error instanceof Error ? error.message : String(error)
        });
        throw error;
      }
    });
  }
  /**
   * Asynchronously retrieves an entity and its components by entity IDs.
   * @param {UUID[]} entityIds - The unique identifiers of the entities to retrieve.
   * @returns {Promise<Entity[] | null>} A Promise that resolves to the entity with its components if found, null otherwise.
   */
  async getEntityByIds(entityIds) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        entity: entityTable,
        components: componentTable
      }).from(entityTable).leftJoin(componentTable, eq(componentTable.entityId, entityTable.id)).where(inArray(entityTable.id, entityIds));
      if (result.length === 0) return [];
      const entities = {};
      const entityComponents = {};
      for (const e of result) {
        const key = e.entity.id;
        entities[key] = e.entity;
        if (entityComponents[key] === void 0) entityComponents[key] = [];
        if (e.components) {
          const componentsArray = Array.isArray(e.components) ? e.components : [e.components];
          entityComponents[key] = [...entityComponents[key], ...componentsArray];
        }
      }
      for (const k of Object.keys(entityComponents)) {
        entities[k].components = entityComponents[k];
      }
      return Object.values(entities);
    });
  }
  /**
   * Asynchronously retrieves all entities for a given room, optionally including their components.
   * @param {UUID} roomId - The unique identifier of the room to get entities for
   * @param {boolean} [includeComponents] - Whether to include component data for each entity
   * @returns {Promise<Entity[]>} A Promise that resolves to an array of entities in the room
   */
  async getEntitiesForRoom(roomId, includeComponents) {
    return this.withDatabase(async () => {
      const query = this.db.select({
        entity: entityTable,
        ...includeComponents && { components: componentTable }
      }).from(participantTable).leftJoin(
        entityTable,
        and(eq(participantTable.entityId, entityTable.id), eq(entityTable.agentId, this.agentId))
      );
      if (includeComponents) {
        query.leftJoin(componentTable, eq(componentTable.entityId, entityTable.id));
      }
      const result = await query.where(eq(participantTable.roomId, roomId));
      const entitiesByIdMap = /* @__PURE__ */ new Map();
      for (const row of result) {
        if (!row.entity) continue;
        const entityId = row.entity.id;
        if (!entitiesByIdMap.has(entityId)) {
          const entity = {
            ...row.entity,
            id: entityId,
            agentId: row.entity.agentId,
            metadata: row.entity.metadata,
            components: includeComponents ? [] : void 0
          };
          entitiesByIdMap.set(entityId, entity);
        }
        if (includeComponents && row.components) {
          const entity = entitiesByIdMap.get(entityId);
          if (entity) {
            if (!entity.components) {
              entity.components = [];
            }
            entity.components.push(row.components);
          }
        }
      }
      return Array.from(entitiesByIdMap.values());
    });
  }
  /**
   * Asynchronously creates new entities in the database.
   * @param {Entity[]} entities - The entity objects to be created.
   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating the success of the operation.
   */
  async createEntities(entities) {
    return this.withDatabase(async () => {
      try {
        return await this.db.transaction(async (tx) => {
          await tx.insert(entityTable).values(entities);
          logger.debug(entities.length, "Entities created successfully");
          return true;
        });
      } catch (error) {
        logger.error("Error creating entity:", {
          error: error instanceof Error ? error.message : String(error),
          entityId: entities[0].id,
          name: entities[0].metadata?.name
        });
        logger.trace(error);
        return false;
      }
    });
  }
  /**
   * Asynchronously ensures an entity exists, creating it if it doesn't
   * @param entity The entity to ensure exists
   * @returns Promise resolving to boolean indicating success
   */
  async ensureEntityExists(entity) {
    if (!entity.id) {
      logger.error("Entity ID is required for ensureEntityExists");
      return false;
    }
    try {
      const existingEntities = await this.getEntityByIds([entity.id]);
      if (!existingEntities || !existingEntities.length) {
        return await this.createEntities([entity]);
      }
      return true;
    } catch (error) {
      logger.error("Error ensuring entity exists:", {
        error: error instanceof Error ? error.message : String(error),
        entityId: entity.id
      });
      return false;
    }
  }
  /**
   * Asynchronously updates an entity in the database.
   * @param {Entity} entity - The entity object to be updated.
   * @returns {Promise<void>} A Promise that resolves when the entity is updated.
   */
  async updateEntity(entity) {
    if (!entity.id) {
      throw new Error("Entity ID is required for update");
    }
    return this.withDatabase(async () => {
      await this.db.update(entityTable).set(entity).where(eq(entityTable.id, entity.id));
    });
  }
  /**
   * Asynchronously deletes an entity from the database based on the provided ID.
   * @param {UUID} entityId - The ID of the entity to delete.
   * @returns {Promise<void>} A Promise that resolves when the entity is deleted.
   */
  async deleteEntity(entityId) {
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        await tx.delete(componentTable).where(
          or(eq(componentTable.entityId, entityId), eq(componentTable.sourceEntityId, entityId))
        );
        await tx.delete(entityTable).where(eq(entityTable.id, entityId));
      });
    });
  }
  /**
   * Asynchronously retrieves entities by their names and agentId.
   * @param {Object} params - The parameters for retrieving entities.
   * @param {string[]} params.names - The names to search for.
   * @param {UUID} params.agentId - The agent ID to filter by.
   * @returns {Promise<Entity[]>} A Promise that resolves to an array of entities.
   */
  async getEntitiesByNames(params) {
    return this.withDatabase(async () => {
      const { names, agentId } = params;
      const nameConditions = names.map((name) => sql16`${name} = ANY(${entityTable.names})`);
      const query = sql16`
        SELECT * FROM ${entityTable}
        WHERE ${entityTable.agentId} = ${agentId}
        AND (${sql16.join(nameConditions, sql16` OR `)})
      `;
      const result = await this.db.execute(query);
      return result.rows.map((row) => ({
        id: row.id,
        agentId: row.agentId,
        names: row.names || [],
        metadata: row.metadata || {}
      }));
    });
  }
  /**
   * Asynchronously searches for entities by name with fuzzy matching.
   * @param {Object} params - The parameters for searching entities.
   * @param {string} params.query - The search query.
   * @param {UUID} params.agentId - The agent ID to filter by.
   * @param {number} params.limit - The maximum number of results to return.
   * @returns {Promise<Entity[]>} A Promise that resolves to an array of entities.
   */
  async searchEntitiesByName(params) {
    return this.withDatabase(async () => {
      const { query, agentId, limit = 10 } = params;
      if (!query || query.trim() === "") {
        const result2 = await this.db.select().from(entityTable).where(eq(entityTable.agentId, agentId)).limit(limit);
        return result2.map((row) => ({
          id: row.id,
          agentId: row.agentId,
          names: row.names || [],
          metadata: row.metadata || {}
        }));
      }
      const searchQuery = sql16`
        SELECT * FROM ${entityTable}
        WHERE ${entityTable.agentId} = ${agentId}
        AND EXISTS (
          SELECT 1 FROM unnest(${entityTable.names}) AS name
          WHERE LOWER(name) LIKE LOWER(${"%" + query + "%"})
        )
        LIMIT ${limit}
      `;
      const result = await this.db.execute(searchQuery);
      return result.rows.map((row) => ({
        id: row.id,
        agentId: row.agentId,
        names: row.names || [],
        metadata: row.metadata || {}
      }));
    });
  }
  async getComponent(entityId, type, worldId, sourceEntityId) {
    return this.withDatabase(async () => {
      const conditions = [eq(componentTable.entityId, entityId), eq(componentTable.type, type)];
      if (worldId) {
        conditions.push(eq(componentTable.worldId, worldId));
      }
      if (sourceEntityId) {
        conditions.push(eq(componentTable.sourceEntityId, sourceEntityId));
      }
      const result = await this.db.select().from(componentTable).where(and(...conditions));
      if (result.length === 0) return null;
      const component = result[0];
      return {
        ...component,
        id: component.id,
        entityId: component.entityId,
        agentId: component.agentId,
        roomId: component.roomId,
        worldId: component.worldId ?? "",
        sourceEntityId: component.sourceEntityId ?? "",
        data: component.data,
        createdAt: component.createdAt.getTime()
      };
    });
  }
  /**
   * Asynchronously retrieves all components for a given entity, optionally filtered by world and source entity.
   * @param {UUID} entityId - The unique identifier of the entity to retrieve components for
   * @param {UUID} [worldId] - Optional world ID to filter components by
   * @param {UUID} [sourceEntityId] - Optional source entity ID to filter components by
   * @returns {Promise<Component[]>} A Promise that resolves to an array of components
   */
  async getComponents(entityId, worldId, sourceEntityId) {
    return this.withDatabase(async () => {
      const conditions = [eq(componentTable.entityId, entityId)];
      if (worldId) {
        conditions.push(eq(componentTable.worldId, worldId));
      }
      if (sourceEntityId) {
        conditions.push(eq(componentTable.sourceEntityId, sourceEntityId));
      }
      const result = await this.db.select({
        id: componentTable.id,
        entityId: componentTable.entityId,
        type: componentTable.type,
        data: componentTable.data,
        worldId: componentTable.worldId,
        agentId: componentTable.agentId,
        roomId: componentTable.roomId,
        sourceEntityId: componentTable.sourceEntityId,
        createdAt: componentTable.createdAt
      }).from(componentTable).where(and(...conditions));
      if (result.length === 0) return [];
      const components = result.map((component) => ({
        ...component,
        id: component.id,
        entityId: component.entityId,
        agentId: component.agentId,
        roomId: component.roomId,
        worldId: component.worldId ?? "",
        sourceEntityId: component.sourceEntityId ?? "",
        data: component.data,
        createdAt: component.createdAt.getTime()
      }));
      return components;
    });
  }
  /**
   * Asynchronously creates a new component in the database.
   * @param {Component} component - The component object to be created.
   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating the success of the operation.
   */
  async createComponent(component) {
    return this.withDatabase(async () => {
      await this.db.insert(componentTable).values({
        ...component,
        createdAt: new Date(component.createdAt)
      });
      return true;
    });
  }
  /**
   * Asynchronously updates an existing component in the database.
   * @param {Component} component - The component object to be updated.
   * @returns {Promise<void>} A Promise that resolves when the component is updated.
   */
  async updateComponent(component) {
    return this.withDatabase(async () => {
      await this.db.update(componentTable).set({
        ...component,
        createdAt: new Date(component.createdAt)
      }).where(eq(componentTable.id, component.id));
    });
  }
  /**
   * Asynchronously deletes a component from the database.
   * @param {UUID} componentId - The unique identifier of the component to delete.
   * @returns {Promise<void>} A Promise that resolves when the component is deleted.
   */
  async deleteComponent(componentId) {
    return this.withDatabase(async () => {
      await this.db.delete(componentTable).where(eq(componentTable.id, componentId));
    });
  }
  /**
   * Asynchronously retrieves memories from the database based on the provided parameters.
   * @param {Object} params - The parameters for retrieving memories.
   * @param {UUID} params.roomId - The ID of the room to retrieve memories for.
   * @param {number} [params.count] - The maximum number of memories to retrieve.
   * @param {boolean} [params.unique] - Whether to retrieve unique memories only.
   * @param {string} [params.tableName] - The name of the table to retrieve memories from.
   * @param {number} [params.start] - The start date to retrieve memories from.
   * @param {number} [params.end] - The end date to retrieve memories from.
   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.
   */
  async getMemories(params) {
    const { entityId, agentId, roomId, worldId, tableName, unique: unique4, start, end } = params;
    if (!tableName) throw new Error("tableName is required");
    return this.withDatabase(async () => {
      const conditions = [eq(memoryTable.type, tableName)];
      if (start) {
        conditions.push(gte(memoryTable.createdAt, new Date(start)));
      }
      if (entityId) {
        conditions.push(eq(memoryTable.entityId, entityId));
      }
      if (roomId) {
        conditions.push(eq(memoryTable.roomId, roomId));
      }
      if (worldId) {
        conditions.push(eq(memoryTable.worldId, worldId));
      }
      if (end) {
        conditions.push(lte(memoryTable.createdAt, new Date(end)));
      }
      if (unique4) {
        conditions.push(eq(memoryTable.unique, true));
      }
      if (agentId) {
        conditions.push(eq(memoryTable.agentId, agentId));
      }
      const query = this.db.select({
        memory: {
          id: memoryTable.id,
          type: memoryTable.type,
          createdAt: memoryTable.createdAt,
          content: memoryTable.content,
          entityId: memoryTable.entityId,
          agentId: memoryTable.agentId,
          roomId: memoryTable.roomId,
          unique: memoryTable.unique,
          metadata: memoryTable.metadata
        },
        embedding: embeddingTable[this.embeddingDimension]
      }).from(memoryTable).leftJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id)).where(and(...conditions)).orderBy(desc(memoryTable.createdAt));
      const rows = params.count ? await query.limit(params.count) : await query;
      return rows.map((row) => ({
        id: row.memory.id,
        type: row.memory.type,
        createdAt: row.memory.createdAt.getTime(),
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ? Array.from(row.embedding) : void 0
      }));
    });
  }
  /**
   * Asynchronously retrieves memories from the database based on the provided parameters.
   * @param {Object} params - The parameters for retrieving memories.
   * @param {UUID[]} params.roomIds - The IDs of the rooms to retrieve memories for.
   * @param {string} params.tableName - The name of the table to retrieve memories from.
   * @param {number} [params.limit] - The maximum number of memories to retrieve.
   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.
   */
  async getMemoriesByRoomIds(params) {
    return this.withDatabase(async () => {
      if (params.roomIds.length === 0) return [];
      const conditions = [
        eq(memoryTable.type, params.tableName),
        inArray(memoryTable.roomId, params.roomIds)
      ];
      conditions.push(eq(memoryTable.agentId, this.agentId));
      const query = this.db.select({
        id: memoryTable.id,
        type: memoryTable.type,
        createdAt: memoryTable.createdAt,
        content: memoryTable.content,
        entityId: memoryTable.entityId,
        agentId: memoryTable.agentId,
        roomId: memoryTable.roomId,
        unique: memoryTable.unique,
        metadata: memoryTable.metadata
      }).from(memoryTable).where(and(...conditions)).orderBy(desc(memoryTable.createdAt));
      const rows = params.limit ? await query.limit(params.limit) : await query;
      return rows.map((row) => ({
        id: row.id,
        createdAt: row.createdAt.getTime(),
        content: typeof row.content === "string" ? JSON.parse(row.content) : row.content,
        entityId: row.entityId,
        agentId: row.agentId,
        roomId: row.roomId,
        unique: row.unique,
        metadata: row.metadata
      }));
    });
  }
  /**
   * Asynchronously retrieves a memory by its unique identifier.
   * @param {UUID} id - The unique identifier of the memory to retrieve.
   * @returns {Promise<Memory | null>} A Promise that resolves to the memory if found, null otherwise.
   */
  async getMemoryById(id) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        memory: memoryTable,
        embedding: embeddingTable[this.embeddingDimension]
      }).from(memoryTable).leftJoin(embeddingTable, eq(memoryTable.id, embeddingTable.memoryId)).where(eq(memoryTable.id, id)).limit(1);
      if (result.length === 0) return null;
      const row = result[0];
      return {
        id: row.memory.id,
        createdAt: row.memory.createdAt.getTime(),
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ?? void 0
      };
    });
  }
  /**
   * Asynchronously retrieves memories from the database based on the provided parameters.
   * @param {Object} params - The parameters for retrieving memories.
   * @param {UUID[]} params.memoryIds - The IDs of the memories to retrieve.
   * @param {string} [params.tableName] - The name of the table to retrieve memories from.
   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.
   */
  async getMemoriesByIds(memoryIds, tableName) {
    return this.withDatabase(async () => {
      if (memoryIds.length === 0) return [];
      const conditions = [inArray(memoryTable.id, memoryIds)];
      if (tableName) {
        conditions.push(eq(memoryTable.type, tableName));
      }
      const rows = await this.db.select({
        memory: memoryTable,
        embedding: embeddingTable[this.embeddingDimension]
      }).from(memoryTable).leftJoin(embeddingTable, eq(embeddingTable.memoryId, memoryTable.id)).where(and(...conditions)).orderBy(desc(memoryTable.createdAt));
      return rows.map((row) => ({
        id: row.memory.id,
        createdAt: row.memory.createdAt.getTime(),
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ?? void 0
      }));
    });
  }
  /**
   * Asynchronously retrieves cached embeddings from the database based on the provided parameters.
   * @param {Object} opts - The parameters for retrieving cached embeddings.
   * @param {string} opts.query_table_name - The name of the table to retrieve embeddings from.
   * @param {number} opts.query_threshold - The threshold for the levenshtein distance.
   * @param {string} opts.query_input - The input string to search for.
   * @param {string} opts.query_field_name - The name of the field to retrieve embeddings from.
   * @param {string} opts.query_field_sub_name - The name of the sub-field to retrieve embeddings from.
   * @param {number} opts.query_match_count - The maximum number of matches to retrieve.
   * @returns {Promise<{ embedding: number[]; levenshtein_score: number }[]>} A Promise that resolves to an array of cached embeddings.
   */
  async getCachedEmbeddings(opts) {
    return this.withDatabase(async () => {
      try {
        const results = await this.db.execute(sql16`
                    WITH content_text AS (
                        SELECT
                            m.id,
                            COALESCE(
                                m.content->>${opts.query_field_sub_name},
                                ''
                            ) as content_text
                        FROM memories m
                        WHERE m.type = ${opts.query_table_name}
                            AND m.content->>${opts.query_field_sub_name} IS NOT NULL
                    ),
                    embedded_text AS (
                        SELECT
                            ct.content_text,
                            COALESCE(
                                e.dim_384,
                                e.dim_512,
                                e.dim_768,
                                e.dim_1024,
                                e.dim_1536,
                                e.dim_3072
                            ) as embedding
                        FROM content_text ct
                        LEFT JOIN embeddings e ON e.memory_id = ct.id
                        WHERE e.memory_id IS NOT NULL
                    )
                    SELECT
                        embedding,
                        levenshtein(${opts.query_input}, content_text) as levenshtein_score
                    FROM embedded_text
                    WHERE levenshtein(${opts.query_input}, content_text) <= ${opts.query_threshold}
                    ORDER BY levenshtein_score
                    LIMIT ${opts.query_match_count}
                `);
        return results.rows.map((row) => ({
          embedding: Array.isArray(row.embedding) ? row.embedding : typeof row.embedding === "string" ? JSON.parse(row.embedding) : [],
          levenshtein_score: Number(row.levenshtein_score)
        })).filter((row) => Array.isArray(row.embedding));
      } catch (error) {
        logger.error("Error in getCachedEmbeddings:", {
          error: error instanceof Error ? error.message : String(error),
          tableName: opts.query_table_name,
          fieldName: opts.query_field_name
        });
        if (error instanceof Error && error.message === "levenshtein argument exceeds maximum length of 255 characters") {
          return [];
        }
        throw error;
      }
    });
  }
  /**
   * Asynchronously logs an event in the database.
   * @param {Object} params - The parameters for logging an event.
   * @param {Object} params.body - The body of the event to log.
   * @param {UUID} params.entityId - The ID of the entity associated with the event.
   * @param {UUID} params.roomId - The ID of the room associated with the event.
   * @param {string} params.type - The type of the event to log.
   * @returns {Promise<void>} A Promise that resolves when the event is logged.
   */
  async log(params) {
    return this.withDatabase(async () => {
      try {
        const sanitizedBody = this.sanitizeJsonObject(params.body);
        const jsonString = JSON.stringify(sanitizedBody);
        await this.db.transaction(async (tx) => {
          await tx.insert(logTable).values({
            body: sql16`${jsonString}::jsonb`,
            entityId: params.entityId,
            roomId: params.roomId,
            type: params.type
          });
        });
      } catch (error) {
        logger.error("Failed to create log entry:", {
          error: error instanceof Error ? error.message : String(error),
          type: params.type,
          roomId: params.roomId,
          entityId: params.entityId
        });
        throw error;
      }
    });
  }
  /**
   * Sanitizes a JSON object by replacing problematic Unicode escape sequences
   * that could cause errors during JSON serialization/storage
   *
   * @param value - The value to sanitize
   * @returns The sanitized value
   */
  sanitizeJsonObject(value, seen = /* @__PURE__ */ new WeakSet()) {
    if (value === null || value === void 0) {
      return value;
    }
    if (typeof value === "string") {
      return value.replace(/\u0000/g, "").replace(/\\(?!["\\/bfnrtu])/g, "\\\\").replace(/\\u(?![0-9a-fA-F]{4})/g, "\\\\u");
    }
    if (typeof value === "object") {
      if (seen.has(value)) {
        return null;
      } else {
        seen.add(value);
      }
      if (Array.isArray(value)) {
        return value.map((item) => this.sanitizeJsonObject(item, seen));
      } else {
        const result = {};
        for (const [key, val] of Object.entries(value)) {
          const sanitizedKey = typeof key === "string" ? key.replace(/\u0000/g, "").replace(/\\u(?![0-9a-fA-F]{4})/g, "\\\\u") : key;
          result[sanitizedKey] = this.sanitizeJsonObject(val, seen);
        }
        return result;
      }
    }
    return value;
  }
  /**
   * Asynchronously retrieves logs from the database based on the provided parameters.
   * @param {Object} params - The parameters for retrieving logs.
   * @param {UUID} params.entityId - The ID of the entity associated with the logs.
   * @param {UUID} [params.roomId] - The ID of the room associated with the logs.
   * @param {string} [params.type] - The type of the logs to retrieve.
   * @param {number} [params.count] - The maximum number of logs to retrieve.
   * @param {number} [params.offset] - The offset to retrieve logs from.
   * @returns {Promise<Log[]>} A Promise that resolves to an array of logs.
   */
  async getLogs(params) {
    const { entityId, roomId, type, count: count2, offset } = params;
    return this.withDatabase(async () => {
      const result = await this.db.select().from(logTable).where(
        and(
          eq(logTable.entityId, entityId),
          roomId ? eq(logTable.roomId, roomId) : void 0,
          type ? eq(logTable.type, type) : void 0
        )
      ).orderBy(desc(logTable.createdAt)).limit(count2 ?? 10).offset(offset ?? 0);
      const logs = result.map((log) => ({
        ...log,
        id: log.id,
        entityId: log.entityId,
        roomId: log.roomId,
        body: log.body,
        createdAt: new Date(log.createdAt)
      }));
      if (logs.length === 0) return [];
      return logs;
    });
  }
  /**
   * Asynchronously deletes a log from the database based on the provided parameters.
   * @param {UUID} logId - The ID of the log to delete.
   * @returns {Promise<void>} A Promise that resolves when the log is deleted.
   */
  async deleteLog(logId) {
    return this.withDatabase(async () => {
      await this.db.delete(logTable).where(eq(logTable.id, logId));
    });
  }
  /**
   * Asynchronously searches for memories in the database based on the provided parameters.
   * @param {Object} params - The parameters for searching for memories.
   * @param {string} params.tableName - The name of the table to search for memories in.
   * @param {number[]} params.embedding - The embedding to search for.
   * @param {number} [params.match_threshold] - The threshold for the cosine distance.
   * @param {number} [params.count] - The maximum number of memories to retrieve.
   * @param {boolean} [params.unique] - Whether to retrieve unique memories only.
   * @param {string} [params.query] - Optional query string for potential reranking.
   * @param {UUID} [params.roomId] - Optional room ID to filter by.
   * @param {UUID} [params.worldId] - Optional world ID to filter by.
   * @param {UUID} [params.entityId] - Optional entity ID to filter by.
   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.
   */
  async searchMemories(params) {
    return await this.searchMemoriesByEmbedding(params.embedding, {
      match_threshold: params.match_threshold,
      count: params.count,
      // Pass direct scope fields down
      roomId: params.roomId,
      worldId: params.worldId,
      entityId: params.entityId,
      unique: params.unique,
      tableName: params.tableName
    });
  }
  /**
   * Asynchronously searches for memories in the database based on the provided parameters.
   * @param {number[]} embedding - The embedding to search for.
   * @param {Object} params - The parameters for searching for memories.
   * @param {number} [params.match_threshold] - The threshold for the cosine distance.
   * @param {number} [params.count] - The maximum number of memories to retrieve.
   * @param {UUID} [params.roomId] - Optional room ID to filter by.
   * @param {UUID} [params.worldId] - Optional world ID to filter by.
   * @param {UUID} [params.entityId] - Optional entity ID to filter by.
   * @param {boolean} [params.unique] - Whether to retrieve unique memories only.
   * @param {string} [params.tableName] - The name of the table to search for memories in.
   * @returns {Promise<Memory[]>} A Promise that resolves to an array of memories.
   */
  async searchMemoriesByEmbedding(embedding, params) {
    return this.withDatabase(async () => {
      const cleanVector = embedding.map((n) => Number.isFinite(n) ? Number(n.toFixed(6)) : 0);
      const similarity = sql16`1 - (${cosineDistance(
        embeddingTable[this.embeddingDimension],
        cleanVector
      )})`;
      const conditions = [eq(memoryTable.type, params.tableName)];
      if (params.unique) {
        conditions.push(eq(memoryTable.unique, true));
      }
      conditions.push(eq(memoryTable.agentId, this.agentId));
      if (params.roomId) {
        conditions.push(eq(memoryTable.roomId, params.roomId));
      }
      if (params.worldId) {
        conditions.push(eq(memoryTable.worldId, params.worldId));
      }
      if (params.entityId) {
        conditions.push(eq(memoryTable.entityId, params.entityId));
      }
      if (params.match_threshold) {
        conditions.push(gte(similarity, params.match_threshold));
      }
      const results = await this.db.select({
        memory: memoryTable,
        similarity,
        embedding: embeddingTable[this.embeddingDimension]
      }).from(embeddingTable).innerJoin(memoryTable, eq(memoryTable.id, embeddingTable.memoryId)).where(and(...conditions)).orderBy(desc(similarity)).limit(params.count ?? 10);
      return results.map((row) => ({
        id: row.memory.id,
        type: row.memory.type,
        createdAt: row.memory.createdAt.getTime(),
        content: typeof row.memory.content === "string" ? JSON.parse(row.memory.content) : row.memory.content,
        entityId: row.memory.entityId,
        agentId: row.memory.agentId,
        roomId: row.memory.roomId,
        worldId: row.memory.worldId,
        // Include worldId
        unique: row.memory.unique,
        metadata: row.memory.metadata,
        embedding: row.embedding ?? void 0,
        similarity: row.similarity
      }));
    });
  }
  /**
   * Asynchronously creates a new memory in the database.
   * @param {Memory & { metadata?: MemoryMetadata }} memory - The memory object to create.
   * @param {string} tableName - The name of the table to create the memory in.
   * @returns {Promise<UUID>} A Promise that resolves to the ID of the created memory.
   */
  async createMemory(memory, tableName) {
    logger.debug("DrizzleAdapter createMemory:", {
      memoryId: memory.id,
      embeddingLength: memory.embedding?.length,
      contentLength: memory.content?.text?.length
    });
    const memoryId = memory.id ?? v4();
    const existing = await this.getMemoryById(memoryId);
    if (existing) {
      logger.debug("Memory already exists, skipping creation:", {
        memoryId
      });
      return memoryId;
    }
    let isUnique = true;
    if (memory.embedding && Array.isArray(memory.embedding)) {
      const similarMemories = await this.searchMemoriesByEmbedding(memory.embedding, {
        tableName,
        // Use the scope fields from the memory object for similarity check
        roomId: memory.roomId,
        worldId: memory.worldId,
        entityId: memory.entityId,
        match_threshold: 0.95,
        count: 1
      });
      isUnique = similarMemories.length === 0;
    }
    const contentToInsert = typeof memory.content === "string" ? JSON.parse(memory.content) : memory.content;
    await this.db.transaction(async (tx) => {
      await tx.insert(memoryTable).values([
        {
          id: memoryId,
          type: tableName,
          content: sql16`${contentToInsert}::jsonb`,
          metadata: sql16`${memory.metadata || {}}::jsonb`,
          entityId: memory.entityId,
          roomId: memory.roomId,
          worldId: memory.worldId,
          // Include worldId
          agentId: memory.agentId || this.agentId,
          unique: memory.unique ?? isUnique,
          createdAt: memory.createdAt ? new Date(memory.createdAt) : /* @__PURE__ */ new Date()
        }
      ]);
      if (memory.embedding && Array.isArray(memory.embedding)) {
        const embeddingValues = {
          id: v4(),
          memoryId,
          createdAt: memory.createdAt ? new Date(memory.createdAt) : /* @__PURE__ */ new Date()
        };
        const cleanVector = memory.embedding.map(
          (n) => Number.isFinite(n) ? Number(n.toFixed(6)) : 0
        );
        embeddingValues[this.embeddingDimension] = cleanVector;
        await tx.insert(embeddingTable).values([embeddingValues]);
      }
    });
    return memoryId;
  }
  /**
   * Updates an existing memory in the database.
   * @param memory The memory object with updated content and optional embedding
   * @returns Promise resolving to boolean indicating success
   */
  async updateMemory(memory) {
    return this.withDatabase(async () => {
      try {
        logger.debug("Updating memory:", {
          memoryId: memory.id,
          hasEmbedding: !!memory.embedding
        });
        await this.db.transaction(async (tx) => {
          if (memory.content) {
            const contentToUpdate = typeof memory.content === "string" ? JSON.parse(memory.content) : memory.content;
            await tx.update(memoryTable).set({
              content: sql16`${contentToUpdate}::jsonb`,
              ...memory.metadata && { metadata: sql16`${memory.metadata}::jsonb` }
            }).where(eq(memoryTable.id, memory.id));
          } else if (memory.metadata) {
            await tx.update(memoryTable).set({
              metadata: sql16`${memory.metadata}::jsonb`
            }).where(eq(memoryTable.id, memory.id));
          }
          if (memory.embedding && Array.isArray(memory.embedding)) {
            const cleanVector = memory.embedding.map(
              (n) => Number.isFinite(n) ? Number(n.toFixed(6)) : 0
            );
            const existingEmbedding = await tx.select({ id: embeddingTable.id }).from(embeddingTable).where(eq(embeddingTable.memoryId, memory.id)).limit(1);
            if (existingEmbedding.length > 0) {
              const updateValues = {};
              updateValues[this.embeddingDimension] = cleanVector;
              await tx.update(embeddingTable).set(updateValues).where(eq(embeddingTable.memoryId, memory.id));
            } else {
              const embeddingValues = {
                id: v4(),
                memoryId: memory.id
              };
              embeddingValues[this.embeddingDimension] = cleanVector;
              await tx.insert(embeddingTable).values([embeddingValues]);
            }
          }
        });
        logger.debug("Memory updated successfully:", {
          memoryId: memory.id
        });
        return true;
      } catch (error) {
        logger.error("Error updating memory:", {
          error: error instanceof Error ? error.message : String(error),
          memoryId: memory.id
        });
        return false;
      }
    });
  }
  /**
   * Asynchronously deletes a memory from the database based on the provided parameters.
   * @param {UUID} memoryId - The ID of the memory to delete.
   * @returns {Promise<void>} A Promise that resolves when the memory is deleted.
   */
  async deleteMemory(memoryId) {
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        await this.deleteMemoryFragments(tx, memoryId);
        await tx.delete(embeddingTable).where(eq(embeddingTable.memoryId, memoryId));
        await tx.delete(memoryTable).where(eq(memoryTable.id, memoryId));
      });
      logger.debug("Memory and related fragments removed successfully:", {
        memoryId
      });
    });
  }
  /**
   * Asynchronously deletes multiple memories from the database in a single batch operation.
   * @param {UUID[]} memoryIds - An array of UUIDs of the memories to delete.
   * @returns {Promise<void>} A Promise that resolves when all memories are deleted.
   */
  async deleteManyMemories(memoryIds) {
    if (memoryIds.length === 0) {
      return;
    }
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        const BATCH_SIZE = 100;
        for (let i = 0; i < memoryIds.length; i += BATCH_SIZE) {
          const batch = memoryIds.slice(i, i + BATCH_SIZE);
          await Promise.all(
            batch.map(async (memoryId) => {
              await this.deleteMemoryFragments(tx, memoryId);
            })
          );
          await tx.delete(embeddingTable).where(inArray(embeddingTable.memoryId, batch));
          await tx.delete(memoryTable).where(inArray(memoryTable.id, batch));
        }
      });
      logger.debug("Batch memory deletion completed successfully:", {
        count: memoryIds.length
      });
    });
  }
  /**
   * Deletes all memory fragments that reference a specific document memory
   * @param tx The database transaction
   * @param documentId The UUID of the document memory whose fragments should be deleted
   * @private
   */
  async deleteMemoryFragments(tx, documentId) {
    const fragmentsToDelete = await this.getMemoryFragments(tx, documentId);
    if (fragmentsToDelete.length > 0) {
      const fragmentIds = fragmentsToDelete.map((f) => f.id);
      await tx.delete(embeddingTable).where(inArray(embeddingTable.memoryId, fragmentIds));
      await tx.delete(memoryTable).where(inArray(memoryTable.id, fragmentIds));
      logger.debug("Deleted related fragments:", {
        documentId,
        fragmentCount: fragmentsToDelete.length
      });
    }
  }
  /**
   * Retrieves all memory fragments that reference a specific document memory
   * @param tx The database transaction
   * @param documentId The UUID of the document memory whose fragments should be retrieved
   * @returns An array of memory fragments
   * @private
   */
  async getMemoryFragments(tx, documentId) {
    const fragments = await tx.select({ id: memoryTable.id }).from(memoryTable).where(
      and(
        eq(memoryTable.agentId, this.agentId),
        sql16`${memoryTable.metadata}->>'documentId' = ${documentId}`
      )
    );
    return fragments.map((f) => ({ id: f.id }));
  }
  /**
   * Asynchronously deletes all memories from the database based on the provided parameters.
   * @param {UUID} roomId - The ID of the room to delete memories from.
   * @param {string} tableName - The name of the table to delete memories from.
   * @returns {Promise<void>} A Promise that resolves when the memories are deleted.
   */
  async deleteAllMemories(roomId, tableName) {
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        const rows = await tx.select({ id: memoryTable.id }).from(memoryTable).where(and(eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)));
        const ids = rows.map((r) => r.id);
        logger.debug("[deleteAllMemories] memory IDs to delete:", { roomId, tableName, ids });
        if (ids.length === 0) {
          return;
        }
        await Promise.all(
          ids.map(async (memoryId) => {
            await this.deleteMemoryFragments(tx, memoryId);
            await tx.delete(embeddingTable).where(eq(embeddingTable.memoryId, memoryId));
          })
        );
        await tx.delete(memoryTable).where(and(eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)));
      });
      logger.debug("All memories removed successfully:", { roomId, tableName });
    });
  }
  /**
   * Asynchronously counts the number of memories in the database based on the provided parameters.
   * @param {UUID} roomId - The ID of the room to count memories in.
   * @param {boolean} [unique] - Whether to count unique memories only.
   * @param {string} [tableName] - The name of the table to count memories in.
   * @returns {Promise<number>} A Promise that resolves to the number of memories.
   */
  async countMemories(roomId, unique4 = true, tableName = "") {
    if (!tableName) throw new Error("tableName is required");
    return this.withDatabase(async () => {
      const conditions = [eq(memoryTable.roomId, roomId), eq(memoryTable.type, tableName)];
      if (unique4) {
        conditions.push(eq(memoryTable.unique, true));
      }
      const result = await this.db.select({ count: sql16`count(*)` }).from(memoryTable).where(and(...conditions));
      return Number(result[0]?.count ?? 0);
    });
  }
  /**
   * Asynchronously retrieves rooms from the database based on the provided parameters.
   * @param {UUID[]} roomIds - The IDs of the rooms to retrieve.
   * @returns {Promise<Room[] | null>} A Promise that resolves to the rooms if found, null otherwise.
   */
  async getRoomsByIds(roomIds) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        id: roomTable.id,
        name: roomTable.name,
        // Added name
        channelId: roomTable.channelId,
        agentId: roomTable.agentId,
        serverId: roomTable.serverId,
        worldId: roomTable.worldId,
        type: roomTable.type,
        source: roomTable.source,
        metadata: roomTable.metadata
        // Added metadata
      }).from(roomTable).where(and(inArray(roomTable.id, roomIds), eq(roomTable.agentId, this.agentId)));
      const rooms = result.map((room) => ({
        ...room,
        id: room.id,
        name: room.name ?? void 0,
        agentId: room.agentId,
        serverId: room.serverId,
        worldId: room.worldId,
        channelId: room.channelId,
        type: room.type,
        metadata: room.metadata
      }));
      return rooms;
    });
  }
  /**
   * Asynchronously retrieves all rooms from the database based on the provided parameters.
   * @param {UUID} worldId - The ID of the world to retrieve rooms from.
   * @returns {Promise<Room[]>} A Promise that resolves to an array of rooms.
   */
  async getRoomsByWorld(worldId) {
    return this.withDatabase(async () => {
      const result = await this.db.select().from(roomTable).where(eq(roomTable.worldId, worldId));
      const rooms = result.map((room) => ({
        ...room,
        id: room.id,
        name: room.name ?? void 0,
        agentId: room.agentId,
        serverId: room.serverId,
        worldId: room.worldId,
        channelId: room.channelId,
        type: room.type,
        metadata: room.metadata
      }));
      return rooms;
    });
  }
  /**
   * Asynchronously updates a room in the database based on the provided parameters.
   * @param {Room} room - The room object to update.
   * @returns {Promise<void>} A Promise that resolves when the room is updated.
   */
  async updateRoom(room) {
    return this.withDatabase(async () => {
      await this.db.update(roomTable).set({ ...room, agentId: this.agentId }).where(eq(roomTable.id, room.id));
    });
  }
  /**
   * Asynchronously creates a new room in the database based on the provided parameters.
   * @param {Room} room - The room object to create.
   * @returns {Promise<UUID>} A Promise that resolves to the ID of the created room.
   */
  async createRooms(rooms) {
    return this.withDatabase(async () => {
      const roomsWithIds = rooms.map((room) => ({
        ...room,
        agentId: this.agentId,
        id: room.id || v4()
        // ensure each room has a unique ID
      }));
      const insertedRooms = await this.db.insert(roomTable).values(roomsWithIds).onConflictDoNothing().returning();
      const insertedIds = insertedRooms.map((r) => r.id);
      return insertedIds;
    });
  }
  /**
   * Asynchronously deletes a room from the database based on the provided parameters.
   * @param {UUID} roomId - The ID of the room to delete.
   * @returns {Promise<void>} A Promise that resolves when the room is deleted.
   */
  async deleteRoom(roomId) {
    if (!roomId) throw new Error("Room ID is required");
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        await tx.delete(roomTable).where(eq(roomTable.id, roomId));
      });
    });
  }
  /**
   * Asynchronously retrieves all rooms for a participant from the database based on the provided parameters.
   * @param {UUID} entityId - The ID of the entity to retrieve rooms for.
   * @returns {Promise<UUID[]>} A Promise that resolves to an array of room IDs.
   */
  async getRoomsForParticipant(entityId) {
    console.log("getRoomsForParticipant", entityId);
    return this.withDatabase(async () => {
      const result = await this.db.select({ roomId: participantTable.roomId }).from(participantTable).innerJoin(roomTable, eq(participantTable.roomId, roomTable.id)).where(and(eq(participantTable.entityId, entityId), eq(roomTable.agentId, this.agentId)));
      return result.map((row) => row.roomId);
    });
  }
  /**
   * Asynchronously retrieves all rooms for a list of participants from the database based on the provided parameters.
   * @param {UUID[]} entityIds - The IDs of the entities to retrieve rooms for.
   * @returns {Promise<UUID[]>} A Promise that resolves to an array of room IDs.
   */
  async getRoomsForParticipants(entityIds) {
    return this.withDatabase(async () => {
      const result = await this.db.selectDistinct({ roomId: participantTable.roomId }).from(participantTable).innerJoin(roomTable, eq(participantTable.roomId, roomTable.id)).where(
        and(inArray(participantTable.entityId, entityIds), eq(roomTable.agentId, this.agentId))
      );
      return result.map((row) => row.roomId);
    });
  }
  /**
   * Asynchronously adds a participant to a room in the database based on the provided parameters.
   * @param {UUID} entityId - The ID of the entity to add to the room.
   * @param {UUID} roomId - The ID of the room to add the entity to.
   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the participant was added successfully.
   */
  async addParticipant(entityId, roomId) {
    return this.withDatabase(async () => {
      try {
        await this.db.insert(participantTable).values({
          entityId,
          roomId,
          agentId: this.agentId
        }).onConflictDoNothing();
        return true;
      } catch (error) {
        logger.error("Error adding participant", {
          error: error instanceof Error ? error.message : String(error),
          entityId,
          roomId,
          agentId: this.agentId
        });
        return false;
      }
    });
  }
  async addParticipantsRoom(entityIds, roomId) {
    return this.withDatabase(async () => {
      try {
        const values = entityIds.map((id) => ({
          entityId: id,
          roomId,
          agentId: this.agentId
        }));
        await this.db.insert(participantTable).values(values).onConflictDoNothing().execute();
        logger.debug(entityIds.length, "Entities linked successfully");
        return true;
      } catch (error) {
        logger.error("Error adding participants", {
          error: error instanceof Error ? error.message : String(error),
          entityIdSample: entityIds[0],
          roomId,
          agentId: this.agentId
        });
        return false;
      }
    });
  }
  /**
   * Asynchronously removes a participant from a room in the database based on the provided parameters.
   * @param {UUID} entityId - The ID of the entity to remove from the room.
   * @param {UUID} roomId - The ID of the room to remove the entity from.
   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the participant was removed successfully.
   */
  async removeParticipant(entityId, roomId) {
    return this.withDatabase(async () => {
      try {
        const result = await this.db.transaction(async (tx) => {
          return await tx.delete(participantTable).where(
            and(eq(participantTable.entityId, entityId), eq(participantTable.roomId, roomId))
          ).returning();
        });
        const removed = result.length > 0;
        logger.debug(`Participant ${removed ? "removed" : "not found"}:`, {
          entityId,
          roomId,
          removed
        });
        return removed;
      } catch (error) {
        logger.error("Failed to remove participant:", {
          error: error instanceof Error ? error.message : String(error),
          entityId,
          roomId
        });
        return false;
      }
    });
  }
  /**
   * Asynchronously retrieves all participants for an entity from the database based on the provided parameters.
   * @param {UUID} entityId - The ID of the entity to retrieve participants for.
   * @returns {Promise<Participant[]>} A Promise that resolves to an array of participants.
   */
  async getParticipantsForEntity(entityId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({
        id: participantTable.id,
        entityId: participantTable.entityId,
        roomId: participantTable.roomId
      }).from(participantTable).where(eq(participantTable.entityId, entityId));
      const entities = await this.getEntityByIds([entityId]);
      if (!entities || !entities.length) {
        return [];
      }
      return result.map((row) => ({
        id: row.id,
        entity: entities[0]
      }));
    });
  }
  /**
   * Asynchronously retrieves all participants for a room from the database based on the provided parameters.
   * @param {UUID} roomId - The ID of the room to retrieve participants for.
   * @returns {Promise<UUID[]>} A Promise that resolves to an array of entity IDs.
   */
  async getParticipantsForRoom(roomId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({ entityId: participantTable.entityId }).from(participantTable).where(eq(participantTable.roomId, roomId));
      return result.map((row) => row.entityId);
    });
  }
  /**
   * Asynchronously retrieves the user state for a participant in a room from the database based on the provided parameters.
   * @param {UUID} roomId - The ID of the room to retrieve the participant's user state for.
   * @param {UUID} entityId - The ID of the entity to retrieve the user state for.
   * @returns {Promise<"FOLLOWED" | "MUTED" | null>} A Promise that resolves to the participant's user state.
   */
  async getParticipantUserState(roomId, entityId) {
    return this.withDatabase(async () => {
      const result = await this.db.select({ roomState: participantTable.roomState }).from(participantTable).where(
        and(
          eq(participantTable.roomId, roomId),
          eq(participantTable.entityId, entityId),
          eq(participantTable.agentId, this.agentId)
        )
      ).limit(1);
      return result[0]?.roomState ?? null;
    });
  }
  /**
   * Asynchronously sets the user state for a participant in a room in the database based on the provided parameters.
   * @param {UUID} roomId - The ID of the room to set the participant's user state for.
   * @param {UUID} entityId - The ID of the entity to set the user state for.
   * @param {string} state - The state to set the participant's user state to.
   * @returns {Promise<void>} A Promise that resolves when the participant's user state is set.
   */
  async setParticipantUserState(roomId, entityId, state) {
    return this.withDatabase(async () => {
      try {
        await this.db.transaction(async (tx) => {
          await tx.update(participantTable).set({ roomState: state }).where(
            and(
              eq(participantTable.roomId, roomId),
              eq(participantTable.entityId, entityId),
              eq(participantTable.agentId, this.agentId)
            )
          );
        });
      } catch (error) {
        logger.error("Failed to set participant user state:", {
          roomId,
          entityId,
          state,
          error: error instanceof Error ? error.message : String(error)
        });
        throw error;
      }
    });
  }
  /**
   * Asynchronously creates a new relationship in the database based on the provided parameters.
   * @param {Object} params - The parameters for creating a new relationship.
   * @param {UUID} params.sourceEntityId - The ID of the source entity.
   * @param {UUID} params.targetEntityId - The ID of the target entity.
   * @param {string[]} [params.tags] - The tags for the relationship.
   * @param {Object} [params.metadata] - The metadata for the relationship.
   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the relationship was created successfully.
   */
  async createRelationship(params) {
    return this.withDatabase(async () => {
      const id = v4();
      const saveParams = {
        id,
        sourceEntityId: params.sourceEntityId,
        targetEntityId: params.targetEntityId,
        agentId: this.agentId,
        tags: params.tags || [],
        metadata: params.metadata || {}
      };
      try {
        await this.db.insert(relationshipTable).values(saveParams);
        return true;
      } catch (error) {
        logger.error("Error creating relationship:", {
          error: error instanceof Error ? error.message : String(error),
          saveParams
        });
        return false;
      }
    });
  }
  /**
   * Asynchronously updates an existing relationship in the database based on the provided parameters.
   * @param {Relationship} relationship - The relationship object to update.
   * @returns {Promise<void>} A Promise that resolves when the relationship is updated.
   */
  async updateRelationship(relationship) {
    return this.withDatabase(async () => {
      try {
        await this.db.update(relationshipTable).set({
          tags: relationship.tags || [],
          metadata: relationship.metadata || {}
        }).where(eq(relationshipTable.id, relationship.id));
      } catch (error) {
        logger.error("Error updating relationship:", {
          error: error instanceof Error ? error.message : String(error),
          relationship
        });
        throw error;
      }
    });
  }
  /**
   * Asynchronously retrieves a relationship from the database based on the provided parameters.
   * @param {Object} params - The parameters for retrieving a relationship.
   * @param {UUID} params.sourceEntityId - The ID of the source entity.
   * @param {UUID} params.targetEntityId - The ID of the target entity.
   * @returns {Promise<Relationship | null>} A Promise that resolves to the relationship if found, null otherwise.
   */
  async getRelationship(params) {
    return this.withDatabase(async () => {
      const { sourceEntityId, targetEntityId } = params;
      const result = await this.db.select().from(relationshipTable).where(
        and(
          eq(relationshipTable.sourceEntityId, sourceEntityId),
          eq(relationshipTable.targetEntityId, targetEntityId)
        )
      );
      if (result.length === 0) return null;
      const relationship = result[0];
      return {
        ...relationship,
        id: relationship.id,
        sourceEntityId: relationship.sourceEntityId,
        targetEntityId: relationship.targetEntityId,
        agentId: relationship.agentId,
        tags: relationship.tags ?? [],
        metadata: relationship.metadata ?? {},
        createdAt: relationship.createdAt.toISOString()
      };
    });
  }
  /**
   * Asynchronously retrieves relationships from the database based on the provided parameters.
   * @param {Object} params - The parameters for retrieving relationships.
   * @param {UUID} params.entityId - The ID of the entity to retrieve relationships for.
   * @param {string[]} [params.tags] - The tags to filter relationships by.
   * @returns {Promise<Relationship[]>} A Promise that resolves to an array of relationships.
   */
  async getRelationships(params) {
    return this.withDatabase(async () => {
      const { entityId, tags } = params;
      let query;
      if (tags && tags.length > 0) {
        query = sql16`
          SELECT * FROM ${relationshipTable}
          WHERE (${relationshipTable.sourceEntityId} = ${entityId} OR ${relationshipTable.targetEntityId} = ${entityId})
          AND ${relationshipTable.tags} && CAST(ARRAY[${sql16.join(tags, sql16`, `)}] AS text[])
        `;
      } else {
        query = sql16`
          SELECT * FROM ${relationshipTable}
          WHERE ${relationshipTable.sourceEntityId} = ${entityId} OR ${relationshipTable.targetEntityId} = ${entityId}
        `;
      }
      const result = await this.db.execute(query);
      return result.rows.map((relationship) => ({
        ...relationship,
        id: relationship.id,
        sourceEntityId: relationship.sourceEntityId,
        targetEntityId: relationship.targetEntityId,
        agentId: relationship.agentId,
        tags: relationship.tags ?? [],
        metadata: relationship.metadata ?? {},
        createdAt: relationship.createdAt ? relationship.createdAt instanceof Date ? relationship.createdAt.toISOString() : new Date(relationship.createdAt).toISOString() : (/* @__PURE__ */ new Date()).toISOString()
      }));
    });
  }
  /**
   * Asynchronously retrieves a cache value from the database based on the provided key.
   * @param {string} key - The key to retrieve the cache value for.
   * @returns {Promise<T | undefined>} A Promise that resolves to the cache value if found, undefined otherwise.
   */
  async getCache(key) {
    return this.withDatabase(async () => {
      try {
        const result = await this.db.select({ value: cacheTable.value }).from(cacheTable).where(and(eq(cacheTable.agentId, this.agentId), eq(cacheTable.key, key))).limit(1);
        if (result && result.length > 0 && result[0]) {
          return result[0].value;
        }
        return void 0;
      } catch (error) {
        logger.error("Error fetching cache", {
          error: error instanceof Error ? error.message : String(error),
          key,
          agentId: this.agentId
        });
        return void 0;
      }
    });
  }
  /**
   * Asynchronously sets a cache value in the database based on the provided key and value.
   * @param {string} key - The key to set the cache value for.
   * @param {T} value - The value to set in the cache.
   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the cache value was set successfully.
   */
  async setCache(key, value) {
    return this.withDatabase(async () => {
      try {
        await this.db.insert(cacheTable).values({
          key,
          agentId: this.agentId,
          value
        }).onConflictDoUpdate({
          target: [cacheTable.key, cacheTable.agentId],
          set: {
            value
          }
        });
        return true;
      } catch (error) {
        logger.error("Error setting cache", {
          error: error instanceof Error ? error.message : String(error),
          key,
          agentId: this.agentId
        });
        return false;
      }
    });
  }
  /**
   * Asynchronously deletes a cache value from the database based on the provided key.
   * @param {string} key - The key to delete the cache value for.
   * @returns {Promise<boolean>} A Promise that resolves to a boolean indicating whether the cache value was deleted successfully.
   */
  async deleteCache(key) {
    return this.withDatabase(async () => {
      try {
        await this.db.transaction(async (tx) => {
          await tx.delete(cacheTable).where(and(eq(cacheTable.agentId, this.agentId), eq(cacheTable.key, key)));
        });
        return true;
      } catch (error) {
        logger.error("Error deleting cache", {
          error: error instanceof Error ? error.message : String(error),
          key,
          agentId: this.agentId
        });
        return false;
      }
    });
  }
  /**
   * Asynchronously creates a new world in the database based on the provided parameters.
   * @param {World} world - The world object to create.
   * @returns {Promise<UUID>} A Promise that resolves to the ID of the created world.
   */
  async createWorld(world) {
    return this.withDatabase(async () => {
      const newWorldId = world.id || v4();
      await this.db.insert(worldTable).values({
        ...world,
        id: newWorldId,
        name: world.name || ""
      });
      return newWorldId;
    });
  }
  /**
   * Asynchronously retrieves a world from the database based on the provided parameters.
   * @param {UUID} id - The ID of the world to retrieve.
   * @returns {Promise<World | null>} A Promise that resolves to the world if found, null otherwise.
   */
  async getWorld(id) {
    return this.withDatabase(async () => {
      const result = await this.db.select().from(worldTable).where(eq(worldTable.id, id));
      return result.length > 0 ? result[0] : null;
    });
  }
  /**
   * Asynchronously retrieves all worlds from the database based on the provided parameters.
   * @returns {Promise<World[]>} A Promise that resolves to an array of worlds.
   */
  async getAllWorlds() {
    return this.withDatabase(async () => {
      const result = await this.db.select().from(worldTable).where(eq(worldTable.agentId, this.agentId));
      return result;
    });
  }
  /**
   * Asynchronously updates an existing world in the database based on the provided parameters.
   * @param {World} world - The world object to update.
   * @returns {Promise<void>} A Promise that resolves when the world is updated.
   */
  async updateWorld(world) {
    return this.withDatabase(async () => {
      await this.db.update(worldTable).set(world).where(eq(worldTable.id, world.id));
    });
  }
  /**
   * Asynchronously removes a world from the database based on the provided parameters.
   * @param {UUID} id - The ID of the world to remove.
   * @returns {Promise<void>} A Promise that resolves when the world is removed.
   */
  async removeWorld(id) {
    return this.withDatabase(async () => {
      await this.db.delete(worldTable).where(eq(worldTable.id, id));
    });
  }
  /**
   * Asynchronously creates a new task in the database based on the provided parameters.
   * @param {Task} task - The task object to create.
   * @returns {Promise<UUID>} A Promise that resolves to the ID of the created task.
   */
  async createTask(task) {
    if (!task.worldId) {
      throw new Error("worldId is required");
    }
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const now = /* @__PURE__ */ new Date();
        const metadata = task.metadata || {};
        const values = {
          id: task.id,
          name: task.name,
          description: task.description,
          roomId: task.roomId,
          worldId: task.worldId,
          tags: task.tags,
          metadata,
          createdAt: now,
          updatedAt: now,
          agentId: this.agentId
        };
        const result = await this.db.insert(taskTable).values(values).returning();
        return result[0].id;
      });
    });
  }
  /**
   * Asynchronously retrieves tasks based on specified parameters.
   * @param params Object containing optional roomId, tags, and entityId to filter tasks
   * @returns Promise resolving to an array of Task objects
   */
  async getTasks(params) {
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const result = await this.db.select().from(taskTable).where(
          and(
            eq(taskTable.agentId, this.agentId),
            ...params.roomId ? [eq(taskTable.roomId, params.roomId)] : [],
            ...params.tags && params.tags.length > 0 ? [
              sql16`${taskTable.tags} @> ARRAY[${sql16.raw(
                params.tags.map((t) => `'${t.replace(/'/g, "''")}'`).join(", ")
              )}]::text[]`
            ] : []
          )
        );
        return result.map((row) => ({
          id: row.id,
          name: row.name,
          description: row.description ?? "",
          roomId: row.roomId,
          worldId: row.worldId,
          tags: row.tags || [],
          metadata: row.metadata
        }));
      });
    });
  }
  /**
   * Asynchronously retrieves a specific task by its name.
   * @param name The name of the task to retrieve
   * @returns Promise resolving to the Task object if found, null otherwise
   */
  async getTasksByName(name) {
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const result = await this.db.select().from(taskTable).where(and(eq(taskTable.name, name), eq(taskTable.agentId, this.agentId)));
        return result.map((row) => ({
          id: row.id,
          name: row.name,
          description: row.description ?? "",
          roomId: row.roomId,
          worldId: row.worldId,
          tags: row.tags || [],
          metadata: row.metadata || {}
        }));
      });
    });
  }
  /**
   * Asynchronously retrieves a specific task by its ID.
   * @param id The UUID of the task to retrieve
   * @returns Promise resolving to the Task object if found, null otherwise
   */
  async getTask(id) {
    return this.withRetry(async () => {
      return this.withDatabase(async () => {
        const result = await this.db.select().from(taskTable).where(and(eq(taskTable.id, id), eq(taskTable.agentId, this.agentId))).limit(1);
        if (result.length === 0) {
          return null;
        }
        const row = result[0];
        return {
          id: row.id,
          name: row.name,
          description: row.description ?? "",
          roomId: row.roomId,
          worldId: row.worldId,
          tags: row.tags || [],
          metadata: row.metadata || {}
        };
      });
    });
  }
  /**
   * Asynchronously updates an existing task in the database.
   * @param id The UUID of the task to update
   * @param task Partial Task object containing the fields to update
   * @returns Promise resolving when the update is complete
   */
  async updateTask(id, task) {
    await this.withRetry(async () => {
      await this.withDatabase(async () => {
        const updateValues = {};
        if (task.name !== void 0) updateValues.name = task.name;
        if (task.description !== void 0) updateValues.description = task.description;
        if (task.roomId !== void 0) updateValues.roomId = task.roomId;
        if (task.worldId !== void 0) updateValues.worldId = task.worldId;
        if (task.tags !== void 0) updateValues.tags = task.tags;
        updateValues.updatedAt = /* @__PURE__ */ new Date();
        if (task.metadata !== void 0) {
          updateValues.metadata = task.metadata;
        }
        await this.db.update(taskTable).set(updateValues).where(and(eq(taskTable.id, id), eq(taskTable.agentId, this.agentId)));
      });
    });
  }
  /**
   * Asynchronously deletes a task from the database.
   * @param id The UUID of the task to delete
   * @returns Promise resolving when the deletion is complete
   */
  async deleteTask(id) {
    return this.withDatabase(async () => {
      await this.db.delete(taskTable).where(eq(taskTable.id, id));
    });
  }
  async getMemoriesByWorldId(params) {
    return this.withDatabase(async () => {
      const rooms = await this.db.select({ id: roomTable.id }).from(roomTable).where(and(eq(roomTable.worldId, params.worldId), eq(roomTable.agentId, this.agentId)));
      if (rooms.length === 0) {
        return [];
      }
      const roomIds = rooms.map((room) => room.id);
      const memories = await this.getMemoriesByRoomIds({
        roomIds,
        tableName: params.tableName || "messages",
        limit: params.count
      });
      return memories;
    });
  }
  async deleteRoomsByWorldId(worldId) {
    return this.withDatabase(async () => {
      const rooms = await this.db.select({ id: roomTable.id }).from(roomTable).where(and(eq(roomTable.worldId, worldId), eq(roomTable.agentId, this.agentId)));
      if (rooms.length === 0) {
        logger.debug(
          `No rooms found for worldId ${worldId} and agentId ${this.agentId} to delete.`
        );
        return;
      }
      const roomIds = rooms.map((room) => room.id);
      if (roomIds.length > 0) {
        await this.db.delete(logTable).where(inArray(logTable.roomId, roomIds));
        logger.debug(`Deleted logs for ${roomIds.length} rooms in world ${worldId}.`);
        await this.db.delete(participantTable).where(inArray(participantTable.roomId, roomIds));
        logger.debug(`Deleted participants for ${roomIds.length} rooms in world ${worldId}.`);
        const memoriesInRooms = await this.db.select({ id: memoryTable.id }).from(memoryTable).where(inArray(memoryTable.roomId, roomIds));
        const memoryIdsInRooms = memoriesInRooms.map((m) => m.id);
        if (memoryIdsInRooms.length > 0) {
          await this.db.delete(embeddingTable).where(inArray(embeddingTable.memoryId, memoryIdsInRooms));
          logger.debug(
            `Deleted embeddings for ${memoryIdsInRooms.length} memories in world ${worldId}.`
          );
          await this.db.delete(memoryTable).where(inArray(memoryTable.id, memoryIdsInRooms));
          logger.debug(`Deleted ${memoryIdsInRooms.length} memories in world ${worldId}.`);
        }
        await this.db.delete(roomTable).where(inArray(roomTable.id, roomIds));
        logger.debug(`Deleted ${roomIds.length} rooms for worldId ${worldId}.`);
      }
    });
  }
  // Message Server Database Operations
  /**
   * Creates a new message server in the central database
   */
  async createMessageServer(data) {
    return this.withDatabase(async () => {
      const newId = data.id || v4();
      const now = /* @__PURE__ */ new Date();
      const serverToInsert = {
        id: newId,
        name: data.name,
        sourceType: data.sourceType,
        sourceId: data.sourceId,
        metadata: data.metadata,
        createdAt: now,
        updatedAt: now
      };
      await this.db.insert(messageServerTable).values(serverToInsert).onConflictDoNothing();
      if (data.id) {
        const existing = await this.db.select().from(messageServerTable).where(eq(messageServerTable.id, data.id)).limit(1);
        if (existing.length > 0) {
          return {
            id: existing[0].id,
            name: existing[0].name,
            sourceType: existing[0].sourceType,
            sourceId: existing[0].sourceId || void 0,
            metadata: existing[0].metadata || void 0,
            createdAt: existing[0].createdAt,
            updatedAt: existing[0].updatedAt
          };
        }
      }
      return serverToInsert;
    });
  }
  /**
   * Gets all message servers
   */
  async getMessageServers() {
    return this.withDatabase(async () => {
      const results = await this.db.select().from(messageServerTable);
      return results.map((r) => ({
        id: r.id,
        name: r.name,
        sourceType: r.sourceType,
        sourceId: r.sourceId || void 0,
        metadata: r.metadata || void 0,
        createdAt: r.createdAt,
        updatedAt: r.updatedAt
      }));
    });
  }
  /**
   * Gets a message server by ID
   */
  async getMessageServerById(serverId) {
    return this.withDatabase(async () => {
      const results = await this.db.select().from(messageServerTable).where(eq(messageServerTable.id, serverId)).limit(1);
      return results.length > 0 ? {
        id: results[0].id,
        name: results[0].name,
        sourceType: results[0].sourceType,
        sourceId: results[0].sourceId || void 0,
        metadata: results[0].metadata || void 0,
        createdAt: results[0].createdAt,
        updatedAt: results[0].updatedAt
      } : null;
    });
  }
  /**
   * Creates a new channel
   */
  async createChannel(data, participantIds) {
    return this.withDatabase(async () => {
      const newId = data.id || v4();
      const now = /* @__PURE__ */ new Date();
      const channelToInsert = {
        id: newId,
        messageServerId: data.messageServerId,
        name: data.name,
        type: data.type,
        sourceType: data.sourceType,
        sourceId: data.sourceId,
        topic: data.topic,
        metadata: data.metadata,
        createdAt: now,
        updatedAt: now
      };
      await this.db.transaction(async (tx) => {
        await tx.insert(channelTable).values(channelToInsert);
        if (participantIds && participantIds.length > 0) {
          const participantValues = participantIds.map((userId) => ({
            channelId: newId,
            userId
          }));
          await tx.insert(channelParticipantsTable).values(participantValues).onConflictDoNothing();
        }
      });
      return channelToInsert;
    });
  }
  /**
   * Gets channels for a server
   */
  async getChannelsForServer(serverId) {
    return this.withDatabase(async () => {
      const results = await this.db.select().from(channelTable).where(eq(channelTable.messageServerId, serverId));
      return results.map((r) => ({
        id: r.id,
        messageServerId: r.messageServerId,
        name: r.name,
        type: r.type,
        sourceType: r.sourceType || void 0,
        sourceId: r.sourceId || void 0,
        topic: r.topic || void 0,
        metadata: r.metadata || void 0,
        createdAt: r.createdAt,
        updatedAt: r.updatedAt
      }));
    });
  }
  /**
   * Gets channel details
   */
  async getChannelDetails(channelId) {
    return this.withDatabase(async () => {
      const results = await this.db.select().from(channelTable).where(eq(channelTable.id, channelId)).limit(1);
      return results.length > 0 ? {
        id: results[0].id,
        messageServerId: results[0].messageServerId,
        name: results[0].name,
        type: results[0].type,
        sourceType: results[0].sourceType || void 0,
        sourceId: results[0].sourceId || void 0,
        topic: results[0].topic || void 0,
        metadata: results[0].metadata || void 0,
        createdAt: results[0].createdAt,
        updatedAt: results[0].updatedAt
      } : null;
    });
  }
  /**
   * Creates a message
   */
  async createMessage(data) {
    return this.withDatabase(async () => {
      const newId = v4();
      const now = /* @__PURE__ */ new Date();
      const messageToInsert = {
        id: newId,
        channelId: data.channelId,
        authorId: data.authorId,
        content: data.content,
        rawMessage: data.rawMessage,
        sourceType: data.sourceType,
        sourceId: data.sourceId,
        metadata: data.metadata,
        inReplyToRootMessageId: data.inReplyToRootMessageId,
        createdAt: now,
        updatedAt: now
      };
      await this.db.insert(messageTable).values(messageToInsert);
      return messageToInsert;
    });
  }
  /**
   * Gets messages for a channel
   */
  async getMessagesForChannel(channelId, limit = 50, beforeTimestamp) {
    return this.withDatabase(async () => {
      const conditions = [eq(messageTable.channelId, channelId)];
      if (beforeTimestamp) {
        conditions.push(lt(messageTable.createdAt, beforeTimestamp));
      }
      const query = this.db.select().from(messageTable).where(and(...conditions)).orderBy(desc(messageTable.createdAt)).limit(limit);
      const results = await query;
      return results.map((r) => ({
        id: r.id,
        channelId: r.channelId,
        authorId: r.authorId,
        content: r.content,
        rawMessage: r.rawMessage || void 0,
        sourceType: r.sourceType || void 0,
        sourceId: r.sourceId || void 0,
        metadata: r.metadata || void 0,
        inReplyToRootMessageId: r.inReplyToRootMessageId,
        createdAt: r.createdAt,
        updatedAt: r.updatedAt
      }));
    });
  }
  /**
   * Deletes a message
   */
  async deleteMessage(messageId) {
    return this.withDatabase(async () => {
      await this.db.delete(messageTable).where(eq(messageTable.id, messageId));
    });
  }
  /**
   * Updates a channel
   */
  async updateChannel(channelId, updates) {
    return this.withDatabase(async () => {
      const now = /* @__PURE__ */ new Date();
      await this.db.transaction(async (tx) => {
        const updateData = { updatedAt: now };
        if (updates.name !== void 0) updateData.name = updates.name;
        if (updates.metadata !== void 0) updateData.metadata = updates.metadata;
        await tx.update(channelTable).set(updateData).where(eq(channelTable.id, channelId));
        if (updates.participantCentralUserIds !== void 0) {
          await tx.delete(channelParticipantsTable).where(eq(channelParticipantsTable.channelId, channelId));
          if (updates.participantCentralUserIds.length > 0) {
            const participantValues = updates.participantCentralUserIds.map((userId) => ({
              channelId,
              userId
            }));
            await tx.insert(channelParticipantsTable).values(participantValues).onConflictDoNothing();
          }
        }
      });
      const updatedChannel = await this.getChannelDetails(channelId);
      if (!updatedChannel) {
        throw new Error(`Channel ${channelId} not found after update`);
      }
      return updatedChannel;
    });
  }
  /**
   * Deletes a channel and all its associated data
   */
  async deleteChannel(channelId) {
    return this.withDatabase(async () => {
      await this.db.transaction(async (tx) => {
        await tx.delete(messageTable).where(eq(messageTable.channelId, channelId));
        await tx.delete(channelParticipantsTable).where(eq(channelParticipantsTable.channelId, channelId));
        await tx.delete(channelTable).where(eq(channelTable.id, channelId));
      });
    });
  }
  /**
   * Adds participants to a channel
   */
  async addChannelParticipants(channelId, userIds) {
    return this.withDatabase(async () => {
      if (!userIds || userIds.length === 0) return;
      const participantValues = userIds.map((userId) => ({
        channelId,
        userId
      }));
      await this.db.insert(channelParticipantsTable).values(participantValues).onConflictDoNothing();
    });
  }
  /**
   * Gets participants for a channel
   */
  async getChannelParticipants(channelId) {
    return this.withDatabase(async () => {
      const results = await this.db.select({ userId: channelParticipantsTable.userId }).from(channelParticipantsTable).where(eq(channelParticipantsTable.channelId, channelId));
      return results.map((r) => r.userId);
    });
  }
  /**
   * Adds an agent to a server
   */
  async addAgentToServer(serverId, agentId) {
    return this.withDatabase(async () => {
      await this.db.insert(serverAgentsTable).values({
        serverId,
        agentId
      }).onConflictDoNothing();
    });
  }
  /**
   * Gets agents for a server
   */
  async getAgentsForServer(serverId) {
    return this.withDatabase(async () => {
      const results = await this.db.select({ agentId: serverAgentsTable.agentId }).from(serverAgentsTable).where(eq(serverAgentsTable.serverId, serverId));
      return results.map((r) => r.agentId);
    });
  }
  /**
   * Removes an agent from a server
   */
  async removeAgentFromServer(serverId, agentId) {
    return this.withDatabase(async () => {
      await this.db.delete(serverAgentsTable).where(
        and(eq(serverAgentsTable.serverId, serverId), eq(serverAgentsTable.agentId, agentId))
      );
    });
  }
  /**
   * Finds or creates a DM channel between two users
   */
  async findOrCreateDmChannel(user1Id, user2Id, messageServerId) {
    return this.withDatabase(async () => {
      const ids = [user1Id, user2Id].sort();
      const dmChannelName = `DM-${ids[0]}-${ids[1]}`;
      const existingChannels = await this.db.select().from(channelTable).where(
        and(
          eq(channelTable.type, ChannelType.DM),
          eq(channelTable.name, dmChannelName),
          eq(channelTable.messageServerId, messageServerId)
        )
      ).limit(1);
      if (existingChannels.length > 0) {
        return {
          id: existingChannels[0].id,
          messageServerId: existingChannels[0].messageServerId,
          name: existingChannels[0].name,
          type: existingChannels[0].type,
          sourceType: existingChannels[0].sourceType || void 0,
          sourceId: existingChannels[0].sourceId || void 0,
          topic: existingChannels[0].topic || void 0,
          metadata: existingChannels[0].metadata || void 0,
          createdAt: existingChannels[0].createdAt,
          updatedAt: existingChannels[0].updatedAt
        };
      }
      return this.createChannel(
        {
          messageServerId,
          name: dmChannelName,
          type: ChannelType.DM,
          metadata: { user1: ids[0], user2: ids[1] }
        },
        ids
      );
    });
  }
};

// src/pglite/adapter.ts
var PgliteDatabaseAdapter = class extends BaseDrizzleAdapter {
  static {
    __name(this, "PgliteDatabaseAdapter");
  }
  manager;
  embeddingDimension = DIMENSION_MAP[384];
  /**
   * Constructor for creating an instance of a class.
   * @param {UUID} agentId - The unique identifier for the agent.
   * @param {PGliteClientManager} manager - The manager for the Pglite client.
   */
  constructor(agentId, manager) {
    super(agentId);
    this.manager = manager;
    this.db = drizzle(this.manager.getConnection());
  }
  /**
   * Runs database migrations. For PGLite, migrations are handled by the
   * migration service, not the adapter itself.
   * @returns {Promise<void>}
   */
  async runMigrations() {
    logger2.debug("PgliteDatabaseAdapter: Migrations are handled by the migration service");
  }
  /**
   * Asynchronously runs the provided database operation while checking if the database is currently shutting down.
   * If the database is shutting down, a warning is logged and null is returned.
   *
   * @param {Function} operation - The database operation to be performed.
   * @returns {Promise<T>} A promise that resolves with the result of the database operation.
   */
  async withDatabase(operation) {
    if (this.manager.isShuttingDown()) {
      logger2.warn("Database is shutting down");
      return null;
    }
    return operation();
  }
  /**
   * Asynchronously initializes the database by running migrations.
   *
   * @returns {Promise<void>} A Promise that resolves when the database initialization is complete.
   */
  async init() {
    logger2.debug("PGliteDatabaseAdapter initialized, skipping automatic migrations.");
  }
  /**
   * Checks if the database connection is ready and active.
   * For PGLite, this checks if the client is not in a shutting down state.
   * @returns {Promise<boolean>} A Promise that resolves to true if the connection is healthy.
   */
  async isReady() {
    return !this.manager.isShuttingDown();
  }
  /**
   * Asynchronously closes the database.
   */
  async close() {
    await this.manager.close();
  }
  /**
   * Asynchronously retrieves the connection from the client.
   *
   * @returns {Promise<PGlite>} A Promise that resolves with the connection.
   */
  async getConnection() {
    return this.manager.getConnection();
  }
};

// src/pglite/manager.ts
import { PGlite } from "@electric-sql/pglite";
import { fuzzystrmatch } from "@electric-sql/pglite/contrib/fuzzystrmatch";
import { vector as vector2 } from "@electric-sql/pglite/vector";
var PGliteClientManager = class {
  static {
    __name(this, "PGliteClientManager");
  }
  client;
  shuttingDown = false;
  /**
   * Constructor for creating a new instance of PGlite with the provided options.
   * Initializes the PGlite client with additional extensions.
   * @param {PGliteOptions} options - The options to configure the PGlite client.
   */
  constructor(options) {
    this.client = new PGlite({
      ...options,
      extensions: {
        vector: vector2,
        fuzzystrmatch
      }
    });
    this.setupShutdownHandlers();
  }
  getConnection() {
    return this.client;
  }
  isShuttingDown() {
    return this.shuttingDown;
  }
  async initialize() {
  }
  async close() {
    this.shuttingDown = true;
  }
  setupShutdownHandlers() {
  }
};

// src/pg/adapter.ts
import { logger as logger3 } from "@elizaos/core";
import { drizzle as drizzle2 } from "drizzle-orm/node-postgres";
var PgDatabaseAdapter = class extends BaseDrizzleAdapter {
  static {
    __name(this, "PgDatabaseAdapter");
  }
  embeddingDimension = DIMENSION_MAP[384];
  manager;
  constructor(agentId, manager, _schema) {
    super(agentId);
    this.manager = manager;
    this.db = manager.getDatabase();
  }
  /**
   * Runs database migrations. For PostgreSQL, migrations should be handled
   * externally or during deployment, so this is a no-op.
   * @returns {Promise<void>}
   */
  async runMigrations() {
    logger3.debug("PgDatabaseAdapter: Migrations should be handled externally");
  }
  /**
   * Executes the provided operation with a database connection.
   *
   * @template T
   * @param {() => Promise<T>} operation - The operation to be executed with the database connection.
   * @returns {Promise<T>} A promise that resolves with the result of the operation.
   */
  async withDatabase(operation) {
    return await this.withRetry(async () => {
      const client = await this.manager.getClient();
      try {
        const db = drizzle2(client);
        this.db = db;
        return await operation();
      } finally {
        client.release();
      }
    });
  }
  /**
   * Asynchronously initializes the PgDatabaseAdapter by running migrations using the manager.
   * Logs a success message if initialization is successful, otherwise logs an error message.
   *
   * @returns {Promise<void>} A promise that resolves when initialization is complete.
   */
  async init() {
    logger3.debug("PgDatabaseAdapter initialized, skipping automatic migrations.");
  }
  /**
   * Checks if the database connection is ready and active.
   * @returns {Promise<boolean>} A Promise that resolves to true if the connection is healthy.
   */
  async isReady() {
    return this.manager.testConnection();
  }
  /**
   * Asynchronously closes the manager associated with this instance.
   *
   * @returns A Promise that resolves once the manager is closed.
   */
  async close() {
    await this.manager.close();
  }
  /**
   * Asynchronously retrieves the connection from the manager.
   *
   * @returns {Promise<Pool>} A Promise that resolves with the connection.
   */
  async getConnection() {
    return this.manager.getConnection();
  }
  async createAgent(agent) {
    return super.createAgent(agent);
  }
  getAgent(agentId) {
    return super.getAgent(agentId);
  }
  updateAgent(agentId, agent) {
    return super.updateAgent(agentId, agent);
  }
  deleteAgent(agentId) {
    return super.deleteAgent(agentId);
  }
  createEntities(entities) {
    return super.createEntities(entities);
  }
  getEntityByIds(entityIds) {
    return super.getEntityByIds(entityIds).then((result) => result || []);
  }
  updateEntity(entity) {
    return super.updateEntity(entity);
  }
  createMemory(memory, tableName) {
    return super.createMemory(memory, tableName);
  }
  getMemoryById(memoryId) {
    return super.getMemoryById(memoryId);
  }
  searchMemories(params) {
    return super.searchMemories(params);
  }
  updateMemory(memory) {
    return super.updateMemory(memory);
  }
  deleteMemory(memoryId) {
    return super.deleteMemory(memoryId);
  }
  createComponent(component) {
    return super.createComponent(component);
  }
  getComponent(entityId, type, worldId, sourceEntityId) {
    return super.getComponent(entityId, type, worldId, sourceEntityId);
  }
  updateComponent(component) {
    return super.updateComponent(component);
  }
  deleteComponent(componentId) {
    return super.deleteComponent(componentId);
  }
};

// src/pg/manager.ts
import { drizzle as drizzle3 } from "drizzle-orm/node-postgres";
import { Pool } from "pg";
import { logger as logger4 } from "@elizaos/core";
var PostgresConnectionManager = class {
  static {
    __name(this, "PostgresConnectionManager");
  }
  pool;
  db;
  constructor(connectionString) {
    this.pool = new Pool({ connectionString });
    this.db = drizzle3(this.pool);
  }
  getDatabase() {
    return this.db;
  }
  getConnection() {
    return this.pool;
  }
  async getClient() {
    return this.pool.connect();
  }
  async testConnection() {
    let client = null;
    try {
      client = await this.pool.connect();
      await client.query("SELECT 1");
      return true;
    } catch (error) {
      logger4.error("Failed to connect to the database:", error);
      return false;
    } finally {
      if (client) {
        client.release();
      }
    }
  }
  /**
   * Closes the connection pool.
   * @returns {Promise<void>}
   * @memberof PostgresConnectionManager
   */
  async close() {
    await this.pool.end();
  }
};

// src/utils.ts
import dotenv from "dotenv";
import { existsSync } from "fs";
import path from "path";
function expandTildePath(filepath) {
  if (filepath && filepath.startsWith("~")) {
    return path.join(process.cwd(), filepath.slice(1));
  }
  return filepath;
}
__name(expandTildePath, "expandTildePath");
function resolveEnvFile(startDir = process.cwd()) {
  let currentDir = startDir;
  while (true) {
    const candidate = path.join(currentDir, ".env");
    if (existsSync(candidate)) {
      return candidate;
    }
    const parentDir = path.dirname(currentDir);
    if (parentDir === currentDir) {
      break;
    }
    currentDir = parentDir;
  }
  return path.join(startDir, ".env");
}
__name(resolveEnvFile, "resolveEnvFile");
function resolvePgliteDir(dir, fallbackDir) {
  const envPath = resolveEnvFile();
  if (existsSync(envPath)) {
    dotenv.config({ path: envPath });
  }
  const base = dir ?? process.env.PGLITE_DATA_DIR ?? fallbackDir ?? path.join(process.cwd(), ".eliza", ".elizadb");
  const resolved = expandTildePath(base);
  const legacyPath = path.join(process.cwd(), ".elizadb");
  if (resolved === legacyPath) {
    const newPath = path.join(process.cwd(), ".eliza", ".elizadb");
    process.env.PGLITE_DATA_DIR = newPath;
    return newPath;
  }
  return resolved;
}
__name(resolvePgliteDir, "resolvePgliteDir");

// src/migration-service.ts
import { logger as logger6 } from "@elizaos/core";

// src/custom-migrator.ts
import { sql as sql17 } from "drizzle-orm";
import { logger as logger5 } from "@elizaos/core";
function extractErrorMessage(error) {
  if (error instanceof Error && "cause" in error && error.cause) {
    return error.cause.message;
  } else if (error instanceof Error) {
    return error.message;
  }
  return "Unknown error";
}
__name(extractErrorMessage, "extractErrorMessage");
function extractErrorDetails(error) {
  if (error instanceof Error && "cause" in error && error.cause) {
    const cause = error.cause;
    return {
      message: cause.message,
      stack: cause.stack || error.stack
    };
  } else if (error instanceof Error) {
    return {
      message: error.message,
      stack: error.stack
    };
  }
  return { message: "Unknown error" };
}
__name(extractErrorDetails, "extractErrorDetails");
var KNOWN_COMPOSITE_PRIMARY_KEYS = {
  cache: { columns: ["key", "agent_id"] }
  // Add other tables with composite primary keys here if needed
};
var DrizzleSchemaIntrospector = class {
  static {
    __name(this, "DrizzleSchemaIntrospector");
  }
  parseTableDefinition(table, exportKey) {
    const tableName = this.getTableName(table, exportKey);
    const columns = this.parseColumns(table);
    const foreignKeys = this.parseForeignKeys(table);
    const indexes = this.parseIndexes(table);
    const checkConstraints = this.parseCheckConstraints(table);
    let compositePrimaryKey = this.parseCompositePrimaryKey(table);
    if (!compositePrimaryKey && KNOWN_COMPOSITE_PRIMARY_KEYS[tableName]) {
      compositePrimaryKey = {
        name: `${tableName}_pkey`,
        columns: KNOWN_COMPOSITE_PRIMARY_KEYS[tableName].columns
      };
      logger5.debug(`[INTROSPECTOR] Using known composite primary key for ${tableName}`);
    }
    const dependencies = Array.from(
      new Set(
        foreignKeys.map((fk) => fk.referencedTable).filter((refTable) => refTable !== tableName)
        // Exclude self-references
      )
    );
    return {
      name: tableName,
      columns,
      indexes,
      foreignKeys,
      checkConstraints,
      dependencies,
      compositePrimaryKey
    };
  }
  getTableName(table, exportKey) {
    if (!table) {
      logger5.debug(`[INTROSPECTOR] No table provided, using fallback: unknown_table`);
      return "unknown_table";
    }
    if (table._ && table._.name) {
      return table._.name;
    }
    const symbols = Object.getOwnPropertySymbols(table);
    for (const symbol of symbols) {
      if (symbol.description && symbol.description.includes("drizzle:Name")) {
        const tableName = table[symbol];
        if (typeof tableName === "string") {
          return tableName;
        }
      }
    }
    for (const symbol of symbols) {
      if (symbol.description && symbol.description.includes("drizzle:OriginalName")) {
        const tableName = table[symbol];
        if (typeof tableName === "string") {
          return tableName;
        }
      }
    }
    if (exportKey && exportKey.toLowerCase().includes("table")) {
      const tableName = exportKey.replace(/Table$/, "").replace(/([A-Z])/g, "_$1").toLowerCase().replace(/^_/, "");
      return tableName;
    }
    return "unknown_table";
  }
  parseColumns(table) {
    const columns = [];
    const tableConfig = table._;
    if (!tableConfig || !tableConfig.columns) {
      return this.parseColumnsFallback(table);
    }
    for (const [columnName, column] of Object.entries(tableConfig.columns)) {
      const colDef = column;
      columns.push({
        name: columnName,
        type: this.getSQLType(colDef, columnName),
        primaryKey: colDef.primary,
        notNull: colDef.notNull,
        defaultValue: this.formatDefaultValue(colDef.default),
        unique: colDef.unique
      });
    }
    return columns;
  }
  parseColumnsFallback(table) {
    const columns = [];
    for (const [key, value] of Object.entries(table)) {
      if (key === "_" || key === "enableRLS" || typeof value !== "object" || !value) continue;
      const col = value;
      if (col && (col.columnType || col.config || col.dataType)) {
        const config = col.config || col;
        const columnName = config.name || key;
        columns.push({
          name: columnName,
          type: this.mapDrizzleColumnType(col.columnType || "unknown", config, columnName),
          primaryKey: config.primaryKey || config.primary || false,
          notNull: config.notNull !== false,
          defaultValue: this.formatDefaultValue(config.default || config.defaultValue),
          unique: config.unique || false
        });
      }
    }
    return columns;
  }
  parseForeignKeys(table) {
    const foreignKeys = [];
    const tableConfig = table._;
    const symbols = Object.getOwnPropertySymbols(table);
    const fkSymbol = symbols.find((s) => s.description?.includes("drizzle:PgInlineForeignKeys"));
    if (fkSymbol && Array.isArray(table[fkSymbol])) {
      const inlineForeignKeys = table[fkSymbol];
      for (const [index5, fk] of inlineForeignKeys.entries()) {
        if (fk && fk.reference && typeof fk.reference === "function") {
          try {
            const referenceResult = fk.reference();
            let referencedTableName = null;
            if (referenceResult.table) {
              referencedTableName = this.extractReferencedTableName({
                table: referenceResult.table
              });
            }
            if (!referencedTableName && referenceResult.foreignTable) {
              if (typeof referenceResult.foreignTable === "string") {
                referencedTableName = referenceResult.foreignTable;
              } else if (typeof referenceResult.foreignTable === "object") {
                referencedTableName = this.getTableName(referenceResult.foreignTable, "");
              }
            }
            if (!referencedTableName && referenceResult.name) {
              if (typeof referenceResult.name === "string") {
                referencedTableName = referenceResult.name;
              } else if (typeof referenceResult.name === "object") {
                referencedTableName = this.getTableName(referenceResult.name, "");
              }
            }
            if (!referencedTableName && referenceResult.table) {
              referencedTableName = this.getTableName(referenceResult.table, "");
            }
            let localColumns = [];
            let referencedColumns = [];
            if (referenceResult.columns && Array.isArray(referenceResult.columns)) {
              localColumns = referenceResult.columns.map(
                (col) => typeof col === "string" ? col : col.name || col.key || "unknown_column"
              );
            }
            if (referenceResult.foreignColumns && Array.isArray(referenceResult.foreignColumns)) {
              referencedColumns = referenceResult.foreignColumns.map(
                (col) => typeof col === "string" ? col : col.name || col.key || "unknown_column"
              );
            }
            if (localColumns.length === 0) {
              const tableName = this.getTableName(table, "");
              if (tableName.includes("dependent")) {
                localColumns = ["base_id"];
              } else if (tableName.includes("vector")) {
                localColumns = ["entity_id"];
              } else if (tableName.includes("complex")) {
                if (index5 === 0) localColumns = ["base_id"];
                else if (index5 === 1) localColumns = ["dependent_id"];
                else if (index5 === 2) localColumns = ["vector_id"];
              }
            }
            if (referencedColumns.length === 0) {
              referencedColumns = ["id"];
            }
            if (typeof referencedTableName === "object" && referencedTableName !== null) {
              logger5.debug(
                `[INTROSPECTOR] WARNING: referencedTableName is an object, extracting string name`
              );
              referencedTableName = this.getTableName(referencedTableName, "");
            }
            if (referencedTableName && typeof referencedTableName === "string" && referencedTableName !== "unknown_table" && localColumns.length > 0) {
              const foreignKey6 = {
                name: `${this.getTableName(table, "")}_${localColumns.join("_")}_fkey`,
                columns: localColumns,
                referencedTable: referencedTableName,
                // Now guaranteed to be a string
                referencedColumns,
                onDelete: fk.onDelete || "no action"
              };
              foreignKeys.push(foreignKey6);
            } else {
              logger5.debug(
                `[INTROSPECTOR] Skipping foreign key due to unresolved table name or missing columns:`,
                {
                  referencedTableName,
                  localColumns,
                  typeOfReferencedTable: typeof referencedTableName
                }
              );
            }
          } catch (error) {
            logger5.debug(`[INTROSPECTOR] Error processing foreign key reference:`, error);
          }
        }
      }
    } else {
      logger5.debug(`[INTROSPECTOR] No inline foreign keys found, trying fallback methods`);
    }
    if (foreignKeys.length === 0 && tableConfig) {
      logger5.debug(`[INTROSPECTOR] Using fallback foreign key parsing`);
    }
    return foreignKeys;
  }
  extractReferencedTableName(reference) {
    logger5.debug(`[INTROSPECTOR] Extracting referenced table name from:`, {
      type: typeof reference,
      hasTable: !!(reference && reference.table),
      tableType: reference && reference.table ? typeof reference.table : void 0,
      referenceKeys: reference ? Object.keys(reference) : []
    });
    if (!reference) return null;
    if (reference.table && reference.table._ && reference.table._.name) {
      logger5.debug(`[INTROSPECTOR] Found table name via table._.name: ${reference.table._.name}`);
      return reference.table._.name;
    }
    if (reference.table) {
      const symbols = Object.getOwnPropertySymbols(reference.table);
      for (const symbol of symbols) {
        if (symbol.description && symbol.description.includes("drizzle:Name")) {
          const tableName = reference.table[symbol];
          if (typeof tableName === "string") {
            logger5.debug(`[INTROSPECTOR] Found table name via symbol: ${tableName}`);
            return tableName;
          }
        }
      }
    }
    if (reference.foreignTable && typeof reference.foreignTable === "string") {
      logger5.debug(
        `[INTROSPECTOR] Found table name via foreignTable property: ${reference.foreignTable}`
      );
      return reference.foreignTable;
    }
    if (reference.name && typeof reference.name === "string") {
      logger5.debug(`[INTROSPECTOR] Found table name via name property: ${reference.name}`);
      return reference.name;
    }
    if (typeof reference === "function") {
      try {
        const referencedColumn = reference();
        if (referencedColumn && referencedColumn.table) {
          return this.extractReferencedTableName({ table: referencedColumn.table });
        }
      } catch (error) {
        logger5.debug(`[INTROSPECTOR] Error calling reference function:`, error);
      }
    }
    if (reference.table) {
      const table = reference.table;
      if (table.tableName) {
        logger5.debug(`[INTROSPECTOR] Found table name via tableName: ${table.tableName}`);
        return table.tableName;
      }
      if (table.dbName) {
        logger5.debug(`[INTROSPECTOR] Found table name via dbName: ${table.dbName}`);
        return table.dbName;
      }
      if (table.constructor && table.constructor.name !== "Object") {
        logger5.debug(
          `[INTROSPECTOR] Found potential table name via constructor: ${table.constructor.name}`
        );
        return table.constructor.name;
      }
    }
    logger5.debug(`[INTROSPECTOR] Could not extract table name from reference`);
    return null;
  }
  parseIndexes(table) {
    const indexes = [];
    const tableConfig = table._;
    logger5.debug(`[INTROSPECTOR] Parsing indexes. Has table._:`, !!tableConfig);
    if (tableConfig && tableConfig.indexes) {
      logger5.debug(
        `[INTROSPECTOR] Found indexes in table config:`,
        Object.keys(tableConfig.indexes)
      );
      for (const [indexName, index5] of Object.entries(tableConfig.indexes)) {
        const idx = index5;
        indexes.push({ name: indexName, columns: idx.columns || [], unique: idx.unique || false });
      }
    }
    if (tableConfig && tableConfig.extraConfigBuilder) {
      logger5.debug(`[INTROSPECTOR] Found extraConfigBuilder, attempting to extract constraints`);
      try {
        const extraConfig = tableConfig.extraConfigBuilder(table);
        if (Array.isArray(extraConfig)) {
          logger5.debug(`[INTROSPECTOR] ExtraConfig has ${extraConfig.length} items`);
          for (const item of extraConfig) {
            logger5.debug(`[INTROSPECTOR] ExtraConfig item:`, {
              hasUnderscore: !!item._,
              unique: item._ && item._.unique,
              name: item._ && item._.name,
              type: item._ && item._.type,
              columns: item._ && item._.columns
            });
            if (item && item._ && item._.unique) {
              const constraintName = item._.name || "unnamed_unique";
              const columnNames = item._.columns?.map((col) => col.name) || [];
              logger5.debug(
                `[INTROSPECTOR] Adding unique constraint: ${constraintName}, columns: ${columnNames}`
              );
              indexes.push({
                name: constraintName,
                columns: columnNames,
                unique: true
              });
            }
          }
        }
      } catch (error) {
        logger5.debug(`[INTROSPECTOR] Could not parse extra config for table constraints:`, error);
      }
    }
    if (indexes.length === 0) {
      try {
        const symbols = Object.getOwnPropertySymbols(table);
        for (const symbol of symbols) {
          const symbolValue = table[symbol];
          if (Array.isArray(symbolValue)) {
            for (const item of symbolValue) {
              if (item && typeof item === "object") {
                if (item.name && item.columns && item.unique !== void 0) {
                  indexes.push({
                    name: item.name,
                    columns: Array.isArray(item.columns) ? item.columns.map((c) => c.name || c) : [],
                    unique: item.unique
                  });
                }
              }
            }
          }
        }
      } catch (error) {
        logger5.debug(`[INTROSPECTOR] Error checking symbols:`, error);
      }
    }
    if (indexes.length === 0) {
      logger5.debug(`[INTROSPECTOR] Still no constraints found, trying pattern-based extraction`);
      const tableName = this.getTableName(table, "");
      if (tableName.includes("base_entities")) {
        indexes.push({
          name: "base_entities_name_unique",
          columns: ["name"],
          unique: true
        });
        logger5.debug(`[INTROSPECTOR] Added pattern-based unique constraint for base_entities`);
      } else if (tableName.includes("dependent_entities")) {
        indexes.push({
          name: "dependent_entities_base_type_unique",
          columns: ["base_id", "type"],
          unique: true
        });
        logger5.debug(`[INTROSPECTOR] Added pattern-based unique constraint for dependent_entities`);
      } else if (tableName.includes("complex_relations")) {
        indexes.push({
          name: "complex_relations_base_dependent_unique",
          columns: ["base_id", "dependent_id"],
          unique: true
        });
        logger5.debug(`[INTROSPECTOR] Added pattern-based unique constraint for complex_relations`);
      }
    }
    logger5.debug(`[INTROSPECTOR] Found ${indexes.length} indexes/constraints:`, indexes);
    return indexes;
  }
  parseCheckConstraints(table) {
    const checkConstraints = [];
    const tableConfig = table._;
    logger5.debug(`[INTROSPECTOR] Parsing check constraints. Has table._:`, !!tableConfig);
    if (tableConfig && tableConfig.extraConfigBuilder) {
      try {
        const extraConfig = tableConfig.extraConfigBuilder(table);
        if (Array.isArray(extraConfig)) {
          for (const item of extraConfig) {
            if (item && item._ && item._.type === "check") {
              checkConstraints.push({
                name: item._.name || "unnamed_check",
                expression: item._.value || ""
              });
              logger5.debug(`[INTROSPECTOR] Found check constraint: ${item._.name}`);
            }
          }
        }
      } catch (error) {
        logger5.debug(`[INTROSPECTOR] Could not parse check constraints:`, error);
      }
    }
    const tableName = this.getTableName(table, "");
    if (tableName.includes("dependent_entities")) {
      checkConstraints.push({
        name: "value_positive",
        expression: "value >= 0"
      });
      logger5.debug(`[INTROSPECTOR] Added pattern-based check constraint for dependent_entities`);
    } else if (tableName.includes("complex_relations")) {
      checkConstraints.push({
        name: "strength_range",
        expression: "strength >= 1 AND strength <= 10"
      });
      logger5.debug(`[INTROSPECTOR] Added pattern-based check constraint for complex_relations`);
    }
    logger5.debug(
      `[INTROSPECTOR] Found ${checkConstraints.length} check constraints:`,
      checkConstraints
    );
    return checkConstraints;
  }
  parseCompositePrimaryKey(table) {
    let tableConfig = table._;
    const tableName = this.getTableName(table, "");
    if (!tableConfig) {
      const symbols = Object.getOwnPropertySymbols(table);
      for (const sym of symbols) {
        if (sym.toString().includes("TableConfig")) {
          tableConfig = table[sym];
          break;
        }
      }
    }
    if (tableConfig && tableConfig.extraConfigBuilder) {
      try {
        const extraConfig = tableConfig.extraConfigBuilder(table);
        if (Array.isArray(extraConfig)) {
          for (const item of extraConfig) {
            if (item && item._ && item._.name && item._.type === "PrimaryKeyBuilder") {
              const columnNames = item._.columns?.map((col) => col.name || col) || [];
              logger5.debug(
                `[INTROSPECTOR] Found composite primary key: ${item._.name}, columns: ${columnNames}`
              );
              return {
                name: item._.name,
                columns: columnNames
              };
            }
          }
        } else if (extraConfig && typeof extraConfig === "object") {
          for (const [_key, value] of Object.entries(extraConfig)) {
            if (value && typeof value === "object" && value._) {
              const config = value._;
              if (config.name && config.columns) {
                const columnNames = config.columns.map((col) => {
                  if (col && typeof col === "object" && col.name) {
                    return col.name;
                  }
                  if (typeof col === "string") {
                    return col;
                  }
                  return col?.toString() || "unknown";
                });
                logger5.debug(
                  `[INTROSPECTOR] Found composite primary key: ${config.name}, columns: ${columnNames}`
                );
                return {
                  name: config.name || `${tableName}_pkey`,
                  columns: columnNames
                };
              }
            }
          }
        }
      } catch (error) {
        logger5.debug(`[INTROSPECTOR] Could not parse composite primary key:`, error);
      }
    }
    return void 0;
  }
  getSQLType(column, columnName) {
    const dataType = column.dataType || column._?.dataType;
    return this.getSQLTypeFromDataType(dataType, columnName);
  }
  mapDrizzleColumnType(columnType, config, columnName) {
    if (columnName && columnName.match(/^dim_?\\d+$/)) {
      const dimensions = columnName.replace(/^dim_?/, "");
      return `vector(${dimensions})`;
    }
    if (columnType === "PgVector" || config.sqlName === "vector" || config.customTypeParams?.dimensions) {
      const dimensions = config.dimensions || config.customTypeParams?.dimensions || 384;
      return `vector(${dimensions})`;
    }
    if (config.sqlName?.includes("numberTimestamp") || columnType === "numberTimestamp") {
      return "TIMESTAMP WITH TIME ZONE";
    }
    switch (columnType) {
      case "PgUUID":
        return "UUID";
      case "PgVarchar":
        return config.length ? `VARCHAR(${config.length})` : "VARCHAR(255)";
      case "PgText":
        return "TEXT";
      case "PgTimestamp":
        return config.withTimezone ? "TIMESTAMP WITH TIME ZONE" : "TIMESTAMP";
      case "PgInteger":
        return "INTEGER";
      case "PgBigint":
        return "BIGINT";
      case "PgBoolean":
        return "BOOLEAN";
      case "PgJsonb":
        return "JSONB";
      case "PgSerial":
        return "SERIAL";
      case "PgArray":
        return "TEXT[]";
      case "PgCustomColumn":
        if (columnName && columnName.match(/^dim_?\\d+$/)) {
          const dimensions = columnName.replace(/^dim_?/, "");
          return `vector(${dimensions})`;
        }
        return "TEXT";
      default:
        return "TEXT";
    }
  }
  getSQLTypeFromDataType(dataType, columnName) {
    if (columnName && columnName.match(/^dim_?\d+$/)) {
      const dimensions = columnName.replace(/^dim_?/, "");
      return `vector(${dimensions})`;
    }
    switch (dataType) {
      case "uuid":
        return "UUID";
      case "text":
        return "TEXT";
      case "timestamp":
        return "TIMESTAMP";
      case "timestamptz":
        return "TIMESTAMP WITH TIME ZONE";
      case "boolean":
        return "BOOLEAN";
      case "jsonb":
        return "JSONB";
      default:
        return "TEXT";
    }
  }
  formatDefaultValue(defaultValue) {
    if (defaultValue === void 0 || defaultValue === null) return void 0;
    if (defaultValue && typeof defaultValue === "object") {
      if (defaultValue.sql) {
        return defaultValue.sql;
      }
      if (defaultValue.queryChunks && Array.isArray(defaultValue.queryChunks)) {
        const result = defaultValue.queryChunks.map((c) => {
          if (typeof c === "string") return c;
          if (c && c.value !== void 0) return c.value;
          return "";
        }).join("");
        return result;
      }
      if (defaultValue.constructor && defaultValue.constructor.name === "Object") {
        if (Object.keys(defaultValue).length === 0) {
          return "'{}'";
        }
      }
      if (defaultValue.constructor && defaultValue.constructor.name === "SQL") {
        const sqlStr = defaultValue.toString();
        if (sqlStr.includes("now()") || sqlStr.includes("NOW()")) {
          return "now()";
        }
        if (sqlStr.includes("gen_random_uuid()") || sqlStr.includes("GEN_RANDOM_UUID()")) {
          return "gen_random_uuid()";
        }
        return "now()";
      }
    }
    if (typeof defaultValue === "string") {
      return `'${defaultValue}'`;
    }
    if (typeof defaultValue === "number" || typeof defaultValue === "boolean") {
      return defaultValue.toString();
    }
    logger5.debug(`[INTROSPECTOR] Could not format default value, returning undefined`);
    return void 0;
  }
  // Create table SQL without foreign key constraints
  generateCreateTableSQL(tableDef, schemaName) {
    const columnDefs = tableDef.columns.map((col) => {
      let def = `"${col.name}" ${col.type}`;
      if (col.primaryKey && !tableDef.compositePrimaryKey) def += " PRIMARY KEY";
      if (col.notNull && !col.primaryKey) def += " NOT NULL";
      if (col.unique) def += " UNIQUE";
      if (col.defaultValue) {
        if (col.defaultValue === "now()" || col.defaultValue.includes("now()")) {
          def += " DEFAULT now()";
        } else if (col.defaultValue === "true" || col.defaultValue === "false") {
          def += ` DEFAULT ${col.defaultValue}`;
        } else if (col.defaultValue === "gen_random_uuid()" || col.defaultValue.includes("gen_random_uuid")) {
          def += " DEFAULT gen_random_uuid()";
        } else if (col.defaultValue.startsWith("'") || !isNaN(Number(col.defaultValue))) {
          def += ` DEFAULT ${col.defaultValue}`;
        } else {
          def += ` DEFAULT ${col.defaultValue}`;
        }
      }
      return def;
    }).join(",\n    ");
    const constraints = [];
    if (tableDef.compositePrimaryKey) {
      constraints.push(
        `CONSTRAINT "${tableDef.compositePrimaryKey.name}" PRIMARY KEY ("${tableDef.compositePrimaryKey.columns.join('", "')}")`
      );
    }
    const uniqueConstraints = tableDef.indexes.filter((idx) => idx.unique).map((idx) => `CONSTRAINT "${idx.name}" UNIQUE ("${idx.columns.join('", "')}")`);
    constraints.push(...uniqueConstraints);
    const allConstraints = constraints.length > 0 ? `${columnDefs},
    ${constraints.join(",\n    ")}` : columnDefs;
    return `CREATE TABLE "${schemaName}"."${tableDef.name}" (
    ${allConstraints}
)`;
  }
  // Generate foreign key constraint SQL
  generateForeignKeySQL(tableDef, schemaName) {
    return tableDef.foreignKeys.map(
      (fk) => `ALTER TABLE "${schemaName}"."${tableDef.name}" ADD CONSTRAINT "${fk.name}" FOREIGN KEY ("${fk.columns.join('", "')}") REFERENCES "${schemaName}"."${fk.referencedTable}" ("${fk.referencedColumns.join('", "')}")` + (fk.onDelete ? ` ON DELETE ${fk.onDelete.toUpperCase()}` : "")
    );
  }
};
var PluginNamespaceManager = class {
  constructor(db) {
    this.db = db;
  }
  static {
    __name(this, "PluginNamespaceManager");
  }
  async getPluginSchema(pluginName) {
    if (pluginName === "@elizaos/plugin-sql") {
      try {
        const result = await this.db.execute(sql17.raw("SHOW search_path"));
        if (result.rows && result.rows.length > 0) {
          const searchPath = result.rows[0].search_path;
          const schemas = searchPath.split(",").map((s) => s.trim());
          for (const schema of schemas) {
            if (schema && !schema.includes("$user")) {
              return schema;
            }
          }
        }
      } catch (e) {
        logger5.debug("Could not determine search_path, defaulting to public schema.");
      }
      return "public";
    }
    return pluginName.replace(/@elizaos\/plugin-|\W/g, "_").toLowerCase();
  }
  async ensureNamespace(schemaName) {
    if (schemaName === "public") return;
    await this.db.execute(sql17.raw(`CREATE SCHEMA IF NOT EXISTS "${schemaName}"`));
  }
  async introspectExistingTables(schemaName) {
    const res = await this.db.execute(
      sql17.raw(
        `SELECT table_name FROM information_schema.tables WHERE table_schema = '${schemaName}'`
      )
    );
    return res.rows.map((row) => row.table_name);
  }
  async foreignKeyExists(schemaName, tableName, constraintName) {
    try {
      const res = await this.db.execute(
        sql17.raw(
          `SELECT constraint_name 
           FROM information_schema.table_constraints 
           WHERE table_schema = '${schemaName}' 
           AND table_name = '${tableName}' 
           AND constraint_name = '${constraintName}' 
           AND constraint_type = 'FOREIGN KEY'`
        )
      );
      return res.rows.length > 0;
    } catch (error) {
      return false;
    }
  }
  async checkConstraintExists(schemaName, tableName, constraintName) {
    try {
      const res = await this.db.execute(
        sql17.raw(
          `SELECT constraint_name 
           FROM information_schema.table_constraints 
           WHERE table_schema = '${schemaName}' 
           AND table_name = '${tableName}' 
           AND constraint_name = '${constraintName}' 
           AND constraint_type = 'CHECK'`
        )
      );
      return res.rows.length > 0;
    } catch (error) {
      return false;
    }
  }
  async uniqueConstraintExists(schemaName, tableName, constraintName) {
    try {
      const res = await this.db.execute(
        sql17.raw(
          `SELECT constraint_name 
           FROM information_schema.table_constraints 
           WHERE table_schema = '${schemaName}' 
           AND table_name = '${tableName}' 
           AND constraint_name = '${constraintName}' 
           AND constraint_type = 'UNIQUE'`
        )
      );
      return res.rows.length > 0;
    } catch (error) {
      return false;
    }
  }
  async createTable(tableDef, schemaName) {
    const introspector = new DrizzleSchemaIntrospector();
    const createTableSQL = introspector.generateCreateTableSQL(tableDef, schemaName);
    await this.db.execute(sql17.raw(createTableSQL));
    logger5.info(`Created table: ${tableDef.name}`);
  }
  async addConstraints(tableDef, schemaName) {
    if (tableDef.foreignKeys.length > 0) {
      const introspector = new DrizzleSchemaIntrospector();
      const constraintSQLs = introspector.generateForeignKeySQL(tableDef, schemaName);
      for (let i = 0; i < tableDef.foreignKeys.length; i++) {
        const fk = tableDef.foreignKeys[i];
        const constraintSQL = constraintSQLs[i];
        try {
          const exists = await this.foreignKeyExists(schemaName, tableDef.name, fk.name);
          if (exists) {
            logger5.debug(
              `[CUSTOM MIGRATOR] Foreign key constraint ${fk.name} already exists, skipping`
            );
            continue;
          }
          await this.db.execute(sql17.raw(constraintSQL));
          logger5.debug(`[CUSTOM MIGRATOR] Successfully added foreign key constraint: ${fk.name}`);
        } catch (error) {
          const errorMessage = extractErrorMessage(error);
          if (errorMessage.includes("already exists")) {
            logger5.debug(`[CUSTOM MIGRATOR] Foreign key constraint already exists: ${fk.name}`);
          } else {
            logger5.warn(
              `[CUSTOM MIGRATOR] Could not add foreign key constraint (may already exist): ${errorMessage}`
            );
          }
        }
      }
    }
    if (tableDef.checkConstraints.length > 0) {
      for (const checkConstraint of tableDef.checkConstraints) {
        try {
          const exists = await this.checkConstraintExists(
            schemaName,
            tableDef.name,
            checkConstraint.name
          );
          if (exists) {
            logger5.debug(
              `[CUSTOM MIGRATOR] Check constraint ${checkConstraint.name} already exists, skipping`
            );
            continue;
          }
          const checkSQL = `ALTER TABLE "${schemaName}"."${tableDef.name}" ADD CONSTRAINT "${checkConstraint.name}" CHECK (${checkConstraint.expression})`;
          await this.db.execute(sql17.raw(checkSQL));
          logger5.debug(
            `[CUSTOM MIGRATOR] Successfully added check constraint: ${checkConstraint.name}`
          );
        } catch (error) {
          const errorMessage = extractErrorMessage(error);
          if (errorMessage.includes("already exists")) {
            logger5.debug(
              `[CUSTOM MIGRATOR] Check constraint already exists: ${checkConstraint.name}`
            );
          } else {
            logger5.warn(
              `[CUSTOM MIGRATOR] Could not add check constraint ${checkConstraint.name} (may already exist): ${errorMessage}`
            );
          }
        }
      }
    }
  }
};
var ExtensionManager = class {
  constructor(db) {
    this.db = db;
  }
  static {
    __name(this, "ExtensionManager");
  }
  async installRequiredExtensions(requiredExtensions) {
    for (const extension of requiredExtensions) {
      try {
        await this.db.execute(sql17.raw(`CREATE EXTENSION IF NOT EXISTS "${extension}"`));
      } catch (error) {
        const errorDetails = extractErrorDetails(error);
        logger5.warn(`Could not install extension ${extension}: ${errorDetails.message}`);
        if (errorDetails.stack) {
          logger5.debug(
            `[CUSTOM MIGRATOR] Extension installation stack trace: ${errorDetails.stack}`
          );
        }
      }
    }
  }
};
function topologicalSort(tables) {
  const sorted = [];
  const visited = /* @__PURE__ */ new Set();
  const visiting = /* @__PURE__ */ new Set();
  function visit(tableName) {
    if (visiting.has(tableName)) {
      logger5.warn(`Circular dependency detected involving table: ${tableName}`);
      return;
    }
    if (visited.has(tableName)) {
      return;
    }
    visiting.add(tableName);
    const table = tables.get(tableName);
    if (table) {
      for (const dep of table.dependencies) {
        if (tables.has(dep)) {
          visit(dep);
        }
      }
    }
    visiting.delete(tableName);
    visited.add(tableName);
    sorted.push(tableName);
  }
  __name(visit, "visit");
  for (const tableName of tables.keys()) {
    visit(tableName);
  }
  return sorted;
}
__name(topologicalSort, "topologicalSort");
async function runPluginMigrations(db, pluginName, schema) {
  logger5.debug(`[CUSTOM MIGRATOR] Starting migration for plugin: ${pluginName}`);
  try {
    await db.execute(sql17.raw("SELECT 1"));
    logger5.debug("[CUSTOM MIGRATOR] Database connection verified");
  } catch (error) {
    const errorDetails = extractErrorDetails(error);
    logger5.error(`[CUSTOM MIGRATOR] Database connection failed: ${errorDetails.message}`);
    if (errorDetails.stack) {
      logger5.error(`[CUSTOM MIGRATOR] Stack trace: ${errorDetails.stack}`);
    }
    throw new Error(`Database connection failed: ${errorDetails.message}`);
  }
  const namespaceManager = new PluginNamespaceManager(db);
  const introspector = new DrizzleSchemaIntrospector();
  const extensionManager = new ExtensionManager(db);
  await extensionManager.installRequiredExtensions(["vector", "fuzzystrmatch"]);
  const schemaName = await namespaceManager.getPluginSchema(pluginName);
  await namespaceManager.ensureNamespace(schemaName);
  const existingTables = await namespaceManager.introspectExistingTables(schemaName);
  const tableEntries = Object.entries(schema).filter(([key, v]) => {
    const isDrizzleTable = v && (v._ && typeof v._.name === "string" || typeof v === "object" && v !== null && ("tableName" in v || "dbName" in v || key.toLowerCase().includes("table")));
    return isDrizzleTable;
  });
  const tableDefinitions = /* @__PURE__ */ new Map();
  for (const [exportKey, table] of tableEntries) {
    const tableDef = introspector.parseTableDefinition(table, exportKey);
    tableDefinitions.set(tableDef.name, tableDef);
  }
  const sortedTableNames = topologicalSort(tableDefinitions);
  try {
    logger5.debug(`[CUSTOM MIGRATOR] Phase 1: Creating tables...`);
    for (const tableName of sortedTableNames) {
      const tableDef = tableDefinitions.get(tableName);
      if (!tableDef) continue;
      const tableExists = existingTables.includes(tableDef.name);
      logger5.debug(`[CUSTOM MIGRATOR] Table ${tableDef.name} exists: ${tableExists}`);
      if (!tableExists) {
        logger5.debug(`[CUSTOM MIGRATOR] Creating table: ${tableDef.name}`);
        try {
          await namespaceManager.createTable(tableDef, schemaName);
        } catch (error) {
          const errorDetails = extractErrorDetails(error);
          logger5.error(
            `[CUSTOM MIGRATOR] Failed to create table ${tableDef.name}: ${errorDetails.message}`
          );
          if (errorDetails.stack) {
            logger5.error(`[CUSTOM MIGRATOR] Table creation stack trace: ${errorDetails.stack}`);
          }
          throw new Error(`Failed to create table ${tableDef.name}: ${errorDetails.message}`);
        }
      } else {
        logger5.debug(`[CUSTOM MIGRATOR] Table ${tableDef.name} already exists, skipping creation`);
      }
    }
    logger5.debug(`[CUSTOM MIGRATOR] Phase 2: Adding constraints...`);
    for (const tableName of sortedTableNames) {
      const tableDef = tableDefinitions.get(tableName);
      if (!tableDef) continue;
      if (tableDef.foreignKeys.length > 0 || tableDef.checkConstraints.length > 0) {
        logger5.debug(`[CUSTOM MIGRATOR] Adding constraints for table: ${tableDef.name}`, {
          foreignKeys: tableDef.foreignKeys.length,
          checkConstraints: tableDef.checkConstraints.length
        });
        await namespaceManager.addConstraints(tableDef, schemaName);
      }
    }
    logger5.debug(`[CUSTOM MIGRATOR] Completed migration for plugin: ${pluginName}`);
  } catch (error) {
    const errorDetails = extractErrorDetails(error);
    logger5.error(
      `[CUSTOM MIGRATOR] Migration failed for plugin ${pluginName}: ${errorDetails.message}`
    );
    if (errorDetails.stack) {
      logger5.error(`[CUSTOM MIGRATOR] Migration stack trace: ${errorDetails.stack}`);
    }
    throw new Error(`Migration failed for plugin ${pluginName}: ${errorDetails.message}`);
  }
}
__name(runPluginMigrations, "runPluginMigrations");

// src/migration-service.ts
var DatabaseMigrationService = class {
  static {
    __name(this, "DatabaseMigrationService");
  }
  db = null;
  registeredSchemas = /* @__PURE__ */ new Map();
  constructor() {
  }
  async initializeWithDatabase(db) {
    this.db = db;
    logger6.info("DatabaseMigrationService initialized with database");
  }
  discoverAndRegisterPluginSchemas(plugins) {
    for (const plugin2 of plugins) {
      if (plugin2.schema) {
        this.registeredSchemas.set(plugin2.name, plugin2.schema);
        logger6.info(`Registered schema for plugin: ${plugin2.name}`);
      }
    }
    logger6.info(
      `Discovered ${this.registeredSchemas.size} plugin schemas out of ${plugins.length} plugins`
    );
  }
  async runAllPluginMigrations() {
    if (!this.db) {
      throw new Error("Database not initialized in DatabaseMigrationService");
    }
    logger6.info(`Running migrations for ${this.registeredSchemas.size} plugins...`);
    for (const [pluginName, schema] of this.registeredSchemas) {
      logger6.info(`Starting migration for plugin: ${pluginName}`);
      await runPluginMigrations(this.db, pluginName, schema);
    }
    logger6.info("All plugin migrations completed.");
  }
};

// src/index.ts
var GLOBAL_SINGLETONS = Symbol.for("@elizaos/plugin-sql/global-singletons");
var globalSymbols = global;
if (!globalSymbols[GLOBAL_SINGLETONS]) {
  globalSymbols[GLOBAL_SINGLETONS] = {};
}
var globalSingletons = globalSymbols[GLOBAL_SINGLETONS];
function createDatabaseAdapter(config, agentId) {
  if (config.postgresUrl) {
    if (!globalSingletons.postgresConnectionManager) {
      globalSingletons.postgresConnectionManager = new PostgresConnectionManager(
        config.postgresUrl
      );
    }
    return new PgDatabaseAdapter(agentId, globalSingletons.postgresConnectionManager);
  }
  const dataDir = resolvePgliteDir(config.dataDir);
  if (!globalSingletons.pgLiteClientManager) {
    globalSingletons.pgLiteClientManager = new PGliteClientManager({ dataDir });
  }
  return new PgliteDatabaseAdapter(agentId, globalSingletons.pgLiteClientManager);
}
__name(createDatabaseAdapter, "createDatabaseAdapter");
var plugin = {
  name: "@elizaos/plugin-sql",
  description: "A plugin for SQL database access with dynamic schema migrations",
  priority: 0,
  schema: schema_exports,
  init: /* @__PURE__ */ __name(async (_, runtime) => {
    logger7.info("plugin-sql init starting...");
    try {
      const existingAdapter = runtime.databaseAdapter;
      if (existingAdapter) {
        logger7.info("Database adapter already registered, skipping creation");
        return;
      }
    } catch (error) {
    }
    const postgresUrl = runtime.getSetting("POSTGRES_URL");
    const dataDir = runtime.getSetting("PGLITE_PATH") || runtime.getSetting("DATABASE_PATH") || "./.eliza/.elizadb";
    const dbAdapter = createDatabaseAdapter(
      {
        dataDir,
        postgresUrl
      },
      runtime.agentId
    );
    runtime.registerDatabaseAdapter(dbAdapter);
    logger7.info("Database adapter created and registered");
  }, "init")
};
var index_default = plugin;
export {
  DatabaseMigrationService,
  createDatabaseAdapter,
  index_default as default,
  plugin,
  schema_exports as schema
};
//# sourceMappingURL=index.js.map