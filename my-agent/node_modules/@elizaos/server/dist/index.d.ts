import { UUID, ChannelType, Character, DatabaseAdapter, IAgentRuntime } from '@elizaos/core';
import express from 'express';
import http from 'node:http';
import { Server } from 'socket.io';

interface MessageServer {
    id: UUID;
    name: string;
    sourceType: string;
    sourceId?: string;
    metadata?: Record<string, any>;
    createdAt: Date;
    updatedAt: Date;
}
interface MessageChannel {
    id: UUID;
    messageServerId: UUID;
    name: string;
    type: ChannelType;
    sourceType?: string;
    sourceId?: string;
    topic?: string;
    metadata?: Record<string, any>;
    createdAt: Date;
    updatedAt: Date;
}
interface CentralRootMessage {
    id: UUID;
    channelId: UUID;
    authorId: UUID;
    content: string;
    rawMessage?: any;
    inReplyToRootMessageId?: UUID;
    sourceType?: string;
    sourceId?: string;
    createdAt: Date;
    updatedAt: Date;
    metadata?: Record<string, any>;
}
interface MessageServiceStructure {
    id: UUID;
    channel_id: UUID;
    server_id: UUID;
    author_id: UUID;
    author_display_name?: string;
    content: string;
    raw_message?: any;
    source_id?: string;
    source_type?: string;
    in_reply_to_message_id?: UUID;
    created_at: number;
    metadata?: any;
}

/**
 * Attempts to load a file from the given file path.
 *
 * @param {string} filePath - The path to the file to load.
 * @returns {string | null} The contents of the file as a string, or null if an error occurred.
 * @throws {Error} If an error occurs while loading the file.
 */
declare function tryLoadFile(filePath: string): string | null;
/**
 * Load characters from a specified URL and return them as an array of Character objects.
 * @param {string} url - The URL from which to load character data.
 * @returns {Promise<Character[]>} - A promise that resolves with an array of Character objects.
 */
declare function loadCharactersFromUrl(url: string): Promise<Character[]>;
/**
 * Converts a JSON object representing a character into a validated Character object with additional settings and secrets.
 *
 * @param {unknown} character - The input data representing a character.
 * @returns {Promise<Character>} - A Promise that resolves to a validated Character object.
 * @throws {Error} If character validation fails.
 */
declare function jsonToCharacter(character: unknown): Promise<Character>;
/**
 * Loads a character from the specified file path with safe JSON parsing and validation.
 *
 * @param {string} filePath - The path to the character file.
 * @returns {Promise<Character>} A Promise that resolves to the validated Character object.
 * @throws {Error} If the character file is not found, has invalid JSON, or fails validation.
 */
declare function loadCharacter(filePath: string): Promise<Character>;
/**
 * Asynchronously loads a character from the specified path.
 * If the path is a URL, it loads the character from the URL.
 * If the path is a local file path, it tries multiple possible locations and
 * loads the character from the first valid location found.
 *
 * @param {string} characterPath - The path to load the character from.
 * @returns {Promise<Character>} A Promise that resolves to the loaded character.
 */
declare function loadCharacterTryPath(characterPath: string): Promise<Character>;
declare const hasValidRemoteUrls: () => boolean | "" | undefined;
/**
 * Load characters from local paths or remote URLs based on configuration.
 * @param charactersArg - A comma-separated list of local file paths or remote URLs to load characters from.
 * @returns A promise that resolves to an array of loaded characters.
 */
declare function loadCharacters(charactersArg: string): Promise<Character[]>;

/**
 * Expands a file path starting with `~` to the project directory.
 *
 * @param filepath - The path to expand.
 * @returns The expanded path.
 */
declare function expandTildePath(filepath: string): string;
declare function resolvePgliteDir(dir?: string, fallbackDir?: string): string;
/**
 * Represents a function that acts as a server middleware.
 * @param {express.Request} req - The request object.
 * @param {express.Response} res - The response object.
 * @param {express.NextFunction} next - The next function to be called in the middleware chain.
 * @returns {void}
 */
type ServerMiddleware = (req: express.Request, res: express.Response, next: express.NextFunction) => void;
/**
 * Interface for defining server configuration options.
 * @typedef {Object} ServerOptions
 * @property {ServerMiddleware[]} [middlewares] - Optional array of server middlewares.
 * @property {string} [dataDir] - Optional directory for storing server data.
 * @property {string} [postgresUrl] - Optional URL for connecting to a PostgreSQL database.
 */
interface ServerOptions {
    middlewares?: ServerMiddleware[];
    dataDir?: string;
    postgresUrl?: string;
}
/**
 * Class representing an agent server.
 */ /**
* Represents an agent server which handles agents, database, and server functionalities.
*/
declare class AgentServer {
    app: express.Application;
    private agents;
    server: http.Server;
    socketIO: Server;
    isInitialized: boolean;
    database: DatabaseAdapter;
    startAgent: (character: Character) => Promise<IAgentRuntime>;
    stopAgent: (runtime: IAgentRuntime) => void;
    loadCharacterTryPath: (characterPath: string) => Promise<Character>;
    jsonToCharacter: (character: unknown) => Promise<Character>;
    /**
     * Constructor for AgentServer class.
     *
     * @constructor
     */
    constructor();
    /**
     * Dynamically resolves the client path based on the installation context.
     * Handles both development and production scenarios.
     *
     * @returns {string} The resolved path to the client dist directory
     * @throws {Error} If no valid client path can be found
     */
    private resolveClientPath;
    /**
     * Initializes the database and server.
     *
     * @param {ServerOptions} [options] - Optional server options.
     * @returns {Promise<void>} A promise that resolves when initialization is complete.
     */
    initialize(options?: ServerOptions): Promise<void>;
    private ensureDefaultServer;
    /**
     * Initializes the server with the provided options.
     *
     * @param {ServerOptions} [options] - Optional server options.
     * @returns {Promise<void>} - A promise that resolves once the server is initialized.
     */
    private initializeServer;
    /**
     * Registers an agent with the provided runtime.
     *
     * @param {IAgentRuntime} runtime - The runtime object containing agent information.
     * @throws {Error} if the runtime is null/undefined, if agentId is missing, if character configuration is missing,
     * or if there are any errors during registration.
     */
    registerAgent(runtime: IAgentRuntime): Promise<void>;
    /**
     * Unregisters an agent from the system.
     *
     * @param {UUID} agentId - The unique identifier of the agent to unregister.
     * @returns {void}
     */
    unregisterAgent(agentId: UUID): void;
    /**
     * Add middleware to the server's request handling pipeline
     * @param {ServerMiddleware} middleware - The middleware function to be registered
     */
    registerMiddleware(middleware: ServerMiddleware): void;
    /**
     * Starts the server on the specified port.
     *
     * @param {number} port - The port number on which the server should listen.
     * @throws {Error} If the port is invalid or if there is an error while starting the server.
     */
    start(port: number): void;
    /**
     * Stops the server if it is running. Closes the server connection,
     * stops the database connection, and logs a success message.
     */
    stop(): Promise<void>;
    createServer(data: Omit<MessageServer, 'id' | 'createdAt' | 'updatedAt'>): Promise<MessageServer>;
    getServers(): Promise<MessageServer[]>;
    getServerById(serverId: UUID): Promise<MessageServer | null>;
    getServerBySourceType(sourceType: string): Promise<MessageServer | null>;
    createChannel(data: Omit<MessageChannel, 'id' | 'createdAt' | 'updatedAt'> & {
        id?: UUID;
    }, participantIds?: UUID[]): Promise<MessageChannel>;
    addParticipantsToChannel(channelId: UUID, userIds: UUID[]): Promise<void>;
    getChannelsForServer(serverId: UUID): Promise<MessageChannel[]>;
    getChannelDetails(channelId: UUID): Promise<MessageChannel | null>;
    getChannelParticipants(channelId: UUID): Promise<UUID[]>;
    deleteMessage(messageId: UUID): Promise<void>;
    updateChannel(channelId: UUID, updates: {
        name?: string;
        participantCentralUserIds?: UUID[];
        metadata?: any;
    }): Promise<MessageChannel>;
    deleteChannel(channelId: UUID): Promise<void>;
    clearChannelMessages(channelId: UUID): Promise<void>;
    findOrCreateCentralDmChannel(user1Id: UUID, user2Id: UUID, messageServerId: UUID): Promise<MessageChannel>;
    createMessage(data: Omit<CentralRootMessage, 'id' | 'createdAt' | 'updatedAt'>): Promise<CentralRootMessage>;
    getMessagesForChannel(channelId: UUID, limit?: number, beforeTimestamp?: Date): Promise<CentralRootMessage[]>;
    removeParticipantFromChannel(): Promise<void>;
    /**
     * Add an agent to a server
     * @param {UUID} serverId - The server ID
     * @param {UUID} agentId - The agent ID to add
     */
    addAgentToServer(serverId: UUID, agentId: UUID): Promise<void>;
    /**
     * Remove an agent from a server
     * @param {UUID} serverId - The server ID
     * @param {UUID} agentId - The agent ID to remove
     */
    removeAgentFromServer(serverId: UUID, agentId: UUID): Promise<void>;
    /**
     * Get all agents associated with a server
     * @param {UUID} serverId - The server ID
     * @returns {Promise<UUID[]>} Array of agent IDs
     */
    getAgentsForServer(serverId: UUID): Promise<UUID[]>;
    /**
     * Get all servers an agent belongs to
     * @param {UUID} agentId - The agent ID
     * @returns {Promise<UUID[]>} Array of server IDs
     */
    getServersForAgent(agentId: UUID): Promise<UUID[]>;
}

export { AgentServer, type CentralRootMessage, type MessageChannel, type MessageServer, type MessageServiceStructure, type ServerMiddleware, type ServerOptions, expandTildePath, hasValidRemoteUrls, jsonToCharacter, loadCharacter, loadCharacterTryPath, loadCharacters, loadCharactersFromUrl, resolvePgliteDir, tryLoadFile };
