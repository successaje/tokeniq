var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "../../node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// ../../node_modules/vary/index.js
var require_vary = __commonJS({
  "../../node_modules/vary/index.js"(exports, module) {
    "use strict";
    module.exports = vary;
    module.exports.append = append;
    var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
    function append(header, field) {
      if (typeof header !== "string") {
        throw new TypeError("header argument is required");
      }
      if (!field) {
        throw new TypeError("field argument is required");
      }
      var fields = !Array.isArray(field) ? parse(String(field)) : field;
      for (var j = 0; j < fields.length; j++) {
        if (!FIELD_NAME_REGEXP.test(fields[j])) {
          throw new TypeError("field argument contains an invalid header name");
        }
      }
      if (header === "*") {
        return header;
      }
      var val = header;
      var vals = parse(header.toLowerCase());
      if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
        return "*";
      }
      for (var i = 0; i < fields.length; i++) {
        var fld = fields[i].toLowerCase();
        if (vals.indexOf(fld) === -1) {
          vals.push(fld);
          val = val ? val + ", " + fields[i] : fields[i];
        }
      }
      return val;
    }
    function parse(header) {
      var end = 0;
      var list = [];
      var start = 0;
      for (var i = 0, len = header.length; i < len; i++) {
        switch (header.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i + 1;
            }
            break;
          case 44:
            list.push(header.substring(start, end));
            start = end = i + 1;
            break;
          default:
            end = i + 1;
            break;
        }
      }
      list.push(header.substring(start, end));
      return list;
    }
    function vary(res, field) {
      if (!res || !res.getHeader || !res.setHeader) {
        throw new TypeError("res argument is required");
      }
      var val = res.getHeader("Vary") || "";
      var header = Array.isArray(val) ? val.join(", ") : String(val);
      if (val = append(header, field)) {
        res.setHeader("Vary", val);
      }
    }
  }
});

// ../../node_modules/cors/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/cors/lib/index.js"(exports, module) {
    "use strict";
    (function() {
      "use strict";
      var assign = require_object_assign();
      var vary = require_vary();
      var defaults = {
        origin: "*",
        methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
        preflightContinue: false,
        optionsSuccessStatus: 204
      };
      function isString(s) {
        return typeof s === "string" || s instanceof String;
      }
      function isOriginAllowed(origin, allowedOrigin) {
        if (Array.isArray(allowedOrigin)) {
          for (var i = 0; i < allowedOrigin.length; ++i) {
            if (isOriginAllowed(origin, allowedOrigin[i])) {
              return true;
            }
          }
          return false;
        } else if (isString(allowedOrigin)) {
          return origin === allowedOrigin;
        } else if (allowedOrigin instanceof RegExp) {
          return allowedOrigin.test(origin);
        } else {
          return !!allowedOrigin;
        }
      }
      function configureOrigin(options, req) {
        var requestOrigin = req.headers.origin, headers = [], isAllowed;
        if (!options.origin || options.origin === "*") {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: "*"
          }]);
        } else if (isString(options.origin)) {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: options.origin
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        } else {
          isAllowed = isOriginAllowed(requestOrigin, options.origin);
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: isAllowed ? requestOrigin : false
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        }
        return headers;
      }
      function configureMethods(options) {
        var methods = options.methods;
        if (methods.join) {
          methods = options.methods.join(",");
        }
        return {
          key: "Access-Control-Allow-Methods",
          value: methods
        };
      }
      function configureCredentials(options) {
        if (options.credentials === true) {
          return {
            key: "Access-Control-Allow-Credentials",
            value: "true"
          };
        }
        return null;
      }
      function configureAllowedHeaders(options, req) {
        var allowedHeaders = options.allowedHeaders || options.headers;
        var headers = [];
        if (!allowedHeaders) {
          allowedHeaders = req.headers["access-control-request-headers"];
          headers.push([{
            key: "Vary",
            value: "Access-Control-Request-Headers"
          }]);
        } else if (allowedHeaders.join) {
          allowedHeaders = allowedHeaders.join(",");
        }
        if (allowedHeaders && allowedHeaders.length) {
          headers.push([{
            key: "Access-Control-Allow-Headers",
            value: allowedHeaders
          }]);
        }
        return headers;
      }
      function configureExposedHeaders(options) {
        var headers = options.exposedHeaders;
        if (!headers) {
          return null;
        } else if (headers.join) {
          headers = headers.join(",");
        }
        if (headers && headers.length) {
          return {
            key: "Access-Control-Expose-Headers",
            value: headers
          };
        }
        return null;
      }
      function configureMaxAge(options) {
        var maxAge = (typeof options.maxAge === "number" || options.maxAge) && options.maxAge.toString();
        if (maxAge && maxAge.length) {
          return {
            key: "Access-Control-Max-Age",
            value: maxAge
          };
        }
        return null;
      }
      function applyHeaders(headers, res) {
        for (var i = 0, n = headers.length; i < n; i++) {
          var header = headers[i];
          if (header) {
            if (Array.isArray(header)) {
              applyHeaders(header, res);
            } else if (header.key === "Vary" && header.value) {
              vary(res, header.value);
            } else if (header.value) {
              res.setHeader(header.key, header.value);
            }
          }
        }
      }
      function cors3(options, req, res, next) {
        var headers = [], method = req.method && req.method.toUpperCase && req.method.toUpperCase();
        if (method === "OPTIONS") {
          headers.push(configureOrigin(options, req));
          headers.push(configureCredentials(options, req));
          headers.push(configureMethods(options, req));
          headers.push(configureAllowedHeaders(options, req));
          headers.push(configureMaxAge(options, req));
          headers.push(configureExposedHeaders(options, req));
          applyHeaders(headers, res);
          if (options.preflightContinue) {
            next();
          } else {
            res.statusCode = options.optionsSuccessStatus;
            res.setHeader("Content-Length", "0");
            res.end();
          }
        } else {
          headers.push(configureOrigin(options, req));
          headers.push(configureCredentials(options, req));
          headers.push(configureExposedHeaders(options, req));
          applyHeaders(headers, res);
          next();
        }
      }
      function middlewareWrapper(o) {
        var optionsCallback = null;
        if (typeof o === "function") {
          optionsCallback = o;
        } else {
          optionsCallback = function(req, cb) {
            cb(null, o);
          };
        }
        return function corsMiddleware(req, res, next) {
          optionsCallback(req, function(err, options) {
            if (err) {
              next(err);
            } else {
              var corsOptions = assign({}, defaults, options);
              var originCallback = null;
              if (corsOptions.origin && typeof corsOptions.origin === "function") {
                originCallback = corsOptions.origin;
              } else if (corsOptions.origin) {
                originCallback = function(origin, cb) {
                  cb(null, corsOptions.origin);
                };
              }
              if (originCallback) {
                originCallback(req.headers.origin, function(err2, origin) {
                  if (err2 || !origin) {
                    next(err2);
                  } else {
                    corsOptions.origin = origin;
                    cors3(corsOptions, req, res, next);
                  }
                });
              } else {
                next();
              }
            }
          });
        };
      }
      module.exports = middlewareWrapper;
    })();
  }
});

// src/index.ts
var import_cors2 = __toESM(require_lib(), 1);
import {
  logger as logger29
} from "@elizaos/core";
import express30 from "express";
import helmet2 from "helmet";
import * as fs9 from "fs";
import http from "http";
import path9, { basename, dirname, extname, join } from "path";
import { fileURLToPath as fileURLToPath2 } from "url";

// src/api/index.ts
var import_cors = __toESM(require_lib(), 1);
import { logger as logger25, validateUuid as validateUuid21 } from "@elizaos/core";
import bodyParser from "body-parser";
import express29 from "express";
import helmet from "helmet";
import { match } from "path-to-regexp";
import { Server as SocketIOServer } from "socket.io";

// src/api/agents/index.ts
import express8 from "express";

// src/api/agents/crud.ts
import {
  validateUuid,
  logger,
  stringToUuid,
  getSalt,
  encryptObjectValues,
  encryptStringValue
} from "@elizaos/core";
import express from "express";

// src/api/shared/response-utils.ts
var sendError = (res, status, code, message, details) => {
  res.status(status).json({
    success: false,
    error: {
      code,
      message,
      ...details && { details }
    }
  });
};
var sendSuccess = (res, data, status = 200) => {
  res.status(status).json({
    success: true,
    data
  });
};

// src/api/agents/crud.ts
function createAgentCrudRouter(agents, serverInstance) {
  const router = express.Router();
  const db = serverInstance?.database;
  router.get("/", async (_, res) => {
    try {
      if (!db) {
        return sendError(res, 500, "DB_ERROR", "Database not available");
      }
      const allAgents = await db.getAgents();
      const runtimes = Array.from(agents.keys());
      const response = allAgents.map((agent) => ({
        id: agent.id,
        name: agent.name || "",
        characterName: agent.name || "",
        // Since Agent extends Character, agent.name is the character name
        bio: agent.bio?.[0] ?? "",
        status: agent.id && runtimes.includes(agent.id) ? "active" : "inactive"
      })).filter((agent) => agent.id).sort((a, b) => {
        if (a.status === b.status) {
          return a.name.localeCompare(b.name);
        }
        return a.status === "active" ? -1 : 1;
      });
      sendSuccess(res, { agents: response });
    } catch (error) {
      logger.error("[AGENTS LIST] Error retrieving agents:", error);
      sendError(
        res,
        500,
        "500",
        "Error retrieving agents",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  router.get("/:agentId", async (req, res) => {
    const agentId = validateUuid(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    if (!db) {
      return sendError(res, 500, "DB_ERROR", "Database not available");
    }
    try {
      const agent = await db.getAgent(agentId);
      if (!agent) {
        return sendError(res, 404, "NOT_FOUND", "Agent not found");
      }
      const runtime = agents.get(agentId);
      const response = {
        ...agent,
        status: runtime ? "active" : "inactive"
      };
      sendSuccess(res, response);
    } catch (error) {
      logger.error("[AGENT GET] Error retrieving agent:", error);
      sendError(
        res,
        500,
        "500",
        "Error retrieving agent",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  router.post("/", async (req, res) => {
    logger.debug("[AGENT CREATE] Creating new agent");
    const { characterPath, characterJson, agent } = req.body;
    if (!db) {
      return sendError(res, 500, "DB_ERROR", "Database not available");
    }
    try {
      let character;
      if (characterJson) {
        logger.debug("[AGENT CREATE] Parsing character from JSON");
        character = await serverInstance?.jsonToCharacter(characterJson);
      } else if (characterPath) {
        logger.debug(`[AGENT CREATE] Loading character from path: ${characterPath}`);
        character = await serverInstance?.loadCharacterTryPath(characterPath);
      } else if (agent) {
        logger.debug("[AGENT CREATE] Parsing character from agent object");
        character = await serverInstance?.jsonToCharacter(agent);
      } else {
        throw new Error("No character configuration provided");
      }
      if (!character) {
        throw new Error("Failed to create character configuration");
      }
      if (character.settings?.secrets) {
        logger.debug("[AGENT CREATE] Encrypting secrets");
        const salt = getSalt();
        character.settings.secrets = encryptObjectValues(character.settings.secrets, salt);
      }
      const ensureAgentExists = async (character2) => {
        const agentId = stringToUuid(character2.name);
        let agent2 = await db.getAgent(agentId);
        if (!agent2) {
          await db.createAgent({ ...character2, id: agentId });
          agent2 = await db.getAgent(agentId);
        }
        return agent2;
      };
      const newAgent = await ensureAgentExists(character);
      if (!newAgent) {
        throw new Error(`Failed to create agent ${character.name}`);
      }
      res.status(201).json({
        success: true,
        data: {
          id: newAgent.id,
          character
        }
      });
      logger.success(`[AGENT CREATE] Successfully created agent: ${character.name}`);
    } catch (error) {
      logger.error("[AGENT CREATE] Error creating agent:", error);
      res.status(400).json({
        success: false,
        error: {
          code: "CREATE_ERROR",
          message: error instanceof Error ? error.message : "Error creating agent",
          details: error instanceof Error ? error.message : String(error)
        }
      });
    }
  });
  router.patch("/:agentId", async (req, res) => {
    const agentId = validateUuid(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    if (!db) {
      return sendError(res, 500, "DB_ERROR", "Database not available");
    }
    const updates = req.body;
    try {
      if (updates.settings?.secrets) {
        const salt = getSalt();
        const encryptedSecrets = {};
        Object.entries(updates.settings.secrets).forEach(([key, value]) => {
          if (value === null) {
            encryptedSecrets[key] = null;
          } else if (typeof value === "string") {
            encryptedSecrets[key] = encryptStringValue(value, salt);
          } else {
            encryptedSecrets[key] = value;
          }
        });
        updates.settings.secrets = encryptedSecrets;
      }
      if (Object.keys(updates).length > 0) {
        await db.updateAgent(agentId, updates);
      }
      const updatedAgent = await db.getAgent(agentId);
      const isActive = !!agents.get(agentId);
      if (isActive && updatedAgent) {
        serverInstance?.unregisterAgent(agentId);
        await serverInstance?.startAgent(updatedAgent);
      }
      const runtime = agents.get(agentId);
      const status = runtime ? "active" : "inactive";
      sendSuccess(res, { ...updatedAgent, status });
    } catch (error) {
      logger.error("[AGENT UPDATE] Error updating agent:", error);
      sendError(
        res,
        500,
        "UPDATE_ERROR",
        "Error updating agent",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  router.delete("/:agentId", async (req, res) => {
    logger.debug(`[AGENT DELETE] Received request to delete agent with ID: ${req.params.agentId}`);
    const agentId = validateUuid(req.params.agentId);
    if (!agentId) {
      logger.error(`[AGENT DELETE] Invalid agent ID format: ${req.params.agentId}`);
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    if (!db) {
      return sendError(res, 500, "DB_ERROR", "Database not available");
    }
    logger.debug(`[AGENT DELETE] Validated agent ID: ${agentId}, proceeding with deletion`);
    try {
      const agent = await db.getAgent(agentId);
      if (!agent) {
        logger.warn(`[AGENT DELETE] Agent not found: ${agentId}`);
        return sendError(res, 404, "NOT_FOUND", "Agent not found");
      }
      logger.debug(`[AGENT DELETE] Agent found: ${agent.name} (${agentId})`);
    } catch (checkError) {
      logger.error(`[AGENT DELETE] Error checking if agent exists: ${agentId}`, checkError);
    }
    const timeoutId = setTimeout(() => {
      logger.warn(`[AGENT DELETE] Operation taking longer than expected for agent: ${agentId}`);
      if (!res.headersSent) {
        res.status(202).json({
          success: true,
          partial: true,
          message: "Agent deletion initiated but taking longer than expected. The operation will continue in the background."
        });
      }
    }, 1e4);
    const MAX_RETRIES = 2;
    let retryCount = 0;
    let lastError = null;
    while (retryCount <= MAX_RETRIES) {
      try {
        const runtime = agents.get(agentId);
        if (runtime) {
          logger.debug(`[AGENT DELETE] Agent ${agentId} is running, unregistering from server`);
          try {
            serverInstance?.unregisterAgent(agentId);
            logger.debug(`[AGENT DELETE] Agent ${agentId} unregistered successfully`);
          } catch (stopError) {
            logger.error(`[AGENT DELETE] Error stopping agent ${agentId}:`, stopError);
          }
        } else {
          logger.debug(`[AGENT DELETE] Agent ${agentId} was not running, no need to unregister`);
        }
        logger.debug(`[AGENT DELETE] Calling database deleteAgent method for agent: ${agentId}`);
        const deleteResult = await db.deleteAgent(agentId);
        logger.debug(`[AGENT DELETE] Database deleteAgent result: ${JSON.stringify(deleteResult)}`);
        clearTimeout(timeoutId);
        logger.success(`[AGENT DELETE] Successfully deleted agent: ${agentId}`);
        if (!res.headersSent) {
          res.status(204).send();
        }
        return;
      } catch (error) {
        lastError = error;
        retryCount++;
        logger.error(
          `[AGENT DELETE] Error deleting agent ${agentId} (attempt ${retryCount}/${MAX_RETRIES + 1}):`,
          error
        );
        if (retryCount > MAX_RETRIES) {
          break;
        }
        const delay = 1e3 * Math.pow(2, retryCount - 1);
        logger.debug(`[AGENT DELETE] Waiting ${delay}ms before retry ${retryCount}`);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
    clearTimeout(timeoutId);
    if (!res.headersSent) {
      let statusCode = 500;
      let errorMessage = "Error deleting agent";
      if (lastError instanceof Error) {
        const message = lastError.message;
        if (message.includes("foreign key constraint")) {
          errorMessage = "Cannot delete agent because it has active references in the system";
          statusCode = 409;
        } else if (message.includes("timed out")) {
          errorMessage = "Agent deletion operation timed out";
          statusCode = 408;
        }
      }
      res.status(statusCode).json({
        success: false,
        error: {
          code: "DELETE_ERROR",
          message: errorMessage,
          details: lastError instanceof Error ? lastError.message : String(lastError)
        }
      });
    }
  });
  return router;
}

// src/api/agents/lifecycle.ts
import { validateUuid as validateUuid2, logger as logger2 } from "@elizaos/core";
import express2 from "express";
function createAgentLifecycleRouter(agents, serverInstance) {
  const router = express2.Router();
  const db = serverInstance?.database;
  router.post("/:agentId/start", async (req, res) => {
    const agentId = validateUuid2(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    if (!db) {
      return sendError(res, 500, "DB_ERROR", "Database not available");
    }
    try {
      const agent = await db.getAgent(agentId);
      if (!agent) {
        logger2.debug("[AGENT START] Agent not found");
        return sendError(res, 404, "NOT_FOUND", "Agent not found");
      }
      const isActive = !!agents.get(agentId);
      if (isActive) {
        logger2.debug(`[AGENT START] Agent ${agentId} is already running`);
        return sendSuccess(res, {
          id: agentId,
          name: agent.name,
          status: "active"
        });
      }
      await serverInstance?.startAgent(agent);
      const runtime = agents.get(agentId);
      if (!runtime) {
        throw new Error("Failed to start agent");
      }
      logger2.debug(`[AGENT START] Successfully started agent: ${agent.name}`);
      sendSuccess(res, {
        id: agentId,
        name: agent.name,
        status: "active"
      });
    } catch (error) {
      logger2.error("[AGENT START] Error starting agent:", error);
      sendError(
        res,
        500,
        "START_ERROR",
        "Error starting agent",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  router.post("/:agentId/stop", async (req, res) => {
    const agentId = validateUuid2(req.params.agentId);
    if (!agentId) {
      logger2.debug("[AGENT STOP] Invalid agent ID format");
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    serverInstance?.unregisterAgent(agentId);
    logger2.debug(`[AGENT STOP] Successfully stopped agent: ${runtime.character.name} (${agentId})`);
    sendSuccess(res, {
      message: "Agent stopped"
    });
  });
  return router;
}

// src/api/agents/worlds.ts
import { validateUuid as validateUuid3, logger as logger3, createUniqueUuid } from "@elizaos/core";
import express3 from "express";
function createAgentWorldsRouter(agents) {
  const router = express3.Router();
  router.get("/worlds", async (_req, res) => {
    try {
      const runtime = Array.from(agents.values())[0];
      if (!runtime) {
        return sendError(res, 404, "NOT_FOUND", "No active agents found to get worlds");
      }
      const worlds = await runtime.getAllWorlds();
      sendSuccess(res, { worlds });
    } catch (error) {
      logger3.error("[WORLDS LIST] Error retrieving worlds:", error);
      sendError(
        res,
        500,
        "500",
        "Error retrieving worlds",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  const createWorldHelper = async (runtime, req, res) => {
    try {
      const { name, serverId, metadata } = req.body;
      if (!name) {
        return sendError(res, 400, "BAD_REQUEST", "World name is required");
      }
      const worldId = createUniqueUuid(runtime, `world-${Date.now()}`);
      await runtime.createWorld({
        id: worldId,
        name,
        agentId: runtime.agentId,
        serverId: serverId || `server-${Date.now()}`,
        metadata
      });
      const world = (await runtime.getAllWorlds()).find((w) => w.id === worldId);
      sendSuccess(res, { world }, 201);
    } catch (error) {
      logger3.error("[WORLD CREATE] Error creating world:", error);
      sendError(
        res,
        500,
        "500",
        "Error creating world",
        error instanceof Error ? error.message : String(error)
      );
    }
  };
  router.post("/:agentId/worlds", async (req, res) => {
    const agentId = validateUuid3(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    await createWorldHelper(runtime, req, res);
  });
  router.patch("/:agentId/worlds/:worldId", async (req, res) => {
    const agentId = validateUuid3(req.params.agentId);
    const worldId = validateUuid3(req.params.worldId);
    if (!agentId || !worldId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID or world ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const world = (await runtime.getAllWorlds()).find((w) => w.id === worldId);
      if (!world) {
        return sendError(res, 404, "NOT_FOUND", "World not found");
      }
      const { name, metadata } = req.body;
      const updatedWorld = {
        ...world,
        name: name !== void 0 ? name : world.name,
        metadata: metadata !== void 0 ? world.metadata ? { ...world.metadata, ...metadata } : metadata : world.metadata
      };
      await runtime.updateWorld(updatedWorld);
      const refreshedWorld = (await runtime.getAllWorlds()).find((w) => w.id === worldId);
      sendSuccess(res, { world: refreshedWorld });
    } catch (error) {
      logger3.error("[WORLD UPDATE] Error updating world:", error);
      sendError(
        res,
        500,
        "500",
        "Error updating world",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  return router;
}

// src/api/agents/panels.ts
import { validateUuid as validateUuid4, logger as logger4 } from "@elizaos/core";
import express4 from "express";
function createAgentPanelsRouter(agents) {
  const router = express4.Router();
  router.get("/:agentId/panels", async (req, res) => {
    const agentId = validateUuid4(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const publicPanels = runtime.plugins.flatMap((plugin) => plugin.routes || []).filter((route) => route.public === true && route.type === "GET" && route.name).map((route) => ({
        name: route.name,
        path: `/api${route.path.startsWith("/") ? route.path : `/${route.path}`}?agentId=${agentId}`
      }));
      sendSuccess(res, publicPanels);
    } catch (error) {
      logger4.error(`[AGENT PANELS] Error retrieving panels for agent ${agentId}:`, error);
      sendError(
        res,
        500,
        "PANEL_ERROR",
        "Error retrieving agent panels",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  return router;
}

// src/api/agents/logs.ts
import { validateUuid as validateUuid5, logger as logger5 } from "@elizaos/core";
import express5 from "express";
function createAgentLogsRouter(agents) {
  const router = express5.Router();
  router.get("/:agentId/logs", async (req, res) => {
    const agentId = validateUuid5(req.params.agentId);
    const { roomId, type, count, offset, excludeTypes } = req.query;
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    if (roomId) {
      const roomIdValidated = validateUuid5(roomId);
      if (!roomIdValidated) {
        return sendError(res, 400, "INVALID_ID", "Invalid room ID format");
      }
    }
    try {
      const logs = await runtime.getLogs({
        entityId: agentId,
        roomId: roomId ? roomId : void 0,
        type: type ? type : void 0,
        count: count ? Number(count) : void 0,
        offset: offset ? Number(offset) : void 0
      });
      let filteredLogs = logs;
      if (excludeTypes) {
        const excludeTypesArray = Array.isArray(excludeTypes) ? excludeTypes : [excludeTypes];
        filteredLogs = logs.filter((log) => {
          if (log.type && excludeTypesArray.includes(log.type)) {
            return false;
          }
          if (log.body && typeof log.body === "object") {
            const body = log.body;
            if (body.modelType && excludeTypesArray.some(
              (excludeType) => body.modelType.toLowerCase().includes(excludeType.toLowerCase())
            )) {
              return false;
            }
          }
          return true;
        });
      }
      sendSuccess(res, filteredLogs);
    } catch (error) {
      logger5.error(`[AGENT LOGS] Error retrieving logs for agent ${agentId}:`, error);
      sendError(
        res,
        500,
        "LOG_ERROR",
        "Error retrieving agent logs",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  router.delete("/:agentId/logs/:logId", async (req, res) => {
    const agentId = validateUuid5(req.params.agentId);
    const logId = validateUuid5(req.params.logId);
    if (!agentId || !logId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent or log ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      await runtime.deleteLog(logId);
      res.status(204).send();
    } catch (error) {
      logger5.error(`[LOG DELETE] Error deleting log ${logId} for agent ${agentId}:`, error);
      sendError(
        res,
        500,
        "DELETE_ERROR",
        "Failed to delete log",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  return router;
}

// src/api/memory/agents.ts
import { MemoryType, createUniqueUuid as createUniqueUuid2 } from "@elizaos/core";
import { validateUuid as validateUuid6, logger as logger6 } from "@elizaos/core";
import express6 from "express";
function createAgentMemoryRouter(agents) {
  const router = express6.Router();
  router.get("/:agentId/rooms/:roomId/memories", async (req, res) => {
    const agentId = validateUuid6(req.params.agentId);
    const roomId = validateUuid6(req.params.roomId);
    if (!agentId || !roomId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID or room ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const limit = req.query.limit ? Number.parseInt(req.query.limit, 10) : 20;
      const before = req.query.before ? Number.parseInt(req.query.before, 10) : Date.now();
      const includeEmbedding = req.query.includeEmbedding === "true";
      const tableName = req.query.tableName || "messages";
      const memories = await runtime.getMemories({
        tableName,
        roomId,
        count: limit,
        end: before
      });
      const cleanMemories = includeEmbedding ? memories : memories.map((memory) => ({
        ...memory,
        embedding: void 0
      }));
      sendSuccess(res, { memories: cleanMemories });
    } catch (error) {
      logger6.error("[MEMORIES GET] Error retrieving memories for room:", error);
      sendError(
        res,
        500,
        "500",
        "Failed to retrieve memories",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  router.get("/:agentId/memories", async (req, res) => {
    const agentId = validateUuid6(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const tableName = req.query.tableName || "messages";
      const includeEmbedding = req.query.includeEmbedding === "true";
      let roomIdToUse;
      if (req.query.channelId) {
        const channelId = validateUuid6(req.query.channelId);
        if (!channelId) {
          return sendError(res, 400, "INVALID_ID", "Invalid channel ID format");
        }
        roomIdToUse = createUniqueUuid2(runtime, channelId);
        logger6.info(
          `[AGENT MEMORIES] Converting channelId ${channelId} to roomId ${roomIdToUse} for agent ${agentId}`
        );
      } else if (req.query.roomId) {
        const roomId = validateUuid6(req.query.roomId);
        if (!roomId) {
          return sendError(res, 400, "INVALID_ID", "Invalid room ID format");
        }
        roomIdToUse = roomId;
      }
      const memories = await runtime.getMemories({
        agentId,
        tableName,
        roomId: roomIdToUse
      });
      const cleanMemories = includeEmbedding ? memories : memories.map((memory) => ({
        ...memory,
        embedding: void 0
      }));
      sendSuccess(res, { memories: cleanMemories });
    } catch (error) {
      logger6.error(`[AGENT MEMORIES] Error retrieving memories for agent ${agentId}:`, error);
      sendError(
        res,
        500,
        "MEMORY_ERROR",
        "Error retrieving agent memories",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  router.patch("/:agentId/memories/:memoryId", async (req, res) => {
    const agentId = validateUuid6(req.params.agentId);
    const memoryId = validateUuid6(req.params.memoryId);
    const { id: _idFromData, ...restOfMemoryData } = req.body;
    if (!agentId || !memoryId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID or memory ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const memoryToUpdate = {
        // Explicitly set the required id using the validated path parameter
        id: memoryId,
        // Spread other properties from the request body.
        // Cast to Partial<Memory> to align with the base type.
        ...restOfMemoryData,
        // If specific fields from restOfMemoryData need type assertion (e.g., to UUID),
        // they should be handled here or ensured by upstream validation.
        // For example, if agentId from body is always expected as UUID:
        agentId: restOfMemoryData.agentId ? validateUuid6(restOfMemoryData.agentId) || void 0 : agentId,
        roomId: restOfMemoryData.roomId ? validateUuid6(restOfMemoryData.roomId) || void 0 : void 0,
        entityId: restOfMemoryData.entityId ? validateUuid6(restOfMemoryData.entityId) || void 0 : void 0,
        worldId: restOfMemoryData.worldId ? validateUuid6(restOfMemoryData.worldId) || void 0 : void 0,
        // Ensure metadata, if provided, conforms to MemoryMetadata
        metadata: restOfMemoryData.metadata
      };
      Object.keys(memoryToUpdate).forEach((key) => {
        if (memoryToUpdate[key] === void 0) {
          delete memoryToUpdate[key];
        }
      });
      await runtime.updateMemory(memoryToUpdate);
      logger6.success(`[MEMORY UPDATE] Successfully updated memory ${memoryId}`);
      sendSuccess(res, { id: memoryId, message: "Memory updated successfully" });
    } catch (error) {
      logger6.error(`[MEMORY UPDATE] Error updating memory ${memoryId}:`, error);
      sendError(
        res,
        500,
        "UPDATE_ERROR",
        "Failed to update memory",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  router.delete("/:agentId/memories", async (req, res) => {
    try {
      const agentId = validateUuid6(req.params.agentId);
      if (!agentId) {
        return sendError(res, 400, "INVALID_ID", "Invalid agent ID");
      }
      const runtime = agents.get(agentId);
      if (!runtime) {
        return sendError(res, 404, "NOT_FOUND", "Agent not found");
      }
      const deletedCount = (await runtime.getAllMemories()).length;
      await runtime.clearAllAgentMemories();
      sendSuccess(res, { deletedCount, message: "All agent memories cleared successfully" });
    } catch (error) {
      logger6.error("[DELETE ALL AGENT MEMORIES] Error deleting all agent memories:", error);
      sendError(
        res,
        500,
        "DELETE_ERROR",
        "Error deleting all agent memories",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  router.delete("/:agentId/memories/all/:roomId", async (req, res) => {
    try {
      const agentId = validateUuid6(req.params.agentId);
      const roomId = validateUuid6(req.params.roomId);
      if (!agentId) {
        return sendError(res, 400, "INVALID_ID", "Invalid agent ID");
      }
      if (!roomId) {
        return sendError(res, 400, "INVALID_ID", "Invalid room ID");
      }
      const runtime = agents.get(agentId);
      if (!runtime) {
        return sendError(res, 404, "NOT_FOUND", "Agent not found");
      }
      await runtime.deleteAllMemories(roomId, MemoryType.MESSAGE);
      await runtime.deleteAllMemories(roomId, MemoryType.DOCUMENT);
      res.status(204).send();
    } catch (error) {
      logger6.error("[DELETE ALL MEMORIES] Error deleting all memories:", error);
      sendError(
        res,
        500,
        "DELETE_ERROR",
        "Error deleting all memories",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  router.delete("/:agentId/memories/:memoryId", async (req, res) => {
    try {
      const agentId = validateUuid6(req.params.agentId);
      const memoryId = validateUuid6(req.params.memoryId);
      if (!agentId || !memoryId) {
        return sendError(res, 400, "INVALID_ID", "Invalid agent ID or memory ID format");
      }
      const runtime = agents.get(agentId);
      if (!runtime) {
        return sendError(res, 404, "NOT_FOUND", "Agent not found");
      }
      await runtime.deleteMemory(memoryId);
      sendSuccess(res, { message: "Memory deleted successfully" });
    } catch (error) {
      logger6.error(`[DELETE MEMORY] Error deleting memory ${req.params.memoryId}:`, error);
      sendError(
        res,
        500,
        "DELETE_ERROR",
        "Error deleting memory",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  return router;
}

// src/api/memory/rooms.ts
import { validateUuid as validateUuid7, logger as logger7, createUniqueUuid as createUniqueUuid3, ChannelType } from "@elizaos/core";
import express7 from "express";
function createRoomManagementRouter(agents) {
  const router = express7.Router();
  router.post("/:agentId/rooms", async (req, res) => {
    const agentId = validateUuid7(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const { name, type = ChannelType.DM, source = "client", worldId, metadata } = req.body;
      if (!name) {
        return sendError(res, 400, "MISSING_PARAM", "Room name is required");
      }
      const roomId = createUniqueUuid3(runtime, `room-${Date.now()}`);
      const serverId = req.body.serverId || `server-${Date.now()}`;
      let resolvedWorldId = worldId;
      if (!resolvedWorldId) {
        const worldName = `World for ${name}`;
        resolvedWorldId = createUniqueUuid3(runtime, `world-${Date.now()}`);
        await runtime.ensureWorldExists({
          id: resolvedWorldId,
          name: worldName,
          agentId: runtime.agentId,
          serverId,
          metadata
        });
      }
      await runtime.ensureRoomExists({
        id: roomId,
        name,
        source,
        type,
        channelId: roomId,
        serverId,
        worldId: resolvedWorldId,
        metadata
      });
      await runtime.addParticipant(runtime.agentId, roomId);
      await runtime.ensureParticipantInRoom(runtime.agentId, roomId);
      await runtime.setParticipantUserState(roomId, runtime.agentId, "FOLLOWED");
      sendSuccess(
        res,
        {
          id: roomId,
          name,
          agentId,
          createdAt: Date.now(),
          source,
          type,
          worldId: resolvedWorldId,
          serverId,
          metadata
        },
        201
      );
    } catch (error) {
      logger7.error(`[ROOM CREATE] Error creating room for agent ${agentId}:`, error);
      sendError(
        res,
        500,
        "CREATE_ERROR",
        "Failed to create room",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  router.get("/:agentId/rooms", async (req, res) => {
    const agentId = validateUuid7(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const worlds = await runtime.getAllWorlds();
      const participantRoomIds = await runtime.getRoomsForParticipant(agentId);
      const agentRooms = [];
      for (const world of worlds) {
        const worldRooms = await runtime.getRooms(world.id);
        for (const room of worldRooms) {
          if (participantRoomIds.includes(room.id)) {
            agentRooms.push({
              ...room
            });
          }
        }
      }
      sendSuccess(res, { rooms: agentRooms });
    } catch (error) {
      logger7.error(`[ROOMS LIST] Error retrieving rooms for agent ${agentId}:`, error);
      sendError(
        res,
        500,
        "RETRIEVAL_ERROR",
        "Failed to retrieve agent rooms",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  router.get("/:agentId/rooms/:roomId", async (req, res) => {
    const agentId = validateUuid7(req.params.agentId);
    const roomId = validateUuid7(req.params.roomId);
    if (!agentId || !roomId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID or room ID format");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const room = await runtime.getRoom(roomId);
      if (!room) {
        return sendError(res, 404, "NOT_FOUND", "Room not found");
      }
      let worldName;
      if (room.worldId) {
        const world = await runtime.getWorld(room.worldId);
        worldName = world?.name;
      }
      sendSuccess(res, {
        ...room,
        ...worldName && { worldName }
      });
    } catch (error) {
      logger7.error(`[ROOM DETAILS] Error retrieving room ${roomId} for agent ${agentId}:`, error);
      sendError(
        res,
        500,
        "RETRIEVAL_ERROR",
        "Failed to retrieve room details",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  return router;
}

// src/api/agents/index.ts
function agentsRouter(agents, serverInstance) {
  const router = express8.Router();
  router.use("/", createAgentCrudRouter(agents, serverInstance));
  router.use("/", createAgentLifecycleRouter(agents, serverInstance));
  router.use("/", createAgentWorldsRouter(agents));
  router.use("/", createAgentPanelsRouter(agents));
  router.use("/", createAgentLogsRouter(agents));
  router.use("/", createAgentMemoryRouter(agents));
  router.use("/", createRoomManagementRouter(agents));
  return router;
}

// src/api/messaging/index.ts
import express12 from "express";

// src/api/messaging/core.ts
import { logger as logger8, validateUuid as validateUuid8 } from "@elizaos/core";
import express9 from "express";

// src/bus.ts
import EventEmitter from "events";
var InternalMessageBus = class extends EventEmitter {
};
var internalMessageBus = new InternalMessageBus();
internalMessageBus.setMaxListeners(50);
var bus_default = internalMessageBus;

// src/api/messaging/core.ts
var DEFAULT_SERVER_ID = "00000000-0000-0000-0000-000000000000";
function createMessagingCoreRouter(serverInstance) {
  const router = express9.Router();
  router.post("/submit", async (req, res) => {
    const {
      channel_id,
      server_id,
      // This is the server_id
      author_id,
      // This should be the agent's runtime.agentId or a dedicated central ID for the agent
      content,
      in_reply_to_message_id,
      // This is a root_message.id
      source_type,
      raw_message,
      metadata
      // Should include agent_name if author_id is agent's runtime.agentId
    } = req.body;
    const isValidServerId = server_id === DEFAULT_SERVER_ID || validateUuid8(server_id);
    if (!validateUuid8(channel_id) || !validateUuid8(author_id) || !content || !isValidServerId || !source_type || !raw_message) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: channel_id, server_id, author_id, content, source_type, raw_message"
      });
    }
    if (in_reply_to_message_id && !validateUuid8(in_reply_to_message_id)) {
      return res.status(400).json({
        success: false,
        error: "Invalid in_reply_to_message_id format"
      });
    }
    try {
      const newRootMessageData = {
        channelId: validateUuid8(channel_id),
        authorId: validateUuid8(author_id),
        content,
        rawMessage: raw_message,
        sourceType: source_type || "agent_response",
        inReplyToRootMessageId: in_reply_to_message_id ? validateUuid8(in_reply_to_message_id) || void 0 : void 0,
        metadata
      };
      const createdMessage = await serverInstance.createMessage(newRootMessageData);
      if (serverInstance.socketIO) {
        serverInstance.socketIO.to(channel_id).emit("messageBroadcast", {
          senderId: author_id,
          // This is the agent's ID
          senderName: metadata?.agentName || "Agent",
          text: content,
          roomId: channel_id,
          // For SocketIO, room is the central channel_id
          serverId: server_id,
          // Client layer uses serverId
          createdAt: new Date(createdMessage.createdAt).getTime(),
          source: createdMessage.sourceType,
          id: createdMessage.id,
          // Central message ID
          thought: raw_message?.thought,
          actions: raw_message?.actions,
          attachments: metadata?.attachments
        });
      }
      res.status(201).json({ success: true, data: createdMessage });
    } catch (error) {
      logger8.error("[Messages Router /submit] Error submitting agent message:", error);
      res.status(500).json({ success: false, error: "Failed to submit agent message" });
    }
  });
  router.post("/complete", async (req, res) => {
    const { channel_id, server_id } = req.body;
    if (!validateUuid8(channel_id) || !validateUuid8(server_id)) {
      return res.status(400).json({
        success: false,
        error: "Missing or invalid fields: channel_id, server_id"
      });
    }
    try {
      if (serverInstance.socketIO) {
        serverInstance.socketIO.to(channel_id).emit("messageComplete", {
          channelId: channel_id,
          serverId: server_id
        });
      }
      res.status(200).json({ success: true, message: "Completion event emitted" });
    } catch (error) {
      logger8.error("[Messages Router /notify-complete] Error notifying message complete:", error);
      res.status(500).json({ success: false, error: "Failed to notify message completion" });
    }
  });
  router.post("/ingest-external", async (req, res) => {
    const messagePayload = req.body;
    if (!messagePayload.channel_id || !messagePayload.server_id || !messagePayload.author_id || !messagePayload.content) {
      return res.status(400).json({ success: false, error: "Invalid external message payload" });
    }
    try {
      const messageToCreate = {
        channelId: messagePayload.channel_id,
        authorId: messagePayload.author_id,
        // This is the original author's ID from the platform (needs mapping to central user ID later)
        content: messagePayload.content,
        rawMessage: messagePayload.raw_message,
        sourceId: messagePayload.source_id,
        // Original platform message ID
        sourceType: messagePayload.source_type,
        inReplyToRootMessageId: messagePayload.in_reply_to_message_id ? validateUuid8(messagePayload.in_reply_to_message_id) || void 0 : void 0,
        metadata: messagePayload.metadata
      };
      const createdRootMessage = await serverInstance.createMessage(messageToCreate);
      const messageForBus = {
        id: createdRootMessage.id,
        channel_id: createdRootMessage.channelId,
        server_id: messagePayload.server_id,
        // Pass through the original server_id
        author_id: createdRootMessage.authorId,
        // This is the central ID used for storage
        author_display_name: messagePayload.author_display_name,
        // Pass through display name
        content: createdRootMessage.content,
        raw_message: createdRootMessage.rawMessage,
        source_id: createdRootMessage.sourceId,
        source_type: createdRootMessage.sourceType,
        in_reply_to_message_id: createdRootMessage.inReplyToRootMessageId,
        created_at: new Date(createdRootMessage.createdAt).getTime(),
        metadata: createdRootMessage.metadata
      };
      bus_default.emit("new_message", messageForBus);
      logger8.info(
        "[Messages Router /ingest-external] Published to internal message bus:",
        createdRootMessage.id
      );
      if (serverInstance.socketIO) {
        serverInstance.socketIO.to(messageForBus.channel_id).emit("messageBroadcast", {
          senderId: messageForBus.author_id,
          senderName: messageForBus.author_display_name || "User",
          text: messageForBus.content,
          roomId: messageForBus.channel_id,
          serverId: messageForBus.server_id,
          // Client layer uses serverId
          createdAt: messageForBus.created_at,
          source: messageForBus.source_type,
          id: messageForBus.id
        });
      }
      res.status(202).json({
        success: true,
        message: "Message ingested and published to bus",
        data: { messageId: createdRootMessage.id }
      });
    } catch (error) {
      logger8.error("[Messages Router /ingest-external] Error ingesting external message:", error);
      res.status(500).json({ success: false, error: "Failed to ingest message" });
    }
  });
  return router;
}

// src/api/messaging/servers.ts
import { logger as logger9, validateUuid as validateUuid9 } from "@elizaos/core";
import express10 from "express";
var DEFAULT_SERVER_ID2 = "00000000-0000-0000-0000-000000000000";
function createServersRouter(serverInstance) {
  const router = express10.Router();
  router.get("/central-servers", async (_req, res) => {
    try {
      const servers = await serverInstance.getServers();
      res.json({ success: true, data: { servers } });
    } catch (error) {
      logger9.error("[Messages Router /central-servers] Error fetching servers:", error);
      res.status(500).json({ success: false, error: "Failed to fetch servers" });
    }
  });
  router.post("/servers", async (req, res) => {
    const { name, sourceType, sourceId, metadata } = req.body;
    if (!name || !sourceType) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: name, sourceType"
      });
    }
    try {
      const server = await serverInstance.createServer({
        name,
        sourceType,
        sourceId,
        metadata
      });
      res.status(201).json({ success: true, data: { server } });
    } catch (error) {
      logger9.error("[Messages Router /servers] Error creating server:", error);
      res.status(500).json({ success: false, error: "Failed to create server" });
    }
  });
  router.post(
    "/servers/:serverId/agents",
    async (req, res) => {
      const serverId = req.params.serverId === DEFAULT_SERVER_ID2 ? DEFAULT_SERVER_ID2 : validateUuid9(req.params.serverId);
      const { agentId } = req.body;
      if (!serverId || !validateUuid9(agentId)) {
        return res.status(400).json({
          success: false,
          error: "Invalid serverId or agentId format"
        });
      }
      try {
        await serverInstance.addAgentToServer(serverId, agentId);
        const messageForBus = {
          type: "agent_added_to_server",
          serverId,
          agentId
        };
        bus_default.emit("server_agent_update", messageForBus);
        res.status(201).json({
          success: true,
          data: {
            serverId,
            agentId,
            message: "Agent added to server successfully"
          }
        });
      } catch (error) {
        logger9.error(
          `[MessagesRouter] Error adding agent ${agentId} to server ${serverId}:`,
          error
        );
        res.status(500).json({ success: false, error: "Failed to add agent to server" });
      }
    }
  );
  router.delete(
    "/servers/:serverId/agents/:agentId",
    async (req, res) => {
      const serverId = req.params.serverId === DEFAULT_SERVER_ID2 ? DEFAULT_SERVER_ID2 : validateUuid9(req.params.serverId);
      const agentId = validateUuid9(req.params.agentId);
      if (!serverId || !agentId) {
        return res.status(400).json({
          success: false,
          error: "Invalid serverId or agentId format"
        });
      }
      try {
        await serverInstance.removeAgentFromServer(serverId, agentId);
        const messageForBus = {
          type: "agent_removed_from_server",
          serverId,
          agentId
        };
        bus_default.emit("server_agent_update", messageForBus);
        res.status(200).json({
          success: true,
          data: {
            serverId,
            agentId,
            message: "Agent removed from server successfully"
          }
        });
      } catch (error) {
        logger9.error(
          `[MessagesRouter] Error removing agent ${agentId} from server ${serverId}:`,
          error
        );
        res.status(500).json({ success: false, error: "Failed to remove agent from server" });
      }
    }
  );
  router.get(
    "/servers/:serverId/agents",
    async (req, res) => {
      const serverId = req.params.serverId === DEFAULT_SERVER_ID2 ? DEFAULT_SERVER_ID2 : validateUuid9(req.params.serverId);
      if (!serverId) {
        return res.status(400).json({
          success: false,
          error: "Invalid serverId format"
        });
      }
      try {
        const agents = await serverInstance.getAgentsForServer(serverId);
        res.json({
          success: true,
          data: {
            serverId,
            agents
            // Array of agent IDs
          }
        });
      } catch (error) {
        logger9.error(`[MessagesRouter] Error fetching agents for server ${serverId}:`, error);
        res.status(500).json({ success: false, error: "Failed to fetch server agents" });
      }
    }
  );
  router.get(
    "/agents/:agentId/servers",
    async (req, res) => {
      const agentId = validateUuid9(req.params.agentId);
      if (!agentId) {
        return res.status(400).json({
          success: false,
          error: "Invalid agentId format"
        });
      }
      try {
        const servers = await serverInstance.getServersForAgent(agentId);
        res.json({
          success: true,
          data: {
            agentId,
            servers
            // Array of server IDs
          }
        });
      } catch (error) {
        logger9.error(`[MessagesRouter] Error fetching servers for agent ${agentId}:`, error);
        res.status(500).json({ success: false, error: "Failed to fetch agent servers" });
      }
    }
  );
  return router;
}

// src/api/messaging/channels.ts
import {
  composePromptFromState,
  ModelType,
  ChannelType as ChannelType2,
  logger as logger12,
  validateUuid as validateUuid12
} from "@elizaos/core";
import express11 from "express";

// src/api/shared/middleware.ts
import { validateUuid as validateUuid11, logger as logger11 } from "@elizaos/core";

// src/api/shared/validation.ts
import { validateUuid as validateUuid10, logger as logger10 } from "@elizaos/core";
var getRuntime = (agents, agentId) => {
  const runtime = agents.get(agentId);
  if (!runtime) {
    throw new Error(`Agent not found: ${agentId}`);
  }
  return runtime;
};

// src/api/shared/middleware.ts
import rateLimit from "express-rate-limit";
var securityMiddleware = () => {
  return (req, res, next) => {
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.setHeader("X-Frame-Options", "SAMEORIGIN");
    res.setHeader("X-XSS-Protection", "1; mode=block");
    res.setHeader("Referrer-Policy", "no-referrer");
    res.removeHeader("X-Powered-By");
    res.removeHeader("Server");
    const userAgent = req.get("User-Agent");
    const forwarded = req.get("X-Forwarded-For");
    const realIp = req.get("X-Real-IP");
    const clientIp = forwarded || realIp || req.ip;
    if (userAgent && (userAgent.includes("..") || userAgent.includes("<script"))) {
      logger11.warn(`[SECURITY] Suspicious User-Agent from ${clientIp}: ${userAgent}`);
    }
    const url = req.originalUrl || req.url;
    const queryString = JSON.stringify(req.query);
    const suspiciousIndicators = [
      { pattern: "..", name: "Path traversal" },
      { pattern: "<script", name: "XSS attempt" },
      { pattern: "javascript:", name: "JavaScript injection" }
    ];
    const sqlKeywords = ["union", "select", "drop", "delete", "insert", "update"];
    let hasSqlPattern = false;
    const lowerUrl = url.toLowerCase();
    const lowerQuery = queryString.toLowerCase();
    for (let i = 0; i < sqlKeywords.length - 1; i++) {
      const keyword1 = sqlKeywords[i];
      for (let j = i + 1; j < sqlKeywords.length; j++) {
        const keyword2 = sqlKeywords[j];
        if (lowerUrl.includes(keyword1) && lowerUrl.includes(keyword2) || lowerQuery.includes(keyword1) && lowerQuery.includes(keyword2)) {
          hasSqlPattern = true;
          break;
        }
      }
      if (hasSqlPattern) break;
    }
    for (const indicator of suspiciousIndicators) {
      if (url.includes(indicator.pattern) || queryString.includes(indicator.pattern)) {
        logger11.warn(`[SECURITY] ${indicator.name} detected from ${clientIp}: ${url}`);
        break;
      }
    }
    if (hasSqlPattern) {
      logger11.warn(`[SECURITY] SQL injection pattern detected from ${clientIp}: ${url}`);
    }
    next();
  };
};
var validateContentTypeMiddleware = () => {
  return (req, res, next) => {
    if (["POST", "PUT", "PATCH"].includes(req.method)) {
      const contentType = req.get("Content-Type");
      const contentLength = req.get("Content-Length");
      if (!contentLength || contentLength === "0") {
        return next();
      }
      const validTypes = [
        "application/json",
        "multipart/form-data",
        "application/x-www-form-urlencoded"
      ];
      if (!contentType || !validTypes.some((type) => contentType.includes(type))) {
        return sendError(
          res,
          400,
          "INVALID_CONTENT_TYPE",
          "Invalid or missing Content-Type header"
        );
      }
    }
    next();
  };
};
var createApiRateLimit = () => {
  return rateLimit({
    windowMs: 15 * 60 * 1e3,
    // 15 minutes
    max: 1e3,
    // Limit each IP to 1000 requests per windowMs
    message: {
      success: false,
      error: {
        code: "RATE_LIMIT_EXCEEDED",
        message: "Too many requests. Please try again later."
      }
    },
    standardHeaders: true,
    // Return rate limit info in the `RateLimitInfo` headers
    legacyHeaders: false,
    // Disable the `X-RateLimit-*` headers
    handler: (req, res) => {
      const clientIp = req.ip || "unknown";
      logger11.warn(`[SECURITY] Rate limit exceeded for IP: ${clientIp}`);
      res.status(429).json({
        success: false,
        error: {
          code: "RATE_LIMIT_EXCEEDED",
          message: "Too many requests. Please try again later."
        }
      });
    }
  });
};
var createFileSystemRateLimit = () => {
  return rateLimit({
    windowMs: 5 * 60 * 1e3,
    // 5 minutes
    max: 100,
    // Limit each IP to 100 file operations per 5 minutes
    message: {
      success: false,
      error: {
        code: "FILE_RATE_LIMIT_EXCEEDED",
        message: "Too many file operations. Please try again later."
      }
    },
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res) => {
      const clientIp = req.ip || "unknown";
      logger11.warn(
        `[SECURITY] File system rate limit exceeded for IP: ${clientIp}, endpoint: ${req.path}`
      );
      res.status(429).json({
        success: false,
        error: {
          code: "FILE_RATE_LIMIT_EXCEEDED",
          message: "Too many file operations. Please try again later."
        }
      });
    }
  });
};
var createUploadRateLimit = () => {
  return rateLimit({
    windowMs: 15 * 60 * 1e3,
    // 15 minutes
    max: 50,
    // Limit each IP to 50 uploads per 15 minutes
    message: {
      success: false,
      error: {
        code: "UPLOAD_RATE_LIMIT_EXCEEDED",
        message: "Too many upload attempts. Please try again later."
      }
    },
    standardHeaders: true,
    legacyHeaders: false,
    handler: (req, res) => {
      const clientIp = req.ip || "unknown";
      logger11.warn(
        `[SECURITY] Upload rate limit exceeded for IP: ${clientIp}, endpoint: ${req.path}`
      );
      res.status(429).json({
        success: false,
        error: {
          code: "UPLOAD_RATE_LIMIT_EXCEEDED",
          message: "Too many upload attempts. Please try again later."
        }
      });
    }
  });
};

// src/api/shared/constants.ts
var MAX_FILE_SIZE = 50 * 1024 * 1024;
var MAX_FILE_SIZE_DISPLAY = "50MB";
var ALLOWED_AUDIO_MIME_TYPES = [
  "audio/mpeg",
  "audio/mp3",
  "audio/wav",
  "audio/ogg",
  "audio/webm",
  "audio/mp4",
  "audio/aac",
  "audio/flac",
  "audio/x-wav",
  "audio/wave"
];
var ALLOWED_MEDIA_MIME_TYPES = [
  ...ALLOWED_AUDIO_MIME_TYPES,
  "image/jpeg",
  "image/png",
  "image/gif",
  "image/webp",
  "video/mp4",
  "video/webm",
  "application/pdf",
  "text/plain"
];

// src/api/messaging/channels.ts
import multer from "multer";
import fs from "fs";
import path from "path";
var DEFAULT_SERVER_ID3 = "00000000-0000-0000-0000-000000000000";
var channelStorage = multer.memoryStorage();
var channelUploadMiddleware = multer({
  storage: channelStorage,
  limits: {
    fileSize: MAX_FILE_SIZE,
    files: 1
  },
  fileFilter: (req, file, cb) => {
    if (ALLOWED_MEDIA_MIME_TYPES.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Invalid file type"), false);
    }
  }
});
async function saveChannelUploadedFile(file, channelId) {
  const uploadDir = path.join(process.cwd(), ".eliza/data/uploads/channels", channelId);
  if (!fs.existsSync(uploadDir)) {
    fs.mkdirSync(uploadDir, { recursive: true });
  }
  const timestamp = Date.now();
  const random = Math.round(Math.random() * 1e9);
  const ext = path.extname(file.originalname);
  const filename = `${timestamp}-${random}${ext}`;
  const filePath = path.join(uploadDir, filename);
  fs.writeFileSync(filePath, file.buffer);
  const url = `/media/uploads/channels/${channelId}/${filename}`;
  return { filename, url };
}
function createChannelsRouter(agents, serverInstance) {
  const router = express11.Router();
  router.post(
    "/central-channels/:channelId/messages",
    async (req, res) => {
      const channelIdParam = validateUuid12(req.params.channelId);
      const {
        author_id,
        // This is the GUI user's central ID
        content,
        in_reply_to_message_id,
        // Central root_message.id
        server_id,
        // Central server_id this channel belongs to
        raw_message,
        metadata,
        // Should include user_display_name
        source_type
        // Should be something like 'eliza_gui'
      } = req.body;
      const isValidServerId = server_id === DEFAULT_SERVER_ID3 || validateUuid12(server_id);
      if (!channelIdParam || !validateUuid12(author_id) || !content || !isValidServerId) {
        return res.status(400).json({
          success: false,
          error: "Missing required fields: channelId, server_id, author_id, content"
        });
      }
      try {
        logger12.info(
          `[Messages Router] Checking if channel ${channelIdParam} exists before creating message`
        );
        let channelExists = false;
        try {
          const existingChannel = await serverInstance.getChannelDetails(channelIdParam);
          channelExists = !!existingChannel;
          logger12.info(`[Messages Router] Channel ${channelIdParam} exists: ${channelExists}`);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          logger12.info(
            `[Messages Router] Channel ${channelIdParam} does not exist, will create it. Error: ${errorMessage}`
          );
        }
        if (!channelExists) {
          logger12.info(
            `[Messages Router] Auto-creating channel ${channelIdParam} with serverId ${server_id}`
          );
          try {
            const servers = await serverInstance.getServers();
            const serverExists = servers.some((s) => s.id === server_id);
            logger12.info(
              `[Messages Router] Server ${server_id} exists: ${serverExists}. Available servers: ${servers.map((s) => s.id).join(", ")}`
            );
            if (!serverExists) {
              logger12.error(
                `[Messages Router] Server ${server_id} does not exist, cannot create channel`
              );
              return res.status(500).json({ success: false, error: `Server ${server_id} does not exist` });
            }
            const isDmChannel = metadata?.isDm || metadata?.channelType === ChannelType2.DM || metadata?.channel_type === ChannelType2.DM;
            const channelData = {
              id: channelIdParam,
              // Use the specific channel ID from the URL
              messageServerId: server_id,
              name: isDmChannel ? `DM ${channelIdParam.substring(0, 8)}` : `Chat ${channelIdParam.substring(0, 8)}`,
              type: isDmChannel ? ChannelType2.DM : ChannelType2.GROUP,
              sourceType: "auto_created",
              metadata: {
                created_by: "gui_auto_creation",
                created_for_user: author_id,
                created_at: (/* @__PURE__ */ new Date()).toISOString(),
                channel_type: isDmChannel ? ChannelType2.DM : ChannelType2.GROUP,
                ...metadata
              }
            };
            logger12.info(
              "[Messages Router] Creating channel with data:",
              JSON.stringify(channelData, null, 2)
            );
            const participants = [author_id];
            if (isDmChannel) {
              const otherParticipant = metadata?.targetUserId || metadata?.recipientId;
              if (otherParticipant && validateUuid12(otherParticipant)) {
                participants.push(otherParticipant);
                logger12.info(
                  `[Messages Router] DM channel will include participants: ${participants.join(", ")}`
                );
              } else {
                logger12.warn(
                  `[Messages Router] DM channel missing second participant, only adding author: ${author_id}`
                );
              }
            }
            await serverInstance.createChannel(channelData, participants);
            logger12.info(
              `[Messages Router] Auto-created ${isDmChannel ? ChannelType2.DM : ChannelType2.GROUP} channel ${channelIdParam} for message submission with ${participants.length} participants`
            );
          } catch (createError) {
            const errorMessage = createError instanceof Error ? createError.message : String(createError);
            logger12.error(
              `[Messages Router] Failed to auto-create channel ${channelIdParam}:`,
              createError
            );
            return res.status(500).json({ success: false, error: `Failed to create channel: ${errorMessage}` });
          }
        } else {
          logger12.info(
            `[Messages Router] Channel ${channelIdParam} already exists, proceeding with message creation`
          );
        }
        const newRootMessageData = {
          channelId: channelIdParam,
          authorId: author_id,
          content,
          inReplyToRootMessageId: in_reply_to_message_id ? validateUuid12(in_reply_to_message_id) || void 0 : void 0,
          rawMessage: raw_message,
          metadata,
          sourceType: source_type || "eliza_gui"
        };
        const createdRootMessage = await serverInstance.createMessage(newRootMessageData);
        if (!createdRootMessage.id) {
          throw new Error("Created message does not have an ID");
        }
        const messageForBus = {
          id: createdRootMessage.id,
          channel_id: createdRootMessage.channelId,
          server_id,
          author_id: createdRootMessage.authorId,
          content: createdRootMessage.content,
          created_at: new Date(createdRootMessage.createdAt).getTime(),
          source_type: createdRootMessage.sourceType,
          raw_message: createdRootMessage.rawMessage,
          metadata: createdRootMessage.metadata,
          author_display_name: metadata?.user_display_name,
          // Get from GUI payload
          in_reply_to_message_id: createdRootMessage.inReplyToRootMessageId,
          source_id: createdRootMessage.sourceId
          // Will be undefined here, which is fine
        };
        bus_default.emit("new_message", messageForBus);
        logger12.info(
          "[Messages Router /central-channels/:channelId/messages] GUI Message published to internal bus:",
          messageForBus.id
        );
        if (serverInstance.socketIO) {
          serverInstance.socketIO.to(channelIdParam).emit("messageBroadcast", {
            senderId: author_id,
            senderName: metadata?.user_display_name || "User",
            text: content,
            roomId: channelIdParam,
            // GUI uses central channelId as roomId for socket
            serverId: server_id,
            // Client layer uses serverId
            createdAt: messageForBus.created_at,
            source: messageForBus.source_type,
            id: messageForBus.id
          });
        }
        res.status(201).json({ success: true, data: messageForBus });
      } catch (error) {
        logger12.error(
          "[Messages Router /central-channels/:channelId/messages] Error processing GUI message:",
          error
        );
        res.status(500).json({ success: false, error: "Failed to process message" });
      }
    }
  );
  router.get(
    "/central-channels/:channelId/messages",
    async (req, res) => {
      const channelId = validateUuid12(req.params.channelId);
      const limit = req.query.limit ? Number.parseInt(req.query.limit, 10) : 50;
      const before = req.query.before ? Number.parseInt(req.query.before, 10) : void 0;
      const beforeDate = before ? new Date(before) : void 0;
      if (!channelId) {
        return res.status(400).json({ success: false, error: "Invalid channelId" });
      }
      try {
        const messages = await serverInstance.getMessagesForChannel(channelId, limit, beforeDate);
        const messagesForGui = messages.map((msg) => {
          const rawMessage = typeof msg.rawMessage === "string" ? JSON.parse(msg.rawMessage) : msg.rawMessage;
          return {
            ...msg,
            created_at: new Date(msg.createdAt).getTime(),
            // Ensure timestamp number
            updated_at: new Date(msg.updatedAt).getTime(),
            // Include thought and actions from rawMessage in metadata for client compatibility
            metadata: {
              ...msg.metadata,
              thought: rawMessage?.thought,
              actions: rawMessage?.actions
            }
            // Ensure other fields align with client's MessageServiceStructure / ServerMessage
          };
        });
        res.json({ success: true, data: { messages: messagesForGui } });
      } catch (error) {
        logger12.error(
          `[Messages Router /central-channels/:channelId/messages] Error fetching messages for channel ${channelId}:`,
          error
        );
        res.status(500).json({ success: false, error: "Failed to fetch messages" });
      }
    }
  );
  router.get(
    "/central-servers/:serverId/channels",
    async (req, res) => {
      const serverId = req.params.serverId === DEFAULT_SERVER_ID3 ? DEFAULT_SERVER_ID3 : validateUuid12(req.params.serverId);
      if (!serverId) {
        return res.status(400).json({ success: false, error: "Invalid serverId" });
      }
      try {
        const channels = await serverInstance.getChannelsForServer(serverId);
        res.json({ success: true, data: { channels } });
      } catch (error) {
        logger12.error(
          `[Messages Router /central-servers/:serverId/channels] Error fetching channels for server ${serverId}:`,
          error
        );
        res.status(500).json({ success: false, error: "Failed to fetch channels" });
      }
    }
  );
  router.post("/channels", async (req, res) => {
    const serverId = req.body.serverId;
    const { name, type, sourceType, sourceId, metadata } = req.body;
    const topic = req.body.topic ?? req.body.description;
    if (!serverId) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: serverId."
      });
    }
    if (!name) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: name."
      });
    }
    if (!type) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: type."
      });
    }
    if (!validateUuid12(serverId)) {
      return res.status(400).json({
        success: false,
        error: "Invalid serverId format"
      });
    }
    try {
      const channel = await serverInstance.createChannel({
        messageServerId: serverId,
        name,
        type,
        sourceType,
        sourceId,
        topic,
        metadata
      });
      res.status(201).json({ success: true, data: { channel } });
    } catch (error) {
      logger12.error("[Messages Router /channels] Error creating channel:", error);
      res.status(500).json({ success: false, error: "Failed to create channel" });
    }
  });
  router.get("/dm-channel", async (req, res) => {
    const targetUserId = validateUuid12(req.query.targetUserId);
    const currentUserId = validateUuid12(req.query.currentUserId);
    const providedDmServerId = req.query.dmServerId === DEFAULT_SERVER_ID3 ? DEFAULT_SERVER_ID3 : validateUuid12(req.query.dmServerId);
    if (!targetUserId || !currentUserId) {
      res.status(400).json({ success: false, error: "Missing targetUserId or currentUserId" });
      return;
    }
    if (targetUserId === currentUserId) {
      res.status(400).json({ success: false, error: "Cannot create DM channel with oneself" });
      return;
    }
    let dmServerIdToUse = DEFAULT_SERVER_ID3;
    try {
      if (providedDmServerId) {
        const existingServer = await serverInstance.getServerById(providedDmServerId);
        if (existingServer) {
          dmServerIdToUse = providedDmServerId;
        } else {
          logger12.warn(
            `Provided dmServerId ${providedDmServerId} not found, using default DM server logic.`
          );
          dmServerIdToUse = DEFAULT_SERVER_ID3;
        }
      }
      const channel = await serverInstance.findOrCreateCentralDmChannel(
        currentUserId,
        targetUserId,
        dmServerIdToUse
      );
      res.json({ success: true, data: channel });
    } catch (error) {
      const errorDetails = error instanceof Error ? {
        message: error.message,
        stack: error.stack,
        originalError: error
      } : { message: String(error) };
      logger12.error("Error finding/creating DM channel:", errorDetails);
      res.status(500).json({ success: false, error: "Failed to find or create DM channel" });
    }
  });
  router.post("/central-channels", async (req, res) => {
    const {
      name,
      participantCentralUserIds,
      type = ChannelType2.GROUP,
      server_id,
      metadata
    } = req.body;
    const isValidServerId = server_id === DEFAULT_SERVER_ID3 || validateUuid12(server_id);
    if (!name || !isValidServerId || !Array.isArray(participantCentralUserIds) || participantCentralUserIds.some((id) => !validateUuid12(id))) {
      return res.status(400).json({
        success: false,
        error: 'Invalid payload. Required: name, server_id (UUID or "0"), participantCentralUserIds (array of UUIDs). Optional: type, metadata.'
      });
    }
    try {
      const channelData = {
        messageServerId: server_id,
        name,
        type,
        metadata: {
          ...metadata || {}
          // participantIds are now handled by the separate table via createChannel's second argument
        }
      };
      const newChannel = await serverInstance.createChannel(
        channelData,
        participantCentralUserIds
      );
      res.status(201).json({ success: true, data: newChannel });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger12.error(
        "[Messages Router /central-channels] Error creating group channel:",
        errorMessage
      );
      res.status(500).json({ success: false, error: "Failed to create group channel", details: errorMessage });
    }
  });
  router.get(
    "/central-channels/:channelId/details",
    async (req, res) => {
      const channelId = validateUuid12(req.params.channelId);
      if (!channelId) {
        return res.status(400).json({ success: false, error: "Invalid channelId" });
      }
      try {
        const channelDetails = await serverInstance.getChannelDetails(channelId);
        if (!channelDetails) {
          return res.status(404).json({ success: false, error: "Channel not found" });
        }
        res.json({ success: true, data: channelDetails });
      } catch (error) {
        logger12.error(`[Messages Router] Error fetching details for channel ${channelId}:`, error);
        res.status(500).json({ success: false, error: "Failed to fetch channel details" });
      }
    }
  );
  router.get(
    "/central-channels/:channelId/participants",
    async (req, res) => {
      const channelId = validateUuid12(req.params.channelId);
      if (!channelId) {
        return res.status(400).json({ success: false, error: "Invalid channelId" });
      }
      try {
        const participants = await serverInstance.getChannelParticipants(channelId);
        res.json({ success: true, data: participants });
      } catch (error) {
        logger12.error(
          `[Messages Router] Error fetching participants for channel ${channelId}:`,
          error
        );
        res.status(500).json({ success: false, error: "Failed to fetch channel participants" });
      }
    }
  );
  router.post(
    "/central-channels/:channelId/agents",
    async (req, res) => {
      const channelId = validateUuid12(req.params.channelId);
      const { agentId } = req.body;
      if (!channelId || !validateUuid12(agentId)) {
        return res.status(400).json({
          success: false,
          error: "Invalid channelId or agentId format"
        });
      }
      try {
        const channel = await serverInstance.getChannelDetails(channelId);
        if (!channel) {
          return res.status(404).json({
            success: false,
            error: "Channel not found"
          });
        }
        await serverInstance.addParticipantsToChannel(channelId, [agentId]);
        logger12.info(`[Messages Router] Added agent ${agentId} to channel ${channelId}`);
        res.status(201).json({
          success: true,
          data: {
            channelId,
            agentId,
            message: "Agent added to channel successfully"
          }
        });
      } catch (error) {
        logger12.error(
          `[Messages Router] Error adding agent ${agentId} to channel ${channelId}:`,
          error
        );
        res.status(500).json({
          success: false,
          error: "Failed to add agent to channel",
          details: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  router.delete(
    "/central-channels/:channelId/agents/:agentId",
    async (req, res) => {
      const channelId = validateUuid12(req.params.channelId);
      const agentId = validateUuid12(req.params.agentId);
      if (!channelId || !agentId) {
        return res.status(400).json({
          success: false,
          error: "Invalid channelId or agentId format"
        });
      }
      try {
        const channel = await serverInstance.getChannelDetails(channelId);
        if (!channel) {
          return res.status(404).json({
            success: false,
            error: "Channel not found"
          });
        }
        const currentParticipants = await serverInstance.getChannelParticipants(channelId);
        if (!currentParticipants.includes(agentId)) {
          return res.status(404).json({
            success: false,
            error: "Agent is not a participant in this channel"
          });
        }
        const updatedParticipants = currentParticipants.filter((id) => id !== agentId);
        await serverInstance.updateChannel(channelId, {
          participantCentralUserIds: updatedParticipants
        });
        logger12.info(`[Messages Router] Removed agent ${agentId} from channel ${channelId}`);
        res.status(200).json({
          success: true,
          data: {
            channelId,
            agentId,
            message: "Agent removed from channel successfully"
          }
        });
      } catch (error) {
        logger12.error(
          `[Messages Router] Error removing agent ${agentId} from channel ${channelId}:`,
          error
        );
        res.status(500).json({
          success: false,
          error: "Failed to remove agent from channel",
          details: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  router.get(
    "/central-channels/:channelId/agents",
    async (req, res) => {
      const channelId = validateUuid12(req.params.channelId);
      if (!channelId) {
        return res.status(400).json({
          success: false,
          error: "Invalid channelId format"
        });
      }
      try {
        const allParticipants = await serverInstance.getChannelParticipants(channelId);
        res.json({
          success: true,
          data: {
            channelId,
            participants: allParticipants
            // All participants (agents and users)
            // TODO: Add agent-specific filtering when agent registry is available
          }
        });
      } catch (error) {
        logger12.error(`[Messages Router] Error fetching agents for channel ${channelId}:`, error);
        res.status(500).json({
          success: false,
          error: "Failed to fetch channel agents"
        });
      }
    }
  );
  router.delete(
    "/central-channels/:channelId/messages/:messageId",
    async (req, res) => {
      const channelId = validateUuid12(req.params.channelId);
      const messageId = validateUuid12(req.params.messageId);
      if (!channelId || !messageId) {
        return res.status(400).json({ success: false, error: "Invalid channelId or messageId" });
      }
      try {
        await serverInstance.deleteMessage(messageId);
        logger12.info(`[Messages Router] Deleted message ${messageId} from central database`);
        const deletedMessagePayload = {
          messageId,
          channelId
        };
        bus_default.emit("message_deleted", deletedMessagePayload);
        logger12.info(
          `[Messages Router] Emitted message_deleted event to internal bus for message ${messageId}`
        );
        if (serverInstance.socketIO) {
          serverInstance.socketIO.to(channelId).emit("messageDeleted", {
            messageId,
            channelId
          });
        }
        res.status(204).send();
      } catch (error) {
        logger12.error(
          `[Messages Router] Error deleting message ${messageId} from channel ${channelId}:`,
          error
        );
        res.status(500).json({ success: false, error: "Failed to delete message" });
      }
    }
  );
  router.delete(
    "/central-channels/:channelId/messages",
    async (req, res) => {
      const channelId = validateUuid12(req.params.channelId);
      if (!channelId) {
        return res.status(400).json({ success: false, error: "Invalid channelId" });
      }
      try {
        await serverInstance.clearChannelMessages(channelId);
        const channelClearedPayload = {
          channelId
        };
        bus_default.emit("channel_cleared", channelClearedPayload);
        logger12.info(
          `[Messages Router] Emitted channel_cleared event to internal bus for channel ${channelId}`
        );
        if (serverInstance.socketIO) {
          serverInstance.socketIO.to(channelId).emit("channelCleared", {
            channelId
          });
        }
        res.status(204).send();
      } catch (error) {
        logger12.error(`[Messages Router] Error clearing messages for channel ${channelId}:`, error);
        res.status(500).json({ success: false, error: "Failed to clear messages" });
      }
    }
  );
  router.patch(
    "/central-channels/:channelId",
    async (req, res) => {
      const channelId = validateUuid12(req.params.channelId);
      if (!channelId) {
        return res.status(400).json({ success: false, error: "Invalid channelId" });
      }
      const { name, participantCentralUserIds, metadata } = req.body;
      try {
        const updatedChannel = await serverInstance.updateChannel(channelId, {
          name,
          participantCentralUserIds,
          metadata
        });
        if (serverInstance.socketIO) {
          serverInstance.socketIO.to(channelId).emit("channelUpdated", {
            channelId,
            updates: updatedChannel
          });
        }
        res.json({ success: true, data: updatedChannel });
      } catch (error) {
        logger12.error(`[Messages Router] Error updating channel ${channelId}:`, error);
        res.status(500).json({ success: false, error: "Failed to update channel" });
      }
    }
  );
  router.delete(
    "/central-channels/:channelId",
    async (req, res) => {
      const channelId = validateUuid12(req.params.channelId);
      if (!channelId) {
        return res.status(400).json({ success: false, error: "Invalid channelId" });
      }
      try {
        const messages = await serverInstance.getMessagesForChannel(channelId);
        const messageCount = messages.length;
        await serverInstance.deleteChannel(channelId);
        logger12.info(
          `[Messages Router] Deleted channel ${channelId} with ${messageCount} messages from central database`
        );
        const channelClearedPayload = {
          channelId
        };
        bus_default.emit("channel_cleared", channelClearedPayload);
        logger12.info(
          `[Messages Router] Emitted channel_cleared event to internal bus for deleted channel ${channelId}`
        );
        if (serverInstance.socketIO) {
          serverInstance.socketIO.to(channelId).emit("channelDeleted", {
            channelId
          });
        }
        res.status(204).send();
      } catch (error) {
        logger12.error(`[Messages Router] Error deleting channel ${channelId}:`, error);
        res.status(500).json({ success: false, error: "Failed to delete channel" });
      }
    }
  );
  router.post(
    "/channels/:channelId/upload-media",
    createUploadRateLimit(),
    createFileSystemRateLimit(),
    channelUploadMiddleware.single("file"),
    async (req, res) => {
      const channelId = validateUuid12(req.params.channelId);
      if (!channelId) {
        res.status(400).json({ success: false, error: "Invalid channelId format" });
        return;
      }
      if (!req.file) {
        res.status(400).json({ success: false, error: "No media file provided" });
        return;
      }
      try {
        if (!req.file.originalname || req.file.originalname.includes("..") || req.file.originalname.includes("/")) {
          res.status(400).json({ success: false, error: "Invalid filename detected" });
          return;
        }
        const result = await saveChannelUploadedFile(req.file, channelId);
        logger12.info(
          `[MessagesRouter /upload-media] Secure file uploaded for channel ${channelId}: ${result.filename}. URL: ${result.url}`
        );
        res.json({
          success: true,
          data: {
            url: result.url,
            // Relative URL, client prepends server origin
            type: req.file.mimetype,
            filename: result.filename,
            originalName: req.file.originalname,
            size: req.file.size
          }
        });
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        logger12.error(
          `[MessagesRouter /upload-media] Error processing upload for channel ${channelId}: ${errorMessage}`,
          error
        );
        res.status(500).json({ success: false, error: "Failed to process media upload" });
      }
    }
  );
  router.post(
    "/central-channels/:channelId/generate-title",
    async (req, res) => {
      const channelId = validateUuid12(req.params.channelId);
      const { agentId } = req.body;
      if (!channelId) {
        return res.status(400).json({
          success: false,
          error: "Invalid channel ID format"
        });
      }
      if (!agentId || !validateUuid12(agentId)) {
        return res.status(400).json({
          success: false,
          error: "Valid agent ID is required"
        });
      }
      try {
        const runtime = agents.get(agentId);
        if (!runtime) {
          return res.status(404).json({
            success: false,
            error: "Agent not found or not active"
          });
        }
        logger12.info(`[CHANNEL SUMMARIZE] Summarizing channel ${channelId}`);
        const limit = req.query.limit ? Number.parseInt(req.query.limit, 10) : 50;
        const before = req.query.before ? Number.parseInt(req.query.before, 10) : void 0;
        const beforeDate = before ? new Date(before) : void 0;
        const messages = await serverInstance.getMessagesForChannel(channelId, limit, beforeDate);
        if (!messages || messages.length < 4) {
          return res.status(200).json({
            success: true,
            data: {
              title: null,
              channelId,
              reason: "Not enough messages to generate a title"
            }
          });
        }
        const recentMessages = messages.reverse().map((msg) => {
          const isUser = msg.authorId !== runtime.agentId;
          const role = isUser ? "User" : "Agent";
          return `${role}: ${msg.content}`;
        }).join("\n");
        const prompt = composePromptFromState({
          state: {
            recentMessages,
            values: {},
            data: {},
            text: recentMessages
          },
          template: `
Based on the conversation below, generate a short, descriptive title for this chat. The title should capture the main topic or theme of the discussion.
Rules:
- Keep it concise (3-6 words)
- Make it descriptive and specific
- Avoid generic terms like "Chat" or "Conversation"
- Focus on the main topic, activity, or subject matter
- Use natural language, not hashtags or symbols
Examples:
- "React Component Help"
- "Weekend Trip Planning"
- "Database Design Discussion"
- "Recipe Exchange"
- "Career Advice Session"
Recent conversation:
{{recentMessages}}
Respond with just the title, nothing else.
            `
        });
        const newTitle = await runtime.useModel(ModelType.TEXT_SMALL, {
          prompt,
          temperature: 0.3,
          // Use low temperature for consistent titles
          maxTokens: 50
          // Keep titles short
        });
        if (!newTitle || newTitle.trim().length === 0) {
          logger12.warn(`[ChatTitleEvaluator] Failed to generate title for room ${channelId}`);
          return;
        }
        const cleanTitle = newTitle.trim().replace(/^["']|["']$/g, "");
        logger12.info(`[ChatTitleEvaluator] Generated title: "${cleanTitle}" for room ${channelId}`);
        const result = {
          title: cleanTitle,
          channelId
        };
        logger12.success(`[CHANNEL SUMMARIZE] Successfully summarized channel ${channelId}`);
        res.json({
          success: true,
          data: result
        });
      } catch (error) {
        logger12.error("[CHANNEL SUMMARIZE] Error summarizing channel:", error);
        res.status(500).json({
          success: false,
          error: "Failed to summarize channel",
          details: error instanceof Error ? error.message : String(error)
        });
      }
    }
  );
  return router;
}

// src/api/messaging/index.ts
function messagingRouter(agents, serverInstance) {
  const router = express12.Router();
  if (!serverInstance) {
    throw new Error("ServerInstance is required for messaging router");
  }
  router.use("/", createMessagingCoreRouter(serverInstance));
  router.use("/", createServersRouter(serverInstance));
  router.use("/", createChannelsRouter(agents, serverInstance));
  return router;
}

// src/api/media/index.ts
import express15 from "express";

// src/api/media/agents.ts
import { validateUuid as validateUuid13, logger as logger13, getContentTypeFromMimeType } from "@elizaos/core";
import express13 from "express";
import multer2 from "multer";
import fs2 from "fs";
import path2 from "path";
var storage = multer2.memoryStorage();
var upload = multer2({
  storage,
  limits: {
    fileSize: MAX_FILE_SIZE,
    files: 1
  },
  fileFilter: (req, file, cb) => {
    if (ALLOWED_MEDIA_MIME_TYPES.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Invalid file type"), false);
    }
  }
});
async function saveUploadedFile(file, agentId) {
  const uploadDir = path2.join(process.cwd(), ".eliza/data/uploads/agents", agentId);
  if (!fs2.existsSync(uploadDir)) {
    fs2.mkdirSync(uploadDir, { recursive: true });
  }
  const timestamp = Date.now();
  const random = Math.round(Math.random() * 1e9);
  const ext = path2.extname(file.originalname);
  const filename = `${timestamp}-${random}${ext}`;
  const filePath = path2.join(uploadDir, filename);
  fs2.writeFileSync(filePath, file.buffer);
  const url = `/media/uploads/agents/${agentId}/${filename}`;
  return { filename, url };
}
function createAgentMediaRouter() {
  const router = express13.Router();
  router.post("/:agentId/upload-media", upload.single("file"), async (req, res) => {
    logger13.debug("[MEDIA UPLOAD] Processing media upload with multer");
    const agentId = validateUuid13(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    if (!req.file) {
      return sendError(res, 400, "INVALID_REQUEST", "No media file provided");
    }
    const mediaType = getContentTypeFromMimeType(req.file.mimetype);
    if (!mediaType) {
      return sendError(
        res,
        400,
        "UNSUPPORTED_MEDIA_TYPE",
        `Unsupported media MIME type: ${req.file.mimetype}`
      );
    }
    try {
      const result = await saveUploadedFile(req.file, agentId);
      logger13.info(
        `[MEDIA UPLOAD] Successfully uploaded ${mediaType}: ${result.filename}. URL: ${result.url}`
      );
      sendSuccess(res, {
        url: result.url,
        type: mediaType,
        filename: result.filename,
        originalName: req.file.originalname,
        size: req.file.size
      });
    } catch (error) {
      logger13.error(`[MEDIA UPLOAD] Error processing upload: ${error}`);
      sendError(
        res,
        500,
        "UPLOAD_ERROR",
        "Failed to process media upload",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  return router;
}

// src/api/media/channels.ts
import { validateUuid as validateUuid14, logger as logger14 } from "@elizaos/core";
import express14 from "express";
import rateLimit2 from "express-rate-limit";
import multer3 from "multer";
import fs3 from "fs";
import path3 from "path";
var storage2 = multer3.memoryStorage();
var upload2 = multer3({
  storage: storage2,
  limits: {
    fileSize: MAX_FILE_SIZE,
    files: 1
  },
  fileFilter: (req, file, cb) => {
    if (ALLOWED_MEDIA_MIME_TYPES.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Invalid file type"), false);
    }
  }
});
async function saveUploadedFile2(file, channelId) {
  const uploadDir = path3.join(process.cwd(), ".eliza/data/uploads/channels", channelId);
  if (!fs3.existsSync(uploadDir)) {
    fs3.mkdirSync(uploadDir, { recursive: true });
  }
  const timestamp = Date.now();
  const random = Math.round(Math.random() * 1e9);
  const ext = path3.extname(file.originalname);
  const filename = `${timestamp}-${random}${ext}`;
  const filePath = path3.join(uploadDir, filename);
  fs3.writeFileSync(filePath, file.buffer);
  const url = `/media/uploads/channels/${channelId}/${filename}`;
  return { filename, url };
}
function createChannelMediaRouter() {
  const router = express14.Router();
  const uploadMediaRateLimiter = rateLimit2({
    windowMs: 15 * 60 * 1e3,
    // 15 minutes
    max: 100,
    // Limit each IP to 100 requests per windowMs
    message: { success: false, error: "Too many requests, please try again later." }
  });
  router.post(
    "/:channelId/upload-media",
    uploadMediaRateLimiter,
    // Apply rate limiter
    upload2.single("file"),
    async (req, res) => {
      const channelId = validateUuid14(req.params.channelId);
      if (!channelId) {
        res.status(400).json({ success: false, error: "Invalid channelId format" });
        return;
      }
      if (!req.file) {
        res.status(400).json({ success: false, error: "No media file provided" });
        return;
      }
      try {
        const result = await saveUploadedFile2(req.file, channelId);
        logger14.info(
          `[Channel Media Upload] File uploaded for channel ${channelId}: ${result.filename}. URL: ${result.url}`
        );
        res.json({
          success: true,
          data: {
            url: result.url,
            // Relative URL, client prepends server origin
            type: req.file.mimetype,
            filename: result.filename,
            originalName: req.file.originalname,
            size: req.file.size
          }
        });
      } catch (error) {
        logger14.error(
          `[Channel Media Upload] Error processing upload for channel ${channelId}: ${error.message}`,
          error
        );
        res.status(500).json({ success: false, error: "Failed to process media upload" });
      }
    }
  );
  return router;
}

// src/api/media/index.ts
function mediaRouter() {
  const router = express15.Router();
  router.use("/agents", createAgentMediaRouter());
  router.use("/channels", createChannelMediaRouter());
  return router;
}

// src/api/memory/index.ts
import express17 from "express";

// src/api/memory/groups.ts
import { validateUuid as validateUuid16, logger as logger17, createUniqueUuid as createUniqueUuid4, ChannelType as ChannelType3 } from "@elizaos/core";
import express16 from "express";

// src/api/shared/file-utils.ts
import fs4 from "fs";
import path4 from "path";
import { logger as logger15 } from "@elizaos/core";
var cleanupUploadedFile = (file) => {
  logger15.debug(`[FILE] Multer file ${file.originalname} in memory, no cleanup needed`);
};

// src/upload.ts
import fs5 from "fs";
import path5 from "path";
import multer4 from "multer";
import { validateUuid as validateUuid15, logger as logger16 } from "@elizaos/core";
var storage3 = multer4.memoryStorage();
var agentAudioUpload = () => multer4({
  storage: storage3,
  limits: {
    fileSize: MAX_FILE_SIZE,
    files: 1
  },
  fileFilter: (req, file, cb) => {
    if (ALLOWED_AUDIO_MIME_TYPES.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Invalid audio file type"), false);
    }
  }
});
function validateAudioFile(file) {
  return ALLOWED_AUDIO_MIME_TYPES.includes(file.mimetype);
}

// src/api/memory/groups.ts
function createGroupMemoryRouter(agents, serverInstance) {
  const router = express16.Router();
  const db = serverInstance?.database;
  router.post("/groups/:serverId", async (req, res) => {
    const serverId = validateUuid16(req.params.serverId);
    const { name, worldId, source, metadata, agentIds = [] } = req.body;
    if (!Array.isArray(agentIds) || agentIds.length === 0) {
      return sendError(res, 400, "BAD_REQUEST", "agentIds must be a non-empty array");
    }
    let results = [];
    let errors = [];
    for (const agentId of agentIds) {
      try {
        const runtime = getRuntime(agents, agentId);
        const roomId = createUniqueUuid4(runtime, serverId);
        const roomName = name || `Chat ${(/* @__PURE__ */ new Date()).toLocaleString()}`;
        await runtime.ensureWorldExists({
          id: worldId,
          name: source,
          agentId: runtime.agentId,
          serverId
        });
        await runtime.ensureRoomExists({
          id: roomId,
          name: roomName,
          source,
          type: ChannelType3.API,
          worldId,
          serverId,
          metadata,
          channelId: roomId
        });
        await runtime.addParticipant(runtime.agentId, roomId);
        await runtime.ensureParticipantInRoom(runtime.agentId, roomId);
        await runtime.setParticipantUserState(roomId, runtime.agentId, "FOLLOWED");
        results.push({
          id: roomId,
          name: roomName,
          source: "client",
          worldId,
          type: ChannelType3.API
        });
      } catch (error) {
        logger17.error(`[ROOM CREATE] Error creating room for agent ${agentId}:`, error);
        errors.push({
          agentId,
          code: error instanceof Error && error.message === "Agent not found" ? "NOT_FOUND" : "CREATE_ERROR",
          message: error instanceof Error && error.message === "Agent not found" ? error.message : "Failed to Create group",
          details: error instanceof Error ? error.message : String(error)
        });
      }
    }
    if (results.length === 0 && errors.length > 0) {
      res.status(500).json({
        success: false,
        error: errors.length ? errors : [{ code: "UNKNOWN_ERROR", message: "No rooms were created" }]
      });
      return;
    }
    res.status(errors.length ? 207 : 201).json({
      success: errors.length === 0,
      data: results,
      errors: errors.length ? errors : void 0
    });
  });
  router.delete("/groups/:serverId", async (req, res) => {
    const worldId = validateUuid16(req.params.serverId);
    if (!worldId) {
      return sendError(res, 400, "INVALID_ID", "Invalid serverId (worldId) format");
    }
    if (!db) {
      return sendError(res, 500, "DB_ERROR", "Database not available");
    }
    try {
      await db.deleteRoomsByWorldId(worldId);
      res.status(204).send();
    } catch (error) {
      logger17.error("[GROUP DELETE] Error deleting group:", error);
      sendError(
        res,
        500,
        "DELETE_ERROR",
        "Error deleting group",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  router.delete("/groups/:serverId/memories", async (req, res) => {
    const worldId = validateUuid16(req.params.serverId);
    if (!worldId) {
      return sendError(res, 400, "INVALID_ID", "Invalid serverId (worldId) format");
    }
    if (!db) {
      return sendError(res, 500, "DB_ERROR", "Database not available");
    }
    try {
      const memories = await db.getMemoriesByWorldId({ worldId, tableName: "messages" });
      const memoryIds = memories.map((memory) => memory.id);
      if (memoryIds.length > 0) {
        await db.deleteManyMemories(memoryIds);
      }
      res.status(204).send();
    } catch (error) {
      logger17.error("[GROUP MEMORIES DELETE] Error clearing memories:", error);
      sendError(
        res,
        500,
        "DELETE_ERROR",
        "Error deleting group memories",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  return router;
}

// src/api/memory/index.ts
function memoryRouter(agents, serverInstance) {
  const router = express17.Router();
  router.use("/", createAgentMemoryRouter(agents));
  router.use("/", createGroupMemoryRouter(agents, serverInstance));
  router.use("/", createRoomManagementRouter(agents));
  return router;
}

// src/api/audio/index.ts
import express21 from "express";

// src/api/audio/processing.ts
import { logger as logger18, ModelType as ModelType2, validateUuid as validateUuid17 } from "@elizaos/core";
import express18 from "express";
import fs6 from "fs";
import os from "os";
import path6 from "path";
function createAudioProcessingRouter(agents) {
  const router = express18.Router();
  router.use(createUploadRateLimit());
  router.use(createFileSystemRateLimit());
  router.post("/:agentId/audio-messages", agentAudioUpload().single("file"), async (req, res) => {
    const audioReq = req;
    logger18.debug("[AUDIO MESSAGE] Processing audio message");
    const agentId = validateUuid17(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const audioFile = audioReq.file;
    if (!audioFile) {
      return sendError(res, 400, "INVALID_REQUEST", "No audio file provided");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      cleanupUploadedFile(audioFile);
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      if (!validateAudioFile(audioFile)) {
        cleanupUploadedFile(audioFile);
        return sendError(res, 400, "INVALID_FILE_TYPE", "Invalid audio file type");
      }
      if (audioFile.size > MAX_FILE_SIZE) {
        cleanupUploadedFile(audioFile);
        return sendError(
          res,
          413,
          "FILE_TOO_LARGE",
          `Audio file too large (max ${MAX_FILE_SIZE_DISPLAY})`
        );
      }
      const transcription = await runtime.useModel(ModelType2.TRANSCRIPTION, audioFile.buffer);
      logger18.info(`[AUDIO MESSAGE] Transcription for agent ${agentId}: ${transcription}`);
      cleanupUploadedFile(audioFile);
      sendSuccess(res, { transcription, message: "Audio transcribed, further processing TBD." });
    } catch (error) {
      logger18.error("[AUDIO MESSAGE] Error processing audio:", error);
      cleanupUploadedFile(audioFile);
      sendError(
        res,
        500,
        "PROCESSING_ERROR",
        "Error processing audio message",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  router.post("/:agentId/transcriptions", agentAudioUpload().single("file"), async (req, res) => {
    const audioReq = req;
    logger18.debug("[TRANSCRIPTION] Request to transcribe audio");
    const agentId = validateUuid17(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const audioFile = audioReq.file;
    if (!audioFile) {
      return sendError(res, 400, "INVALID_REQUEST", "No audio file provided");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      cleanupUploadedFile(audioFile);
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      logger18.debug("[TRANSCRIPTION] Reading audio file");
      if (!validateAudioFile(audioFile)) {
        cleanupUploadedFile(audioFile);
        return sendError(res, 400, "INVALID_FILE_TYPE", "Invalid audio file type");
      }
      if (audioFile.size > MAX_FILE_SIZE) {
        cleanupUploadedFile(audioFile);
        return sendError(
          res,
          413,
          "FILE_TOO_LARGE",
          `Audio file too large (max ${MAX_FILE_SIZE_DISPLAY})`
        );
      }
      logger18.debug("[TRANSCRIPTION] Transcribing audio");
      const transcription = await runtime.useModel(ModelType2.TRANSCRIPTION, audioFile.buffer);
      cleanupUploadedFile(audioFile);
      if (!transcription) {
        return sendError(res, 500, "PROCESSING_ERROR", "Failed to transcribe audio");
      }
      logger18.success("[TRANSCRIPTION] Successfully transcribed audio");
      sendSuccess(res, { text: transcription });
    } catch (error) {
      logger18.error("[TRANSCRIPTION] Error transcribing audio:", error);
      cleanupUploadedFile(audioFile);
      sendError(
        res,
        500,
        "PROCESSING_ERROR",
        "Error transcribing audio",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  return router;
}

// src/api/audio/synthesis.ts
import { validateUuid as validateUuid18, logger as logger19, ModelType as ModelType3 } from "@elizaos/core";
import express19 from "express";

// src/api/audio/audioBuffer.ts
import { Readable } from "stream";
function getAudioMimeType(audioBuffer) {
  if (audioBuffer.length >= 12 && audioBuffer.toString("ascii", 0, 4) === "RIFF" && audioBuffer.toString("ascii", 8, 12) === "WAVE") {
    return "audio/wav";
  }
  if (audioBuffer.length >= 3 && audioBuffer.toString("ascii", 0, 3) === "ID3") {
    return "audio/mpeg";
  }
  if (audioBuffer.length >= 2 && audioBuffer[0] === 255 && (audioBuffer[1] & 224) === 224) {
    return "audio/mpeg";
  }
  return "audio/mpeg";
}
async function convertToAudioBuffer(speechResponse, detectMimeType) {
  let resultBuffer;
  if (Buffer.isBuffer(speechResponse)) {
    resultBuffer = speechResponse;
  } else if (typeof speechResponse?.getReader === "function") {
    const reader = speechResponse.getReader();
    const chunks = [];
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        if (value) chunks.push(value);
      }
      resultBuffer = Buffer.concat(chunks);
    } finally {
      reader.releaseLock();
    }
  } else if (speechResponse instanceof Readable || speechResponse && speechResponse.readable === true && typeof speechResponse.pipe === "function" && typeof speechResponse.on === "function") {
    resultBuffer = await new Promise((resolve, reject) => {
      const chunks = [];
      speechResponse.on(
        "data",
        (chunk) => chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk))
      );
      speechResponse.on("end", () => resolve(Buffer.concat(chunks)));
      speechResponse.on("error", (err) => reject(err));
    });
  } else {
    throw new Error("Unexpected response type from TEXT_TO_SPEECH model");
  }
  if (detectMimeType) {
    return {
      buffer: resultBuffer,
      mimeType: getAudioMimeType(resultBuffer)
    };
  }
  return resultBuffer;
}

// src/api/audio/synthesis.ts
function createSynthesisRouter(agents) {
  const router = express19.Router();
  router.post("/:agentId/audio-messages/synthesize", async (req, res) => {
    const agentId = validateUuid18(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const { text } = req.body;
    if (!text) {
      return sendError(res, 400, "INVALID_REQUEST", "Text is required for speech synthesis");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const speechResponse = await runtime.useModel(ModelType3.TEXT_TO_SPEECH, text);
      const audioResult = await convertToAudioBuffer(speechResponse, true);
      logger19.debug("[TTS] Setting response headers");
      res.set({
        "Content-Type": audioResult.mimeType,
        "Content-Length": audioResult.buffer.length.toString()
      });
      res.send(audioResult.buffer);
    } catch (error) {
      logger19.error("[TTS] Error generating speech:", error);
      sendError(
        res,
        500,
        "PROCESSING_ERROR",
        "Error generating speech",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  router.post("/:agentId/speech/generate", async (req, res) => {
    logger19.debug("[SPEECH GENERATE] Request to generate speech from text");
    const agentId = validateUuid18(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const { text } = req.body;
    if (!text) {
      return sendError(res, 400, "INVALID_REQUEST", "Text is required for speech synthesis");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      logger19.debug("[SPEECH GENERATE] Using text-to-speech model");
      const speechResponse = await runtime.useModel(ModelType3.TEXT_TO_SPEECH, text);
      const audioResult = await convertToAudioBuffer(speechResponse, true);
      logger19.debug("[SPEECH GENERATE] Detected audio MIME type:", audioResult.mimeType);
      logger19.debug("[SPEECH GENERATE] Setting response headers");
      res.set({
        "Content-Type": audioResult.mimeType,
        "Content-Length": audioResult.buffer.length.toString()
      });
      res.send(audioResult.buffer);
      logger19.success(
        `[SPEECH GENERATE] Successfully generated speech for: ${runtime.character.name}`
      );
    } catch (error) {
      logger19.error("[SPEECH GENERATE] Error generating speech:", error);
      sendError(
        res,
        500,
        "PROCESSING_ERROR",
        "Error generating speech",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  return router;
}

// src/api/audio/conversation.ts
import {
  validateUuid as validateUuid19,
  logger as logger20,
  ModelType as ModelType4,
  ChannelType as ChannelType4,
  createUniqueUuid as createUniqueUuid5,
  composePrompt,
  messageHandlerTemplate
} from "@elizaos/core";
import express20 from "express";
function createConversationRouter(agents) {
  const router = express20.Router();
  router.post("/:agentId/speech/conversation", async (req, res) => {
    const agentId = validateUuid19(req.params.agentId);
    if (!agentId) {
      return sendError(res, 400, "INVALID_ID", "Invalid agent ID format");
    }
    const { text, roomId: rawRoomId, entityId: rawUserId, worldId: rawWorldId } = req.body;
    if (!text) {
      return sendError(res, 400, "INVALID_REQUEST", "Text is required for conversation");
    }
    const runtime = agents.get(agentId);
    if (!runtime) {
      return sendError(res, 404, "NOT_FOUND", "Agent not found");
    }
    try {
      const roomId = createUniqueUuid5(runtime, rawRoomId ?? `default-room-${agentId}`);
      const entityId = createUniqueUuid5(runtime, rawUserId ?? "Anon");
      const worldId = rawWorldId ?? createUniqueUuid5(runtime, "direct");
      logger20.debug("[SPEECH CONVERSATION] Ensuring connection");
      await runtime.ensureConnection({
        entityId,
        roomId,
        userName: req.body.userName,
        name: req.body.name,
        source: "direct",
        type: ChannelType4.API,
        worldId,
        worldName: "Direct"
      });
      const messageId = createUniqueUuid5(runtime, Date.now().toString());
      const content = {
        text,
        attachments: [],
        source: "direct",
        inReplyTo: void 0,
        channelType: ChannelType4.API
      };
      const userMessageMemory = {
        id: messageId,
        entityId,
        roomId,
        worldId,
        agentId: runtime.agentId,
        content,
        createdAt: Date.now()
      };
      logger20.debug("[SPEECH CONVERSATION] Creating memory");
      await runtime.createMemory(userMessageMemory, "messages");
      logger20.debug("[SPEECH CONVERSATION] Composing state");
      const state = await runtime.composeState(userMessageMemory);
      logger20.debug("[SPEECH CONVERSATION] Creating context");
      const prompt = composePrompt({
        state,
        template: messageHandlerTemplate
      });
      logger20.debug("[SPEECH CONVERSATION] Using LLM for response");
      const llmResponse = await runtime.useModel(ModelType4.TEXT_LARGE, {
        // Renamed to llmResponse
        messages: [
          {
            role: "system",
            content: messageHandlerTemplate
          },
          {
            role: "user",
            content: prompt
          }
        ]
      });
      if (!llmResponse) {
        return sendError(res, 500, "MODEL_ERROR", "No response from model");
      }
      logger20.debug("[SPEECH CONVERSATION] Creating response memory");
      const responseMessage = {
        // Explicitly type as Memory
        id: createUniqueUuid5(runtime, `resp-${messageId}`),
        // Ensure new ID for response
        entityId: runtime.agentId,
        // Agent is sender
        agentId: runtime.agentId,
        roomId,
        worldId,
        content: { text: llmResponse, inReplyTo: messageId },
        // Use llmResponse
        createdAt: Date.now()
      };
      await runtime.createMemory(responseMessage, "messages");
      await runtime.evaluate(userMessageMemory, state);
      await runtime.processActions(
        userMessageMemory,
        [responseMessage],
        state,
        async () => [userMessageMemory]
        // Callback should return relevant memories
      );
      logger20.debug("[SPEECH CONVERSATION] Generating speech response from LLM output");
      const speechAudioResponse = await runtime.useModel(ModelType4.TEXT_TO_SPEECH, llmResponse);
      const audioResult = await convertToAudioBuffer(speechAudioResponse, true);
      logger20.debug("[SPEECH CONVERSATION] Setting response headers");
      res.set({
        "Content-Type": audioResult.mimeType,
        "Content-Length": audioResult.buffer.length.toString()
      });
      res.send(audioResult.buffer);
      logger20.success(
        `[SPEECH CONVERSATION] Successfully processed conversation for: ${runtime.character.name}`
      );
    } catch (error) {
      logger20.error("[SPEECH CONVERSATION] Error processing conversation:", error);
      sendError(
        res,
        500,
        "PROCESSING_ERROR",
        "Error processing conversation",
        error instanceof Error ? error.message : String(error)
      );
    }
  });
  return router;
}

// src/api/audio/index.ts
function audioRouter(agents) {
  const router = express21.Router();
  router.use("/", createAudioProcessingRouter(agents));
  router.use("/", createSynthesisRouter(agents));
  router.use("/", createConversationRouter(agents));
  return router;
}

// src/api/runtime/index.ts
import express25 from "express";

// src/api/runtime/health.ts
import { logger as logger21 } from "@elizaos/core";
import express22 from "express";
function createHealthRouter(agents, serverInstance) {
  const router = express22.Router();
  router.get("/ping", (_req, res) => {
    res.json({ pong: true, timestamp: Date.now() });
  });
  router.get("/hello", (_req, res) => {
    logger21.info("Hello endpoint hit");
    res.setHeader("Content-Type", "application/json");
    res.send(JSON.stringify({ message: "Hello World!" }));
  });
  router.get("/status", (_req, res) => {
    logger21.info("Status endpoint hit");
    res.setHeader("Content-Type", "application/json");
    res.send(
      JSON.stringify({
        status: "ok",
        agentCount: agents.size,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      })
    );
  });
  router.get("/health", (_req, res) => {
    logger21.log({ apiRoute: "/health" }, "Health check route hit");
    const healthcheck = {
      status: "OK",
      version: process.env.APP_VERSION || "unknown",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      dependencies: {
        agents: agents.size > 0 ? "healthy" : "no_agents"
      }
    };
    const statusCode = healthcheck.dependencies.agents === "healthy" ? 200 : 503;
    res.status(statusCode).json(healthcheck);
  });
  router.post("/stop", (_req, res) => {
    logger21.log({ apiRoute: "/stop" }, "Server stopping...");
    serverInstance?.stop();
    res.json({ message: "Server stopping..." });
  });
  return router;
}

// src/api/runtime/logging.ts
import { logger as logger22 } from "@elizaos/core";
import express23 from "express";
var LOG_LEVELS = {
  fatal: 60,
  error: 50,
  warn: 40,
  info: 30,
  log: 29,
  progress: 28,
  success: 27,
  debug: 20,
  trace: 10
};
function createLoggingRouter() {
  const router = express23.Router();
  const logsHandler = async (req, res) => {
    const since = req.query.since ? Number(req.query.since) : Date.now() - 36e5;
    const requestedLevel = req.query.level?.toString().toLowerCase() || "all";
    const requestedAgentName = req.query.agentName?.toString() || "all";
    const requestedAgentId = req.query.agentId?.toString() || "all";
    const limit = Math.min(Number(req.query.limit) || 100, 1e3);
    const destination = logger22[Symbol.for("pino-destination")];
    if (!destination?.recentLogs) {
      return res.status(500).json({
        error: "Logger destination not available",
        message: "The logger is not configured to maintain recent logs"
      });
    }
    try {
      const recentLogs = destination.recentLogs();
      const requestedLevelValue = requestedLevel === "all" ? 0 : LOG_LEVELS[requestedLevel] || LOG_LEVELS.info;
      const logsWithAgentNames = recentLogs.filter((l) => l.agentName).length;
      const logsWithAgentIds = recentLogs.filter((l) => l.agentId).length;
      const totalLogs = recentLogs.length;
      const agentNamePopulationRate = totalLogs > 0 ? logsWithAgentNames / totalLogs : 0;
      const agentIdPopulationRate = totalLogs > 0 ? logsWithAgentIds / totalLogs : 0;
      const isAgentNameDataSparse = agentNamePopulationRate < 0.1;
      const isAgentIdDataSparse = agentIdPopulationRate < 0.1;
      const filtered = recentLogs.filter((log) => {
        const timeMatch = log.time >= since;
        let levelMatch = true;
        if (requestedLevel && requestedLevel !== "all") {
          levelMatch = log.level === requestedLevelValue;
        }
        let agentNameMatch = true;
        if (requestedAgentName && requestedAgentName !== "all") {
          if (log.agentName) {
            agentNameMatch = log.agentName === requestedAgentName;
          } else {
            agentNameMatch = isAgentNameDataSparse;
          }
        }
        let agentIdMatch = true;
        if (requestedAgentId && requestedAgentId !== "all") {
          if (log.agentId) {
            agentIdMatch = log.agentId === requestedAgentId;
          } else {
            agentIdMatch = isAgentIdDataSparse;
          }
        }
        return timeMatch && levelMatch && agentNameMatch && agentIdMatch;
      }).slice(-limit);
      logger22.debug("Logs request processed", {
        requestedLevel,
        requestedLevelValue,
        requestedAgentName,
        requestedAgentId,
        filteredCount: filtered.length,
        totalLogs: recentLogs.length,
        logsWithAgentNames,
        logsWithAgentIds,
        agentNamePopulationRate: Math.round(agentNamePopulationRate * 100) + "%",
        agentIdPopulationRate: Math.round(agentIdPopulationRate * 100) + "%",
        isAgentNameDataSparse,
        isAgentIdDataSparse,
        sampleLogAgentNames: recentLogs.slice(0, 5).map((log) => log.agentName),
        uniqueAgentNamesInLogs: [...new Set(recentLogs.map((log) => log.agentName))].filter(
          Boolean
        ),
        exactAgentNameMatches: recentLogs.filter((log) => log.agentName === requestedAgentName).length
      });
      res.json({
        logs: filtered,
        count: filtered.length,
        total: recentLogs.length,
        requestedLevel,
        agentName: requestedAgentName,
        agentId: requestedAgentId,
        levels: Object.keys(LOG_LEVELS)
      });
    } catch (error) {
      res.status(500).json({
        error: "Failed to retrieve logs",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  };
  router.get("/logs", logsHandler);
  router.post("/logs", logsHandler);
  const logsClearHandler = (_req, res) => {
    try {
      const destination = logger22[Symbol.for("pino-destination")];
      if (!destination?.clear) {
        return res.status(500).json({
          error: "Logger clear method not available",
          message: "The logger is not configured to clear logs"
        });
      }
      destination.clear();
      logger22.debug("Logs cleared via API endpoint");
      res.json({ status: "success", message: "Logs cleared successfully" });
    } catch (error) {
      res.status(500).json({
        error: "Failed to clear logs",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  };
  router.delete("/logs", logsClearHandler);
  return router;
}

// src/api/runtime/debug.ts
import express24 from "express";
function createDebugRouter(serverInstance) {
  const router = express24.Router();
  router.get("/servers", async (_req, res) => {
    try {
      const servers = await serverInstance?.getServers();
      res.json({
        success: true,
        servers: servers || [],
        count: servers?.length || 0
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  return router;
}

// src/api/runtime/index.ts
function runtimeRouter(agents, serverInstance) {
  const router = express25.Router();
  router.use("/", createHealthRouter(agents, serverInstance));
  router.use("/", createLoggingRouter(agents, serverInstance));
  router.use("/debug", createDebugRouter(serverInstance));
  return router;
}

// src/api/tee/index.ts
import express26 from "express";
function teeRouter() {
  const router = express26.Router();
  return router;
}

// src/api/system/index.ts
import express28 from "express";

// src/api/system/environment.ts
import { logger as logger23 } from "@elizaos/core";
import express27 from "express";
import { existsSync, writeFileSync } from "fs";
import path7 from "path";
import dotenv from "dotenv";
import fs7 from "fs/promises";
async function parseEnvFile(filePath) {
  try {
    if (!existsSync(filePath)) {
      return {};
    }
    const content = await fs7.readFile(filePath, "utf-8");
    if (content.trim() === "") {
      return {};
    }
    return dotenv.parse(content);
  } catch (error) {
    console.error(`Error parsing .env file: ${error.message}`);
    return {};
  }
}
function serializeEnvObject(envObj) {
  return Object.entries(envObj).map(([key, val]) => `${key}=${val ?? ""}`).join("\n\n");
}
function getLocalEnvPath() {
  const envPath = resolveEnvFile();
  return existsSync(envPath) ? envPath : null;
}
function resolveEnvFile(startDir = process.cwd()) {
  let currentDir = startDir;
  while (true) {
    const candidate = path7.join(currentDir, ".env");
    if (existsSync(candidate)) {
      return candidate;
    }
    const parentDir = path7.dirname(currentDir);
    if (parentDir === currentDir) {
      break;
    }
    currentDir = parentDir;
  }
  return path7.join(startDir, ".env");
}
function createEnvironmentRouter() {
  const router = express27.Router();
  router.get("/local", async (_req, res) => {
    try {
      const localEnvPath = getLocalEnvPath();
      if (!localEnvPath) {
        return res.json({
          success: true,
          data: {}
        });
      }
      const localEnvs = await parseEnvFile(localEnvPath);
      res.json({
        success: true,
        data: localEnvs
      });
    } catch (error) {
      logger23.error(`[ENVS GET] Error retrieving local envs`, error);
      res.status(500).json({
        success: false,
        error: {
          code: "FETCH_ERROR",
          message: "Failed to retrieve local envs",
          details: error instanceof Error ? error.message : String(error)
        }
      });
    }
  });
  router.post("/local", async (req, res) => {
    try {
      const { content } = req.body;
      if (!content || typeof content !== "object") {
        res.status(400).json({
          success: false,
          error: {
            code: "INVALID_INPUT",
            message: 'Missing or invalid "content" in request body'
          }
        });
      }
      const localEnvPath = getLocalEnvPath();
      if (!localEnvPath) throw new Error("Local .env file not found");
      const envString = serializeEnvObject(content);
      writeFileSync(localEnvPath, envString, "utf-8");
      res.json({
        success: true,
        message: "Local env updated"
      });
    } catch (error) {
      logger23.error(`[ENVS POST] Error updating local envs`, error);
      res.status(500).json({
        success: false,
        error: {
          code: "UPDATE_ERROR",
          message: "Failed to update local envs",
          details: error instanceof Error ? error.message : String(error)
        }
      });
    }
  });
  return router;
}

// src/api/system/index.ts
function systemRouter() {
  const router = express28.Router();
  router.use("/env", createEnvironmentRouter());
  return router;
}

// src/socketio/index.ts
import {
  logger as logger24,
  SOCKET_MESSAGE_TYPE,
  validateUuid as validateUuid20,
  ChannelType as ChannelType5,
  EventType
} from "@elizaos/core";
var DEFAULT_SERVER_ID4 = "00000000-0000-0000-0000-000000000000";
var SocketIORouter = class {
  agents;
  connections;
  // socket.id -> agentId (for agent-specific interactions like log streaming, if any)
  logStreamConnections;
  serverInstance;
  constructor(agents, serverInstance) {
    this.agents = agents;
    this.connections = /* @__PURE__ */ new Map();
    this.logStreamConnections = /* @__PURE__ */ new Map();
    this.serverInstance = serverInstance;
    logger24.info(`[SocketIO] Router initialized with ${this.agents.size} agents`);
  }
  setupListeners(io) {
    logger24.info(`[SocketIO] Setting up Socket.IO event listeners`);
    const messageTypes = Object.keys(SOCKET_MESSAGE_TYPE).map(
      (key) => `${key}: ${SOCKET_MESSAGE_TYPE[key]}`
    );
    logger24.info(`[SocketIO] Registered message types: ${messageTypes.join(", ")}`);
    io.on("connection", (socket) => {
      this.handleNewConnection(socket, io);
    });
  }
  handleNewConnection(socket, _io) {
    logger24.info(`[SocketIO] New connection: ${socket.id}`);
    socket.on(String(SOCKET_MESSAGE_TYPE.ROOM_JOINING), (payload) => {
      logger24.debug(
        `[SocketIO] Channel joining event received directly: ${JSON.stringify(payload)}`
      );
      this.handleChannelJoining(socket, payload);
    });
    socket.on(String(SOCKET_MESSAGE_TYPE.SEND_MESSAGE), (payload) => {
      const messagePreview = payload.message?.substring(0, 50) + (payload.message?.length > 50 ? "..." : "");
      const channelId = payload.channelId || payload.roomId;
      logger24.info(
        `[SocketIO] SEND_MESSAGE event received directly: ${JSON.stringify({
          senderId: payload.senderId,
          channelId,
          messagePreview
        })}`
      );
      this.handleMessageSubmission(socket, payload);
    });
    socket.on("message", (data) => {
      logger24.info(
        `[SocketIO] Generic 'message' event received: ${JSON.stringify(data)} (SocketID: ${socket.id})`
      );
      this.handleGenericMessage(socket, data);
    });
    socket.on("subscribe_logs", () => this.handleLogSubscription(socket));
    socket.on("unsubscribe_logs", () => this.handleLogUnsubscription(socket));
    socket.on("update_log_filters", (filters) => this.handleLogFilterUpdate(socket, filters));
    socket.on("disconnect", () => this.handleDisconnect(socket));
    socket.on("error", (error) => {
      logger24.error(`[SocketIO] Socket error for ${socket.id}: ${error.message}`, error);
    });
    if (process.env.NODE_ENV === "development") {
      socket.onAny((event, ...args) => {
        logger24.info(`[SocketIO DEBUG ${socket.id}] Event '${event}': ${JSON.stringify(args)}`);
      });
    }
    socket.emit("connection_established", {
      message: "Connected to Eliza Socket.IO server",
      socketId: socket.id
    });
  }
  handleGenericMessage(socket, data) {
    try {
      if (!(data && typeof data === "object" && "type" in data && "payload" in data)) {
        logger24.warn(
          `[SocketIO ${socket.id}] Malformed 'message' event data: ${JSON.stringify(data)}`
        );
        return;
      }
      const { type, payload } = data;
      switch (type) {
        case SOCKET_MESSAGE_TYPE.ROOM_JOINING:
          logger24.info(`[SocketIO ${socket.id}] Handling channel joining via 'message' event`);
          this.handleChannelJoining(socket, payload);
          break;
        case SOCKET_MESSAGE_TYPE.SEND_MESSAGE:
          logger24.info(`[SocketIO ${socket.id}] Handling message sending via 'message' event`);
          this.handleMessageSubmission(socket, payload);
          break;
        default:
          logger24.warn(
            `[SocketIO ${socket.id}] Unknown message type received in 'message' event: ${type}`
          );
          break;
      }
    } catch (error) {
      logger24.error(
        `[SocketIO ${socket.id}] Error processing 'message' event: ${error.message}`,
        error
      );
    }
  }
  handleChannelJoining(socket, payload) {
    const channelId = payload.channelId || payload.roomId;
    const { agentId, entityId, serverId, metadata } = payload;
    logger24.debug(
      `[SocketIO] handleChannelJoining called with payload:`,
      JSON.stringify(payload, null, 2)
    );
    if (!channelId) {
      this.sendErrorResponse(socket, `channelId is required for joining.`);
      return;
    }
    if (agentId) {
      const agentUuid = validateUuid20(agentId);
      if (agentUuid) {
        this.connections.set(socket.id, agentUuid);
        logger24.info(`[SocketIO] Socket ${socket.id} associated with agent ${agentUuid}`);
      }
    }
    socket.join(channelId);
    logger24.info(`[SocketIO] Socket ${socket.id} joined Socket.IO channel: ${channelId}`);
    if (entityId && (serverId || DEFAULT_SERVER_ID4)) {
      const finalServerId = serverId || DEFAULT_SERVER_ID4;
      const isDm = metadata?.isDm || metadata?.channelType === ChannelType5.DM;
      logger24.info(
        `[SocketIO] Emitting ENTITY_JOINED event for entityId: ${entityId}, serverId: ${finalServerId}, isDm: ${isDm}`
      );
      const runtime = Array.from(this.agents.values())[0];
      if (runtime) {
        runtime.emitEvent(EventType.ENTITY_JOINED, {
          entityId,
          runtime,
          worldId: finalServerId,
          // Use serverId as worldId identifier
          roomId: channelId,
          metadata: {
            type: isDm ? ChannelType5.DM : ChannelType5.GROUP,
            isDm,
            ...metadata
          },
          source: "socketio"
        });
        logger24.info(`[SocketIO] ENTITY_JOINED event emitted successfully for ${entityId}`);
      } else {
        logger24.warn(`[SocketIO] No runtime available to emit ENTITY_JOINED event`);
      }
    } else {
      logger24.debug(
        `[SocketIO] Missing entityId (${entityId}) or serverId (${serverId || DEFAULT_SERVER_ID4}) - not emitting ENTITY_JOINED event`
      );
    }
    const successMessage = `Socket ${socket.id} successfully joined channel ${channelId}.`;
    const responsePayload = {
      message: successMessage,
      channelId,
      roomId: channelId,
      // Keep for backward compatibility
      ...agentId && { agentId: validateUuid20(agentId) || agentId }
    };
    socket.emit("channel_joined", responsePayload);
    socket.emit("room_joined", responsePayload);
    logger24.info(`[SocketIO] ${successMessage}`);
  }
  async handleMessageSubmission(socket, payload) {
    const channelId = payload.channelId || payload.roomId;
    const { senderId, senderName, message, serverId, source, metadata, attachments } = payload;
    logger24.info(
      `[SocketIO ${socket.id}] Received SEND_MESSAGE for central submission: channel ${channelId} from ${senderName || senderId}`
    );
    logger24.info(
      `[SocketIO ${socket.id}] Full payload for debugging:`,
      JSON.stringify(payload, null, 2)
    );
    const isValidServerId = serverId === DEFAULT_SERVER_ID4 || validateUuid20(serverId);
    if (!validateUuid20(channelId) || !isValidServerId || !validateUuid20(senderId) || !message) {
      this.sendErrorResponse(
        socket,
        `For SEND_MESSAGE: channelId, serverId (server_id), senderId (author_id), and message are required.`
      );
      return;
    }
    try {
      const isDmForWorldSetup = metadata?.isDm || metadata?.channelType === ChannelType5.DM;
      if (isDmForWorldSetup && senderId) {
        logger24.info(
          `[SocketIO] Detected DM channel during message submission, emitting ENTITY_JOINED for proper world setup`
        );
        const runtime = Array.from(this.agents.values())[0];
        if (runtime) {
          runtime.emitEvent(EventType.ENTITY_JOINED, {
            entityId: senderId,
            runtime,
            worldId: serverId,
            // Use serverId as worldId identifier
            roomId: channelId,
            metadata: {
              type: ChannelType5.DM,
              isDm: true,
              ...metadata
            },
            source: "socketio_message"
          });
          logger24.info(`[SocketIO] ENTITY_JOINED event emitted for DM channel setup: ${senderId}`);
        }
      }
      logger24.info(
        `[SocketIO ${socket.id}] Checking if channel ${channelId} exists before creating message`
      );
      let channelExists = false;
      try {
        const existingChannel = await this.serverInstance.getChannelDetails(channelId);
        channelExists = !!existingChannel;
        logger24.info(`[SocketIO ${socket.id}] Channel ${channelId} exists: ${channelExists}`);
      } catch (error) {
        logger24.info(
          `[SocketIO ${socket.id}] Channel ${channelId} does not exist, will create it. Error: ${error.message}`
        );
      }
      if (!channelExists) {
        logger24.info(
          `[SocketIO ${socket.id}] Auto-creating channel ${channelId} with serverId ${serverId}`
        );
        try {
          const servers = await this.serverInstance.getServers();
          const serverExists = servers.some((s) => s.id === serverId);
          logger24.info(
            `[SocketIO ${socket.id}] Server ${serverId} exists: ${serverExists}. Available servers: ${servers.map((s) => s.id).join(", ")}`
          );
          if (!serverExists) {
            logger24.error(
              `[SocketIO ${socket.id}] Server ${serverId} does not exist, cannot create channel`
            );
            this.sendErrorResponse(socket, `Server ${serverId} does not exist`);
            return;
          }
          const isDmChannel = metadata?.isDm || metadata?.channelType === ChannelType5.DM || senderName?.includes("DM");
          const channelData = {
            id: channelId,
            // Use the specific channel ID from the client
            messageServerId: serverId,
            name: isDmChannel ? `DM ${channelId.substring(0, 8)}` : `Chat ${channelId.substring(0, 8)}`,
            type: isDmChannel ? ChannelType5.DM : ChannelType5.GROUP,
            sourceType: "auto_created",
            metadata: {
              created_by: "socketio_auto_creation",
              created_for_user: senderId,
              created_at: (/* @__PURE__ */ new Date()).toISOString(),
              channel_type: isDmChannel ? ChannelType5.DM : ChannelType5.GROUP,
              ...metadata
            }
          };
          logger24.info(
            `[SocketIO ${socket.id}] Creating channel with data:`,
            JSON.stringify(channelData, null, 2)
          );
          let participants = [senderId];
          if (isDmChannel) {
            const otherParticipant = metadata?.targetUserId || metadata?.recipientId || payload.targetUserId;
            if (otherParticipant && validateUuid20(otherParticipant)) {
              participants.push(otherParticipant);
              logger24.info(
                `[SocketIO ${socket.id}] DM channel will include participants: ${participants.join(", ")}`
              );
            } else {
              logger24.warn(
                `[SocketIO ${socket.id}] DM channel missing second participant, only adding sender: ${senderId}`
              );
            }
          }
          await this.serverInstance.createChannel(channelData, participants);
          logger24.info(
            `[SocketIO ${socket.id}] Auto-created ${isDmChannel ? ChannelType5.DM : ChannelType5.GROUP} channel ${channelId} for message submission with ${participants.length} participants`
          );
        } catch (createError) {
          logger24.error(
            `[SocketIO ${socket.id}] Failed to auto-create channel ${channelId}:`,
            createError
          );
          this.sendErrorResponse(socket, `Failed to create channel: ${createError.message}`);
          return;
        }
      } else {
        logger24.info(
          `[SocketIO ${socket.id}] Channel ${channelId} already exists, proceeding with message creation`
        );
      }
      const newRootMessageData = {
        channelId,
        authorId: senderId,
        content: message,
        rawMessage: payload,
        metadata: {
          ...metadata || {},
          user_display_name: senderName,
          socket_id: socket.id,
          serverId,
          attachments
        },
        sourceType: source || "socketio_client"
      };
      const createdRootMessage = await this.serverInstance.createMessage(newRootMessageData);
      logger24.info(
        `[SocketIO ${socket.id}] Message from ${senderId} (msgId: ${payload.messageId || "N/A"}) submitted to central store (central ID: ${createdRootMessage.id}). It will be processed by agents and broadcasted upon their reply.`
      );
      const messageBroadcast = {
        id: createdRootMessage.id,
        senderId,
        senderName: senderName || "User",
        text: message,
        channelId,
        roomId: channelId,
        // Keep for backward compatibility
        serverId,
        // Use serverId at message server layer
        createdAt: new Date(createdRootMessage.createdAt).getTime(),
        source: source || "socketio_client",
        attachments
      };
      socket.to(channelId).emit("messageBroadcast", messageBroadcast);
      socket.emit("messageBroadcast", {
        ...messageBroadcast,
        clientMessageId: payload.messageId
      });
      socket.emit("messageAck", {
        clientMessageId: payload.messageId,
        messageId: createdRootMessage.id,
        status: "received_by_server_and_processing",
        channelId,
        roomId: channelId
        // Keep for backward compatibility
      });
    } catch (error) {
      logger24.error(
        `[SocketIO ${socket.id}] Error during central submission for message: ${error.message}`,
        error
      );
      this.sendErrorResponse(socket, `[SocketIO] Error processing your message: ${error.message}`);
    }
  }
  sendErrorResponse(socket, errorMessage) {
    logger24.error(`[SocketIO ${socket.id}] Sending error to client: ${errorMessage}`);
    socket.emit("messageError", {
      error: errorMessage
    });
  }
  handleLogSubscription(socket) {
    this.logStreamConnections.set(socket.id, {});
    logger24.info(`[SocketIO ${socket.id}] Client subscribed to log stream`);
    socket.emit("log_subscription_confirmed", {
      subscribed: true,
      message: "Successfully subscribed to log stream"
    });
  }
  handleLogUnsubscription(socket) {
    this.logStreamConnections.delete(socket.id);
    logger24.info(`[SocketIO ${socket.id}] Client unsubscribed from log stream`);
    socket.emit("log_subscription_confirmed", {
      subscribed: false,
      message: "Successfully unsubscribed from log stream"
    });
  }
  handleLogFilterUpdate(socket, filters) {
    const existingFilters = this.logStreamConnections.get(socket.id);
    if (existingFilters !== void 0) {
      this.logStreamConnections.set(socket.id, { ...existingFilters, ...filters });
      logger24.info(`[SocketIO ${socket.id}] Updated log filters:`, filters);
      socket.emit("log_filters_updated", {
        success: true,
        filters: this.logStreamConnections.get(socket.id)
      });
    } else {
      logger24.warn(`[SocketIO ${socket.id}] Cannot update filters: not subscribed to log stream`);
      socket.emit("log_filters_updated", {
        success: false,
        error: "Not subscribed to log stream"
      });
    }
  }
  broadcastLog(io, logEntry) {
    if (this.logStreamConnections.size === 0) return;
    const logData = { type: "log_entry", payload: logEntry };
    this.logStreamConnections.forEach((filters, socketId) => {
      const socket = io.sockets.sockets.get(socketId);
      if (socket) {
        let shouldBroadcast = true;
        if (filters.agentName && filters.agentName !== "all") {
          shouldBroadcast = shouldBroadcast && logEntry.agentName === filters.agentName;
        }
        if (filters.level && filters.level !== "all") {
          const numericLevel = typeof filters.level === "string" ? logger24.levels.values[filters.level.toLowerCase()] || 70 : filters.level;
          shouldBroadcast = shouldBroadcast && logEntry.level >= numericLevel;
        }
        if (shouldBroadcast) {
          socket.emit("log_stream", logData);
        }
      }
    });
  }
  handleDisconnect(socket) {
    const agentIdAssociated = this.connections.get(socket.id);
    this.connections.delete(socket.id);
    this.logStreamConnections.delete(socket.id);
    if (agentIdAssociated) {
      logger24.info(
        `[SocketIO] Client ${socket.id} (associated with agent ${agentIdAssociated}) disconnected.`
      );
    } else {
      logger24.info(`[SocketIO] Client ${socket.id} disconnected.`);
    }
  }
};

// src/api/index.ts
function setupSocketIO(server, agents, serverInstance) {
  const io = new SocketIOServer(server, {
    cors: {
      origin: "*",
      methods: ["GET", "POST"]
    }
  });
  const centralSocketRouter = new SocketIORouter(agents, serverInstance);
  centralSocketRouter.setupListeners(io);
  setupLogStreaming(io, centralSocketRouter);
  return io;
}
function setupLogStreaming(io, router) {
  const loggerInstance = logger25;
  const destination = loggerInstance[Symbol.for("pino-destination")];
  if (destination && typeof destination.write === "function") {
    const originalWrite = destination.write.bind(destination);
    destination.write = function(data) {
      originalWrite(data);
      try {
        let logEntry;
        if (typeof data === "string") {
          logEntry = JSON.parse(data);
        } else {
          logEntry = data;
        }
        if (!logEntry.time) {
          logEntry.time = Date.now();
        }
        router.broadcastLog(io, logEntry);
      } catch (error) {
      }
    };
  }
}
function createPluginRouteHandler(agents) {
  return (req, res, next) => {
    logger25.debug("Handling plugin request in the plugin route handler", {
      path: req.path,
      method: req.method,
      query: req.query
    });
    const agentApiRoutePattern = /^\/agents\/[a-f0-9-]{36}\/(?!plugins\/)/i;
    if (agentApiRoutePattern.test(req.path)) {
      logger25.debug(`Skipping agent API route in plugin handler: ${req.path}`);
      return next();
    }
    if (req.path.startsWith("/api/messages/")) {
      return next();
    }
    if (req.path.endsWith(".js") || req.path.includes(".js?") || req.path.match(/index-[A-Za-z0-9]{8}\.js/)) {
      logger25.debug(`JavaScript request in plugin handler: ${req.method} ${req.path}`);
      res.setHeader("Content-Type", "application/javascript");
    }
    if (agents.size === 0) {
      logger25.debug("No agents available, skipping plugin route handling.");
      return next();
    }
    let handled = false;
    const agentIdFromQuery = req.query.agentId;
    const reqPath = req.path;
    if (agentIdFromQuery && validateUuid21(agentIdFromQuery)) {
      const runtime = agents.get(agentIdFromQuery);
      if (runtime) {
        logger25.debug(
          `Agent-scoped request for Agent ID: ${agentIdFromQuery} from query. Path: ${reqPath}`
        );
        for (const route of runtime.routes) {
          if (handled) break;
          const methodMatches = req.method.toLowerCase() === route.type.toLowerCase();
          if (!methodMatches) continue;
          const routePath = route.path.startsWith("/") ? route.path : `/${route.path}`;
          if (routePath.endsWith("/*")) {
            const baseRoute = routePath.slice(0, -1);
            if (reqPath.startsWith(baseRoute)) {
              logger25.debug(
                `Agent ${agentIdFromQuery} plugin wildcard route: [${route.type.toUpperCase()}] ${routePath} for request: ${reqPath}`
              );
              try {
                if (route.handler) {
                  route.handler(req, res, runtime);
                  handled = true;
                }
              } catch (error) {
                logger25.error(
                  `Error handling plugin wildcard route for agent ${agentIdFromQuery}: ${routePath}`,
                  {
                    error,
                    path: reqPath,
                    agent: agentIdFromQuery
                  }
                );
                if (!res.headersSent) {
                  const status = error instanceof Error && "code" in error && error.code === "ENOENT" || error instanceof Error && error.message?.includes("not found") ? 404 : 500;
                  res.status(status).json({
                    error: error instanceof Error ? error.message : "Error processing wildcard route"
                  });
                }
                handled = true;
              }
            }
          } else {
            logger25.debug(
              `Agent ${agentIdFromQuery} attempting plugin route match: [${route.type.toUpperCase()}] ${routePath} vs request path: ${reqPath}`
            );
            let matcher;
            try {
              matcher = match(routePath, { decode: decodeURIComponent });
            } catch (err) {
              logger25.error(
                `Invalid plugin route path syntax for agent ${agentIdFromQuery}: "${routePath}"`,
                err
              );
              continue;
            }
            const matched = matcher(reqPath);
            if (matched) {
              logger25.debug(
                `Agent ${agentIdFromQuery} plugin route matched: [${route.type.toUpperCase()}] ${routePath} vs request path: ${reqPath}`
              );
              req.params = { ...matched.params || {} };
              try {
                if (route.handler) {
                  route.handler(req, res, runtime);
                  handled = true;
                }
              } catch (error) {
                logger25.error(
                  `Error handling plugin route for agent ${agentIdFromQuery}: ${routePath}`,
                  {
                    error,
                    path: reqPath,
                    agent: agentIdFromQuery,
                    params: req.params
                  }
                );
                if (!res.headersSent) {
                  const status = error instanceof Error && "code" in error && error.code === "ENOENT" || error instanceof Error && error.message?.includes("not found") ? 404 : 500;
                  res.status(status).json({
                    error: error instanceof Error ? error.message : "Error processing route"
                  });
                }
                handled = true;
              }
            }
          }
        }
      } else {
        logger25.warn(
          `Agent ID ${agentIdFromQuery} provided in query, but agent runtime not found. Path: ${reqPath}.`
        );
        res.status(404).json({
          success: false,
          error: {
            message: "Agent not found",
            code: "AGENT_NOT_FOUND"
          }
        });
        return;
      }
    } else if (agentIdFromQuery && !validateUuid21(agentIdFromQuery)) {
      logger25.warn(`Invalid Agent ID format in query: ${agentIdFromQuery}. Path: ${reqPath}.`);
      res.status(400).json({
        success: false,
        error: {
          message: "Invalid agent ID format",
          code: "INVALID_AGENT_ID"
        }
      });
      return;
    } else {
      logger25.debug(`No valid agentId in query. Trying global match for path: ${reqPath}`);
      for (const [_, runtime] of agents) {
        if (handled) break;
        for (const route of runtime.routes) {
          if (handled) break;
          const methodMatches = req.method.toLowerCase() === route.type.toLowerCase();
          if (!methodMatches) continue;
          const routePath = route.path.startsWith("/") ? route.path : `/${route.path}`;
          if (routePath.includes(":")) {
            continue;
          }
          if (routePath.endsWith("/*")) {
            const baseRoute = routePath.slice(0, -1);
            if (reqPath.startsWith(baseRoute)) {
              logger25.debug(
                `Global plugin wildcard route: [${route.type.toUpperCase()}] ${routePath} (Agent: ${runtime.agentId}) for request: ${reqPath}`
              );
              try {
                route?.handler?.(req, res, runtime);
                handled = true;
              } catch (error) {
                logger25.error(
                  `Error handling global plugin wildcard route ${routePath} (Agent: ${runtime.agentId})`,
                  { error, path: reqPath }
                );
                if (!res.headersSent) {
                  const status = error instanceof Error && "code" in error && error.code === "ENOENT" || error instanceof Error && error.message?.includes("not found") ? 404 : 500;
                  res.status(status).json({
                    error: error instanceof Error ? error.message : "Error processing wildcard route"
                  });
                }
                handled = true;
              }
            }
          } else if (reqPath === routePath) {
            logger25.debug(
              `Global plugin route matched: [${route.type.toUpperCase()}] ${routePath} (Agent: ${runtime.agentId}) for request: ${reqPath}`
            );
            try {
              route?.handler?.(req, res, runtime);
              handled = true;
            } catch (error) {
              logger25.error(
                `Error handling global plugin route ${routePath} (Agent: ${runtime.agentId})`,
                { error, path: reqPath }
              );
              if (!res.headersSent) {
                const status = error instanceof Error && "code" in error && error.code === "ENOENT" || error instanceof Error && error.message?.includes("not found") ? 404 : 500;
                res.status(status).json({
                  error: error instanceof Error ? error.message : "Error processing route"
                });
              }
              handled = true;
            }
          }
        }
      }
    }
    if (handled) {
      return;
    }
    logger25.debug(`No plugin route handled ${req.method} ${req.path}, passing to next middleware.`);
    next();
  };
}
function createApiRouter(agents, serverInstance) {
  const router = express29.Router();
  router.use(
    helmet({
      // Disable CSP here - let main app handle it with environment awareness
      contentSecurityPolicy: false,
      // API-specific headers only
      crossOriginResourcePolicy: { policy: "cross-origin" },
      referrerPolicy: { policy: "no-referrer" }
    })
  );
  router.use(
    (0, import_cors.default)({
      origin: process.env.API_CORS_ORIGIN || process.env.CORS_ORIGIN || false,
      // More restrictive for API
      credentials: true,
      methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
      allowedHeaders: ["Content-Type", "Authorization", "X-API-KEY"],
      exposedHeaders: ["X-Total-Count"],
      maxAge: 86400
      // Cache preflight for 24 hours
    })
  );
  router.use(createApiRateLimit());
  router.use(securityMiddleware());
  router.use("/media", mediaRouter());
  router.use(validateContentTypeMiddleware());
  router.use(
    bodyParser.json({
      limit: process.env.EXPRESS_MAX_PAYLOAD || "100kb"
    })
  );
  router.use(
    bodyParser.urlencoded({
      extended: true,
      limit: process.env.EXPRESS_MAX_PAYLOAD || "100kb"
    })
  );
  router.use(
    express29.json({
      limit: process.env.EXPRESS_MAX_PAYLOAD || "100kb"
    })
  );
  router.use("/agents", agentsRouter(agents, serverInstance));
  router.use("/messaging", messagingRouter(agents, serverInstance));
  router.use("/memory", memoryRouter(agents, serverInstance));
  router.use("/audio", audioRouter(agents));
  router.use("/server", runtimeRouter(agents, serverInstance));
  router.use("/tee", teeRouter());
  router.use("/system", systemRouter());
  router.use(createPluginRouteHandler(agents));
  return router;
}

// src/authMiddleware.ts
import { logger as logger26 } from "@elizaos/core";
function apiKeyAuthMiddleware(req, res, next) {
  const serverAuthToken = process.env.ELIZA_SERVER_AUTH_TOKEN;
  if (!serverAuthToken) {
    return next();
  }
  if (req.method === "OPTIONS") {
    return next();
  }
  const apiKey = req.headers?.["x-api-key"];
  if (!apiKey || apiKey !== serverAuthToken) {
    logger26.warn(`Unauthorized access attempt: Missing or invalid X-API-KEY from ${req.ip}`);
    return res.status(401).send("Unauthorized: Invalid or missing X-API-KEY");
  }
  next();
}

// src/services/message.ts
import {
  ChannelType as ChannelType6,
  EventType as EventType2,
  Service,
  createUniqueUuid as createUniqueUuid6,
  logger as logger27,
  validateUuid as validateUuid22
} from "@elizaos/core";
var MessageBusService = class _MessageBusService extends Service {
  static serviceType = "message-bus-service";
  capabilityDescription = "Manages connection and message synchronization with the message server.";
  boundHandleIncomingMessage;
  boundHandleServerAgentUpdate;
  boundHandleMessageDeleted;
  boundHandleChannelCleared;
  subscribedServers = /* @__PURE__ */ new Set();
  constructor(runtime) {
    super(runtime);
    this.boundHandleIncomingMessage = this.handleIncomingMessage.bind(this);
    this.boundHandleServerAgentUpdate = this.handleServerAgentUpdate.bind(this);
    this.boundHandleMessageDeleted = this.handleMessageDeleted.bind(this);
    this.boundHandleChannelCleared = this.handleChannelCleared.bind(this);
  }
  static async start(runtime) {
    const service = new _MessageBusService(runtime);
    await service.connectToMessageBus();
    return service;
  }
  static async stop(runtime) {
    const service = new _MessageBusService(runtime);
    await service.stop();
  }
  async connectToMessageBus() {
    logger27.info(
      `[${this.runtime.character.name}] MessageBusService: Subscribing to internal message bus for 'new_message', 'message_deleted', and 'channel_cleared' events.`
    );
    bus_default.on("new_message", this.boundHandleIncomingMessage);
    bus_default.on("server_agent_update", this.boundHandleServerAgentUpdate);
    bus_default.on("message_deleted", this.boundHandleMessageDeleted);
    bus_default.on("channel_cleared", this.boundHandleChannelCleared);
    await this.fetchAgentServers();
    await this.fetchValidChannelIds();
  }
  validChannelIds = /* @__PURE__ */ new Set();
  async fetchValidChannelIds() {
    try {
      const serverApiUrl = this.getCentralMessageServerUrl();
      this.validChannelIds.clear();
      const DEFAULT_SERVER_ID6 = "00000000-0000-0000-0000-000000000000";
      const serversToCheck = new Set(this.subscribedServers);
      serversToCheck.add(DEFAULT_SERVER_ID6);
      for (const serverId of serversToCheck) {
        try {
          const channelsUrl = new URL(
            `/api/messaging/central-servers/${encodeURIComponent(serverId)}/channels`,
            serverApiUrl
          );
          const response = await fetch(channelsUrl.toString(), {
            headers: this.getAuthHeaders()
          });
          if (response.ok) {
            const data = await response.json();
            if (data.success && data.data?.channels && Array.isArray(data.data.channels)) {
              data.data.channels.forEach((channel) => {
                if (channel.id && validateUuid22(channel.id)) {
                  this.validChannelIds.add(channel.id);
                }
              });
              logger27.info(
                `[${this.runtime.character.name}] MessageBusService: Fetched ${data.data.channels.length} channels from server ${serverId}`
              );
            }
          } else {
            logger27.warn(
              `[${this.runtime.character.name}] MessageBusService: Failed to fetch channels for server ${serverId}: ${response.status} ${response.statusText}`
            );
          }
        } catch (serverError) {
          logger27.error(
            `[${this.runtime.character.name}] MessageBusService: Error fetching channels for server ${serverId}:`,
            serverError
          );
        }
      }
      logger27.info(
        `[${this.runtime.character.name}] MessageBusService: Loaded ${this.validChannelIds.size} valid channel IDs from ${serversToCheck.size} servers (including default server)`
      );
    } catch (error) {
      logger27.error(
        `[${this.runtime.character.name}] MessageBusService: Error in fetchValidChannelIds:`,
        error
      );
    }
  }
  async getChannelParticipants(channelId) {
    try {
      const serverApiUrl = this.getCentralMessageServerUrl();
      if (!validateUuid22(channelId)) {
        logger27.warn(
          `[${this.runtime.character.name}] MessageBusService: Invalid channel ID format: ${channelId}`
        );
        return [];
      }
      if (!this.validChannelIds.has(channelId)) {
        const detailsUrl = new URL(
          `/api/messaging/central-channels/${encodeURIComponent(channelId)}/details`,
          serverApiUrl
        );
        const detailsResponse = await fetch(detailsUrl.toString(), {
          headers: this.getAuthHeaders()
        });
        if (detailsResponse.ok) {
          this.validChannelIds.add(channelId);
          logger27.info(
            `[${this.runtime.character.name}] MessageBusService: Discovered new channel ${channelId}, added to valid channels`
          );
        } else {
          logger27.warn(
            `[${this.runtime.character.name}] MessageBusService: Channel ${channelId} does not exist or is not accessible`
          );
          return [];
        }
      }
      const participantsUrl = new URL(
        `/api/messaging/central-channels/${encodeURIComponent(channelId)}/participants`,
        serverApiUrl
      );
      const response = await fetch(participantsUrl.toString(), {
        headers: this.getAuthHeaders()
      });
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.data) {
          return data.data;
        }
      }
      return [];
    } catch (error) {
      logger27.error(
        `[${this.runtime.character.name}] MessageBusService: Error fetching participants for channel ${channelId}:`,
        error
      );
      return [];
    }
  }
  async fetchAgentServers() {
    try {
      const serverApiUrl = this.getCentralMessageServerUrl();
      const agentServersUrl = new URL(
        `/api/messaging/agents/${encodeURIComponent(this.runtime.agentId)}/servers`,
        serverApiUrl
      );
      const response = await fetch(agentServersUrl.toString(), {
        headers: this.getAuthHeaders()
      });
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.data?.servers) {
          this.subscribedServers = new Set(data.data.servers);
          const DEFAULT_SERVER_ID6 = "00000000-0000-0000-0000-000000000000";
          this.subscribedServers.add(DEFAULT_SERVER_ID6);
          logger27.info(
            `[${this.runtime.character.name}] MessageBusService: Agent is subscribed to ${this.subscribedServers.size} servers (including default server)`
          );
        }
      } else {
        const DEFAULT_SERVER_ID6 = "00000000-0000-0000-0000-000000000000";
        this.subscribedServers.add(DEFAULT_SERVER_ID6);
        logger27.warn(
          `[${this.runtime.character.name}] MessageBusService: Failed to fetch agent servers, but added default server`
        );
      }
    } catch (error) {
      logger27.error(
        `[${this.runtime.character.name}] MessageBusService: Error fetching agent servers:`,
        error
      );
      const DEFAULT_SERVER_ID6 = "00000000-0000-0000-0000-000000000000";
      this.subscribedServers.add(DEFAULT_SERVER_ID6);
      logger27.info(
        `[${this.runtime.character.name}] MessageBusService: Added default server after error`
      );
    }
  }
  async handleServerAgentUpdate(data) {
    if (data.agentId !== this.runtime.agentId) {
      return;
    }
    if (data.type === "agent_added_to_server") {
      this.subscribedServers.add(data.serverId);
      logger27.info(
        `[${this.runtime.character.name}] MessageBusService: Agent added to server ${data.serverId}`
      );
      await this.fetchValidChannelIds();
    } else if (data.type === "agent_removed_from_server") {
      this.subscribedServers.delete(data.serverId);
      logger27.info(
        `[${this.runtime.character.name}] MessageBusService: Agent removed from server ${data.serverId}`
      );
      await this.fetchValidChannelIds();
    }
  }
  async validateServerSubscription(message) {
    if (!this.subscribedServers.has(message.server_id)) {
      logger27.debug(
        `[${this.runtime.character.name}] MessageBusService: Agent not subscribed to server ${message.server_id}, ignoring message`
      );
      return false;
    }
    logger27.info(
      `[${this.runtime.character.name}] MessageBusService: Passed server subscription check for ${message.server_id}`
    );
    return true;
  }
  async validateNotSelfMessage(message) {
    if (message.author_id === this.runtime.agentId) {
      logger27.debug(
        `[${this.runtime.character.name}] MessageBusService: Agent is the author of the message, ignoring message`
      );
      return false;
    }
    return true;
  }
  async ensureWorldAndRoomExist(message) {
    const agentWorldId = createUniqueUuid6(this.runtime, message.server_id);
    const agentRoomId = createUniqueUuid6(this.runtime, message.channel_id);
    try {
      await this.runtime.ensureWorldExists({
        id: agentWorldId,
        name: message.metadata?.serverName || `Server ${message.server_id.substring(0, 8)}`,
        agentId: this.runtime.agentId,
        serverId: message.server_id,
        metadata: {
          ...message.metadata?.serverMetadata || {}
        }
      });
    } catch (error) {
      if (error.message && error.message.includes("worlds_pkey")) {
        logger27.debug(
          `[${this.runtime.character.name}] MessageBusService: World ${agentWorldId} already exists, continuing with message processing`
        );
      } else {
        throw error;
      }
    }
    try {
      await this.runtime.ensureRoomExists({
        id: agentRoomId,
        name: message.metadata?.channelName || `Channel ${message.channel_id.substring(0, 8)}`,
        agentId: this.runtime.agentId,
        worldId: agentWorldId,
        channelId: message.channel_id,
        serverId: message.server_id,
        source: message.source_type || "central-bus",
        type: message.metadata?.channelType || ChannelType6.GROUP,
        metadata: {
          ...message.metadata?.channelMetadata || {}
        }
      });
    } catch (error) {
      if (error.message && error.message.includes("rooms_pkey")) {
        logger27.debug(
          `[${this.runtime.character.name}] MessageBusService: Room ${agentRoomId} already exists, continuing with message processing`
        );
      } else {
        throw error;
      }
    }
    return { agentWorldId, agentRoomId };
  }
  async ensureAuthorEntityExists(message) {
    const agentAuthorEntityId = createUniqueUuid6(this.runtime, message.author_id);
    const authorEntity = await this.runtime.getEntityById(agentAuthorEntityId);
    if (!authorEntity) {
      await this.runtime.createEntity({
        id: agentAuthorEntityId,
        names: [message.author_display_name || `User-${message.author_id.substring(0, 8)}`],
        agentId: this.runtime.agentId,
        metadata: {
          author_id: message.author_id,
          source: message.source_type
        }
      });
    }
    return agentAuthorEntityId;
  }
  createAgentMemory(message, agentAuthorEntityId, agentRoomId, agentWorldId) {
    const messageContent = {
      text: message.content,
      source: message.source_type || "central-bus",
      attachments: message.metadata?.attachments,
      inReplyTo: message.in_reply_to_message_id ? createUniqueUuid6(this.runtime, message.in_reply_to_message_id) : void 0
    };
    return {
      id: createUniqueUuid6(this.runtime, message.id),
      entityId: agentAuthorEntityId,
      agentId: this.runtime.agentId,
      roomId: agentRoomId,
      worldId: agentWorldId,
      content: messageContent,
      createdAt: message.created_at,
      metadata: {
        type: "message",
        source: message.source_type || "central-bus",
        sourceId: message.id,
        raw: {
          ...message.raw_message,
          senderName: message.author_display_name || `User-${message.author_id.substring(0, 8)}`,
          senderId: message.author_id
        }
      }
    };
  }
  async handleIncomingMessage(message) {
    logger27.info(
      `[${this.runtime.character.name}] MessageBusService: Received message from central bus`,
      { messageId: message.id }
    );
    const participants = await this.getChannelParticipants(message.channel_id);
    if (!participants.includes(this.runtime.agentId)) {
      logger27.info(
        `[${this.runtime.character.name}] MessageBusService: Agent not a participant in channel ${message.channel_id}, ignoring message`
      );
      return;
    }
    logger27.info(
      `[${this.runtime.character.name} - ${this.runtime.agentId}] MessageBusService: Agent is a participant in channel ${message.channel_id}, proceeding with message processing`
    );
    try {
      if (!await this.validateServerSubscription(message)) return;
      if (!await this.validateNotSelfMessage(message)) return;
      logger27.info(
        `[${this.runtime.character.name}] MessageBusService: All checks passed, proceeding to create agent memory and emit MESSAGE_RECEIVED event`
      );
      const { agentWorldId, agentRoomId } = await this.ensureWorldAndRoomExist(message);
      const agentAuthorEntityId = await this.ensureAuthorEntityExists(message);
      const agentMemory = this.createAgentMemory(
        message,
        agentAuthorEntityId,
        agentRoomId,
        agentWorldId
      );
      const existingMemory = await this.runtime.getMemoryById(agentMemory.id);
      if (existingMemory) {
        logger27.debug(
          `[${this.runtime.character.name}] MessageBusService: Memory ${agentMemory.id} already exists, skipping duplicate processing`
        );
        return;
      }
      const callbackForCentralBus = async (responseContent) => {
        logger27.info(
          `[${this.runtime.character.name}] Agent generated response for message. Preparing to send back to bus.`
        );
        await this.runtime.createMemory(
          {
            entityId: this.runtime.agentId,
            content: responseContent,
            roomId: agentRoomId,
            worldId: agentWorldId,
            agentId: this.runtime.agentId
          },
          "messages"
        );
        await this.sendAgentResponseToBus(
          agentRoomId,
          agentWorldId,
          responseContent,
          agentMemory.id,
          message
        );
        return [];
      };
      await this.runtime.emitEvent(EventType2.MESSAGE_RECEIVED, {
        runtime: this.runtime,
        message: agentMemory,
        callback: callbackForCentralBus,
        onComplete: async () => {
          const room = await this.runtime.getRoom(agentRoomId);
          const world = await this.runtime.getWorld(agentWorldId);
          const channelId = room?.channelId;
          const serverId = world?.serverId;
          await this.notifyMessageComplete(channelId, serverId);
        }
      });
    } catch (error) {
      logger27.error(
        `[${this.runtime.character.name}] MessageBusService: Error processing incoming message:`,
        error
      );
    }
  }
  async handleMessageDeleted(data) {
    try {
      logger27.info(
        `[${this.runtime.character.name}] MessageBusService: Received message_deleted event for message ${data.messageId}`
      );
      const agentMemoryId = createUniqueUuid6(this.runtime, data.messageId);
      const existingMemory = await this.runtime.getMemoryById(agentMemoryId);
      if (existingMemory) {
        await this.runtime.emitEvent(EventType2.MESSAGE_DELETED, {
          runtime: this.runtime,
          message: existingMemory,
          source: "message-bus-service"
        });
        logger27.debug(
          `[${this.runtime.character.name}] MessageBusService: Successfully processed message deletion for ${data.messageId}`
        );
      } else {
        logger27.warn(
          `[${this.runtime.character.name}] MessageBusService: No memory found for deleted message ${data.messageId}`
        );
      }
    } catch (error) {
      logger27.error(
        `[${this.runtime.character.name}] MessageBusService: Error handling message deletion:`,
        error
      );
    }
  }
  async handleChannelCleared(data) {
    try {
      logger27.info(
        `[${this.runtime.character.name}] MessageBusService: Received channel_cleared event for channel ${data.channelId}`
      );
      const agentRoomId = createUniqueUuid6(this.runtime, data.channelId);
      const memories = await this.runtime.getMemoriesByRoomIds({
        tableName: "messages",
        roomIds: [agentRoomId]
      });
      logger27.info(
        `[${this.runtime.character.name}] MessageBusService: Found ${memories.length} memories to delete for channel ${data.channelId}`
      );
      await this.runtime.emitEvent(EventType2.CHANNEL_CLEARED, {
        runtime: this.runtime,
        source: "message-bus-service",
        roomId: agentRoomId,
        channelId: data.channelId,
        memoryCount: memories.length
      });
      logger27.info(
        `[${this.runtime.character.name}] MessageBusService: Successfully processed channel clear for ${data.channelId} -> room ${agentRoomId}`
      );
    } catch (error) {
      logger27.error(
        `[${this.runtime.character.name}] MessageBusService: Error handling channel clear:`,
        error
      );
    }
  }
  async sendAgentResponseToBus(agentRoomId, agentWorldId, content, inReplyToAgentMemoryId, originalMessage) {
    try {
      const room = await this.runtime.getRoom(agentRoomId);
      const world = await this.runtime.getWorld(agentWorldId);
      const channelId = room?.channelId;
      const serverId = world?.serverId;
      if (!channelId || !serverId) {
        logger27.error(
          `[${this.runtime.character.name}] MessageBusService: Cannot map agent room/world to central IDs for response. AgentRoomID: ${agentRoomId}, AgentWorldID: ${agentWorldId}. Room or World object missing, or channelId/serverId not found on them.`
        );
        return;
      }
      const shouldSkip = content.actions?.includes("IGNORE") || !content.text || content.text.trim() === "";
      if (shouldSkip) {
        logger27.info(
          `[${this.runtime.character.name}] MessageBusService: Skipping response (reason: ${content.actions?.includes("IGNORE") ? "IGNORE action" : "No text"})`
        );
        return;
      }
      let centralInReplyToRootMessageId = void 0;
      if (inReplyToAgentMemoryId) {
        const originalAgentMemory = await this.runtime.getMemoryById(inReplyToAgentMemoryId);
        if (originalAgentMemory?.metadata?.sourceId) {
          centralInReplyToRootMessageId = originalAgentMemory.metadata.sourceId;
        }
      }
      const payloadToServer = {
        channel_id: channelId,
        server_id: serverId,
        author_id: this.runtime.agentId,
        // This needs careful consideration: is it the agent's core ID or a specific central identity for the agent?
        content: content.text,
        in_reply_to_message_id: centralInReplyToRootMessageId,
        source_type: "agent_response",
        raw_message: {
          text: content.text,
          thought: content.thought,
          actions: content.actions
        },
        metadata: {
          agent_id: this.runtime.agentId,
          agentName: this.runtime.character.name,
          attachments: content.attachments,
          channelType: originalMessage?.metadata?.channelType || room?.type,
          isDm: originalMessage?.metadata?.isDm || (originalMessage?.metadata?.channelType || room?.type) === ChannelType6.DM
        }
      };
      logger27.info(
        `[${this.runtime.character.name}] MessageBusService: Sending payload to central server API endpoint (/api/messaging/submit):`,
        payloadToServer
      );
      const baseUrl = this.getCentralMessageServerUrl();
      const submitUrl = new URL("/api/messaging/submit", baseUrl);
      const serverApiUrl = submitUrl.toString();
      const response = await fetch(serverApiUrl, {
        method: "POST",
        headers: this.getAuthHeaders(),
        body: JSON.stringify(payloadToServer)
      });
      if (!response.ok) {
        logger27.error(
          `[${this.runtime.character.name}] MessageBusService: Error sending response to central server: ${response.status} ${await response.text()}`
        );
      }
    } catch (error) {
      logger27.error(
        `[${this.runtime.character.name}] MessageBusService: Error sending agent response to bus:`,
        error
      );
    }
  }
  async notifyMessageComplete(channelId, serverId) {
    if (!channelId || !serverId) return;
    try {
      const completeUrl = new URL("/api/messaging/complete", this.getCentralMessageServerUrl());
      await fetch(completeUrl.toString(), {
        method: "POST",
        headers: this.getAuthHeaders(),
        body: JSON.stringify({ channel_id: channelId, server_id: serverId })
      });
    } catch (error) {
      logger27.warn(
        `[${this.runtime.character.name}] MessageBusService: Failed to notify completion`,
        error
      );
    }
  }
  getAuthHeaders() {
    const headers = {
      "Content-Type": "application/json"
    };
    const serverAuthToken = process.env.ELIZA_SERVER_AUTH_TOKEN;
    if (serverAuthToken) {
      headers["X-API-KEY"] = serverAuthToken;
    }
    return headers;
  }
  getCentralMessageServerUrl() {
    const serverPort = process.env.SERVER_PORT;
    const envUrl = process.env.CENTRAL_MESSAGE_SERVER_URL;
    let validatedPort = null;
    if (serverPort) {
      const portNum = parseInt(serverPort, 10);
      if (!isNaN(portNum) && portNum > 0 && portNum <= 65535) {
        validatedPort = portNum;
      } else {
        logger27.warn(`[MessageBusService] Invalid SERVER_PORT value: ${serverPort}`);
      }
    }
    const defaultUrl = validatedPort ? `http://localhost:${validatedPort}` : "http://localhost:3000";
    const baseUrl = envUrl ?? defaultUrl;
    try {
      const url = new URL(baseUrl);
      if (!["http:", "https:"].includes(url.protocol)) {
        logger27.warn(
          `[MessageBusService] Unsafe protocol in CENTRAL_MESSAGE_SERVER_URL: ${url.protocol}`
        );
        return defaultUrl;
      }
      const allowedHosts = ["localhost", "127.0.0.1", "::1"];
      if (!allowedHosts.includes(url.hostname)) {
        logger27.warn(
          `[MessageBusService] Unsafe hostname in CENTRAL_MESSAGE_SERVER_URL: ${url.hostname}`
        );
        return defaultUrl;
      }
      if (url.port) {
        const portNum = parseInt(url.port, 10);
        if (isNaN(portNum) || portNum <= 0 || portNum > 65535) {
          logger27.warn(
            `[MessageBusService] Invalid port in CENTRAL_MESSAGE_SERVER_URL: ${url.port}`
          );
          return defaultUrl;
        }
      }
      url.username = "";
      url.password = "";
      url.hash = "";
      return url.toString().replace(/\/$/, "");
    } catch (error) {
      logger27.error(
        `[MessageBusService] Invalid URL format in CENTRAL_MESSAGE_SERVER_URL: ${baseUrl}`
      );
      return defaultUrl;
    }
  }
  async stop() {
    logger27.info(`[${this.runtime.character.name}] MessageBusService stopping...`);
    bus_default.off("new_message", this.boundHandleIncomingMessage);
    bus_default.off("server_agent_update", this.boundHandleServerAgentUpdate);
    bus_default.off("message_deleted", this.boundHandleMessageDeleted);
    bus_default.off("channel_cleared", this.boundHandleChannelCleared);
  }
};
var messageBusConnectorPlugin = {
  name: "internal-message-bus-connector",
  description: "Internal service to connect agent to the message bus.",
  services: [MessageBusService]
};

// src/loader.ts
import fs8 from "fs";
import path8 from "path";
import { fileURLToPath } from "url";
import {
  logger as logger28,
  parseAndValidateCharacter,
  validateCharacter
} from "@elizaos/core";
var __filename = fileURLToPath(import.meta.url);
var __dirname = path8.dirname(__filename);
function tryLoadFile(filePath) {
  try {
    return fs8.readFileSync(filePath, "utf8");
  } catch (e) {
    throw new Error(`Error loading file ${filePath}: ${e}`);
  }
}
async function loadCharactersFromUrl(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}: ${response.statusText}`);
    }
    const responseJson = await response.json();
    let characters = [];
    if (Array.isArray(responseJson)) {
      characters = await Promise.all(responseJson.map((character) => jsonToCharacter(character)));
    } else {
      const character = await jsonToCharacter(responseJson);
      characters.push(character);
    }
    return characters;
  } catch (e) {
    const errorMsg = e instanceof Error ? e.message : String(e);
    logger28.error(`Error loading character(s) from ${url}: ${errorMsg}`);
    if (errorMsg.includes("Character validation failed") || errorMsg.includes("validation")) {
      throw new Error(
        `Invalid character data from URL '${url}'. The character data does not match the required schema: ${errorMsg}`
      );
    } else if (errorMsg.includes("JSON")) {
      throw new Error(
        `Invalid JSON response from URL '${url}'. The resource may not contain valid character data.`
      );
    } else if (e instanceof TypeError) {
      throw new Error(
        `Failed to fetch character from URL '${url}'. The URL may be incorrect or unavailable.`
      );
    } else {
      throw new Error(`Failed to load character from URL '${url}': ${errorMsg}`);
    }
  }
}
async function jsonToCharacter(character) {
  const validationResult = validateCharacter(character);
  if (!validationResult.success) {
    const errorDetails = validationResult.error?.issues ? validationResult.error.issues.map((issue) => `${issue.path.join(".")}: ${issue.message}`).join("; ") : validationResult.error?.message || "Unknown validation error";
    throw new Error(`Character validation failed: ${errorDetails}`);
  }
  if (!validationResult.data) {
    throw new Error("Validation succeeded but no data was returned");
  }
  const validatedCharacter = validationResult.data;
  const characterId = validatedCharacter.id || validatedCharacter.name;
  const characterPrefix = `CHARACTER.${characterId.toUpperCase().replace(/ /g, "_")}.`;
  const characterSettings = Object.entries(process.env).filter(([key]) => key.startsWith(characterPrefix)).reduce((settings, [key, value]) => {
    const settingKey = key.slice(characterPrefix.length);
    return { ...settings, [settingKey]: value };
  }, {});
  if (Object.keys(characterSettings).length > 0) {
    const combinedSecrets = {
      ...characterSettings,
      ...validatedCharacter.secrets || {},
      ...typeof validatedCharacter.settings?.secrets === "object" && validatedCharacter.settings?.secrets !== null ? validatedCharacter.settings.secrets : {}
    };
    const updatedCharacter = {
      ...validatedCharacter
    };
    if (validatedCharacter.settings || Object.keys(combinedSecrets).length > 0) {
      updatedCharacter.settings = validatedCharacter.settings || {};
    }
    if (Object.keys(combinedSecrets).length > 0) {
      updatedCharacter.secrets = combinedSecrets;
    }
    const revalidationResult = validateCharacter(updatedCharacter);
    if (!revalidationResult.success) {
      logger28.warn(
        "Character became invalid after adding environment settings, using original validated character"
      );
      return validatedCharacter;
    }
    if (!revalidationResult.data) {
      logger28.warn("Revalidation succeeded but no data returned, using original character");
      return validatedCharacter;
    }
    return revalidationResult.data;
  }
  return validatedCharacter;
}
async function loadCharacter(filePath) {
  const content = tryLoadFile(filePath);
  if (!content) {
    throw new Error(`Character file not found: ${filePath}`);
  }
  const parseResult = parseAndValidateCharacter(content);
  if (!parseResult.success) {
    throw new Error(`Failed to load character from ${filePath}: ${parseResult.error?.message}`);
  }
  return jsonToCharacter(parseResult.data);
}
function handleCharacterLoadError(path10, error) {
  const errorMsg = error instanceof Error ? error.message : String(error);
  if (errorMsg.includes("ENOENT") || errorMsg.includes("no such file")) {
    logger28.error(`Character file not found: ${path10}`);
    throw new Error(
      `Character '${path10}' not found. Please check if the file exists and the path is correct.`
    );
  } else if (errorMsg.includes("Character validation failed")) {
    logger28.error(`Character validation failed for: ${path10}`);
    throw new Error(`Character file '${path10}' contains invalid character data. ${errorMsg}`);
  } else if (errorMsg.includes("JSON")) {
    logger28.error(`JSON parsing error in character file: ${path10}`);
    throw new Error(`Character file '${path10}' has malformed JSON. Please check the file content.`);
  } else if (errorMsg.includes("Invalid JSON")) {
    logger28.error(`Invalid JSON in character file: ${path10}`);
    throw new Error(
      `Character file '${path10}' has invalid JSON format. Please check the file content.`
    );
  } else {
    logger28.error(`Error loading character from ${path10}: ${errorMsg}`);
    throw new Error(`Failed to load character '${path10}': ${errorMsg}`);
  }
}
async function safeLoadCharacter(path10) {
  try {
    const character = await loadCharacter(path10);
    logger28.info(`Successfully loaded character from: ${path10}`);
    return character;
  } catch (e) {
    return handleCharacterLoadError(path10, e);
  }
}
async function loadCharacterTryPath(characterPath) {
  if (characterPath.startsWith("http")) {
    try {
      const characters = await loadCharactersFromUrl(characterPath);
      if (!characters || characters.length === 0) {
        throw new Error("No characters found in the URL response");
      }
      return characters[0];
    } catch (error) {
      throw error;
    }
  }
  const hasJsonExtension = characterPath.toLowerCase().endsWith(".json");
  const basePath = hasJsonExtension ? characterPath : characterPath;
  const jsonPath = hasJsonExtension ? characterPath : `${characterPath}.json`;
  const basePathsToTry = [
    basePath,
    path8.resolve(process.cwd(), basePath),
    path8.resolve(process.cwd(), "..", "..", basePath),
    path8.resolve(process.cwd(), "..", "..", "..", basePath),
    path8.resolve(process.cwd(), "agent", basePath),
    path8.resolve(__dirname, basePath),
    path8.resolve(__dirname, "characters", path8.basename(basePath)),
    path8.resolve(__dirname, "../characters", path8.basename(basePath)),
    path8.resolve(__dirname, "../../characters", path8.basename(basePath)),
    path8.resolve(__dirname, "../../../characters", path8.basename(basePath))
  ];
  const jsonPathsToTry = hasJsonExtension ? [] : [
    jsonPath,
    path8.resolve(process.cwd(), jsonPath),
    path8.resolve(process.cwd(), "..", "..", jsonPath),
    path8.resolve(process.cwd(), "..", "..", "..", jsonPath),
    path8.resolve(process.cwd(), "agent", jsonPath),
    path8.resolve(__dirname, jsonPath),
    path8.resolve(__dirname, "characters", path8.basename(jsonPath)),
    path8.resolve(__dirname, "../characters", path8.basename(jsonPath)),
    path8.resolve(__dirname, "../../characters", path8.basename(jsonPath)),
    path8.resolve(__dirname, "../../../characters", path8.basename(jsonPath))
  ];
  const pathsToTry = Array.from(/* @__PURE__ */ new Set([...basePathsToTry, ...jsonPathsToTry]));
  let lastError = null;
  for (const tryPath of pathsToTry) {
    try {
      const content = tryLoadFile(tryPath);
      if (content !== null) {
        return safeLoadCharacter(tryPath);
      }
    } catch (e) {
      lastError = e;
    }
  }
  const errorMessage = lastError ? `${lastError}` : "File not found in any of the expected locations";
  return handleCharacterLoadError(
    characterPath,
    `Character not found. Tried ${pathsToTry.length} locations. ${errorMessage}`
  );
}
function commaSeparatedStringToArray(commaSeparated) {
  return commaSeparated?.split(",").map((value) => value.trim());
}
async function readCharactersFromStorage(characterPaths) {
  try {
    const uploadDir = path8.join(process.cwd(), ".eliza", "data", "characters");
    await fs8.promises.mkdir(uploadDir, { recursive: true });
    const fileNames = await fs8.promises.readdir(uploadDir);
    for (const fileName of fileNames) {
      characterPaths.push(path8.join(uploadDir, fileName));
    }
  } catch (err) {
    logger28.error(`Error reading directory: ${err.message}`);
  }
  return characterPaths;
}
var hasValidRemoteUrls = () => process.env.REMOTE_CHARACTER_URLS && process.env.REMOTE_CHARACTER_URLS !== "" && process.env.REMOTE_CHARACTER_URLS.startsWith("http");
async function loadCharacters(charactersArg) {
  let characterPaths = commaSeparatedStringToArray(charactersArg);
  const loadedCharacters = [];
  if (process.env.USE_CHARACTER_STORAGE === "true") {
    characterPaths = await readCharactersFromStorage(characterPaths);
  }
  if (characterPaths?.length > 0) {
    for (const characterPath of characterPaths) {
      try {
        const character = await loadCharacterTryPath(characterPath);
        loadedCharacters.push(character);
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        logger28.error(`Failed to load character from '${characterPath}': ${errorMsg}`);
      }
    }
  }
  if (hasValidRemoteUrls()) {
    logger28.info("Loading characters from remote URLs");
    const characterUrls = commaSeparatedStringToArray(process.env.REMOTE_CHARACTER_URLS || "");
    for (const characterUrl of characterUrls) {
      const characters = await loadCharactersFromUrl(characterUrl);
      loadedCharacters.push(...characters);
    }
  }
  if (loadedCharacters.length === 0) {
    logger28.info("No characters found, using default character");
    logger28.warn("Server package does not include a default character. Please provide one.");
  }
  return loadedCharacters;
}

// src/index.ts
import {
  createDatabaseAdapter,
  DatabaseMigrationService,
  plugin as sqlPlugin
} from "@elizaos/plugin-sql";
import { existsSync as existsSync3 } from "fs";
import dotenv2 from "dotenv";
function expandTildePath(filepath) {
  if (!filepath) {
    return filepath;
  }
  if (filepath.startsWith("~")) {
    if (filepath === "~") {
      return process.cwd();
    } else if (filepath.startsWith("~/")) {
      return path9.join(process.cwd(), filepath.slice(2));
    } else if (filepath.startsWith("~~")) {
      return filepath;
    } else {
      return path9.join(process.cwd(), filepath.slice(1));
    }
  }
  return filepath;
}
function resolvePgliteDir(dir, fallbackDir) {
  const envPath = resolveEnvFile();
  if (existsSync3(envPath)) {
    dotenv2.config({ path: envPath });
  }
  const base = dir ?? process.env.PGLITE_DATA_DIR ?? fallbackDir ?? path9.join(process.cwd(), ".eliza", ".elizadb");
  const resolved = expandTildePath(base);
  const legacyPath = path9.join(process.cwd(), ".elizadb");
  if (resolved === legacyPath) {
    const newPath = path9.join(process.cwd(), ".eliza", ".elizadb");
    process.env.PGLITE_DATA_DIR = newPath;
    return newPath;
  }
  return resolved;
}
var __dirname2 = dirname(fileURLToPath2(import.meta.url));
var DEFAULT_SERVER_ID5 = "00000000-0000-0000-0000-000000000000";
var AgentServer = class {
  app;
  agents;
  server;
  socketIO;
  isInitialized = false;
  // Flag to prevent double initialization
  database;
  startAgent;
  stopAgent;
  loadCharacterTryPath;
  jsonToCharacter;
  /**
   * Constructor for AgentServer class.
   *
   * @constructor
   */
  constructor() {
    try {
      logger29.debug("Initializing AgentServer (constructor)...");
      this.agents = /* @__PURE__ */ new Map();
      this.loadCharacterTryPath = loadCharacterTryPath;
      this.jsonToCharacter = jsonToCharacter;
    } catch (error) {
      logger29.error("Failed to initialize AgentServer (constructor):", error);
      throw error;
    }
  }
  /**
   * Dynamically resolves the client path based on the installation context.
   * Handles both development and production scenarios.
   *
   * @returns {string} The resolved path to the client dist directory
   * @throws {Error} If no valid client path can be found
   */
  resolveClientPath() {
    try {
      const cliPackageJson = __require.resolve("@elizaos/cli/package.json");
      const cliDir = path9.dirname(cliPackageJson);
      const cliDistPath = path9.join(cliDir, "dist");
      if (fs9.existsSync(path9.join(cliDistPath, "index.html"))) {
        logger29.debug(`[CLIENT PATH] Resolved client path from npm package: ${cliDistPath}`);
        return cliDistPath;
      }
    } catch (e) {
      logger29.debug("[CLIENT PATH] Could not resolve @elizaos/cli package, trying other methods");
    }
    const relativePath = path9.resolve(__dirname2, "../../cli/dist");
    if (fs9.existsSync(path9.join(relativePath, "index.html"))) {
      logger29.debug(`[CLIENT PATH] Resolved client path from relative path: ${relativePath}`);
      return relativePath;
    }
    const cwdPath = path9.join(process.cwd(), "dist");
    if (fs9.existsSync(path9.join(cwdPath, "index.html"))) {
      logger29.debug(`[CLIENT PATH] Resolved client path from current directory: ${cwdPath}`);
      return cwdPath;
    }
    if (process.env.ELIZA_CLIENT_PATH) {
      const envPath = path9.resolve(process.env.ELIZA_CLIENT_PATH);
      if (fs9.existsSync(path9.join(envPath, "index.html"))) {
        logger29.debug(`[CLIENT PATH] Resolved client path from environment variable: ${envPath}`);
        return envPath;
      }
    }
    throw new Error(
      "Unable to locate client files. Please ensure @elizaos/cli is properly installed."
    );
  }
  /**
   * Initializes the database and server.
   *
   * @param {ServerOptions} [options] - Optional server options.
   * @returns {Promise<void>} A promise that resolves when initialization is complete.
   */
  async initialize(options) {
    if (this.isInitialized) {
      logger29.warn("AgentServer is already initialized, skipping initialization");
      return;
    }
    try {
      logger29.debug("Initializing AgentServer (async operations)...");
      const agentDataDir = await resolvePgliteDir(options?.dataDir);
      logger29.info(`[INIT] Database Dir for SQL plugin: ${agentDataDir}`);
      this.database = createDatabaseAdapter(
        {
          dataDir: agentDataDir,
          postgresUrl: options?.postgresUrl
        },
        "00000000-0000-0000-0000-000000000002"
      );
      await this.database.init();
      logger29.success("Consolidated database initialized successfully");
      logger29.info("[INIT] Running database migrations for messaging tables...");
      try {
        const migrationService = new DatabaseMigrationService();
        const db = this.database.getDatabase();
        await migrationService.initializeWithDatabase(db);
        migrationService.discoverAndRegisterPluginSchemas([sqlPlugin]);
        await migrationService.runAllPluginMigrations();
        logger29.success("[INIT] Database migrations completed successfully");
      } catch (migrationError) {
        logger29.error("[INIT] Failed to run database migrations:", migrationError);
        throw new Error(
          `Database migration failed: ${migrationError instanceof Error ? migrationError.message : String(migrationError)}`
        );
      }
      await new Promise((resolve) => setTimeout(resolve, 500));
      logger29.info("[INIT] Ensuring default server exists...");
      await this.ensureDefaultServer();
      logger29.success("[INIT] Default server setup complete");
      await this.initializeServer(options);
      await new Promise((resolve) => setTimeout(resolve, 250));
      this.isInitialized = true;
    } catch (error) {
      logger29.error("Failed to initialize AgentServer (async operations):", error);
      console.trace(error);
      throw error;
    }
  }
  async ensureDefaultServer() {
    try {
      logger29.info("[AgentServer] Checking for default server...");
      const servers = await this.database.getMessageServers();
      logger29.debug(`[AgentServer] Found ${servers.length} existing servers`);
      servers.forEach((s) => {
        logger29.debug(`[AgentServer] Existing server: ID=${s.id}, Name=${s.name}`);
      });
      const defaultServer = servers.find(
        (s) => s.id === "00000000-0000-0000-0000-000000000000"
      );
      if (!defaultServer) {
        logger29.info(
          "[AgentServer] Creating default server with UUID 00000000-0000-0000-0000-000000000000..."
        );
        try {
          await this.database.db.execute(`
            INSERT INTO message_servers (id, name, source_type, created_at, updated_at)
            VALUES ('00000000-0000-0000-0000-000000000000', 'Default Server', 'eliza_default', NOW(), NOW())
            ON CONFLICT (id) DO NOTHING
          `);
          logger29.success("[AgentServer] Default server created via raw SQL");
          const checkResult = await this.database.db.execute(
            "SELECT id, name FROM message_servers WHERE id = '00000000-0000-0000-0000-000000000000'"
          );
          logger29.debug("[AgentServer] Raw SQL check result:", checkResult);
        } catch (sqlError) {
          logger29.error("[AgentServer] Raw SQL insert failed:", sqlError);
          try {
            const server = await this.database.createMessageServer({
              id: "00000000-0000-0000-0000-000000000000",
              name: "Default Server",
              sourceType: "eliza_default"
            });
            logger29.success("[AgentServer] Default server created via ORM with ID:", server.id);
          } catch (ormError) {
            logger29.error("[AgentServer] Both SQL and ORM creation failed:", ormError);
            throw new Error(`Failed to create default server: ${ormError.message}`);
          }
        }
        const verifyServers = await this.database.getMessageServers();
        logger29.debug(`[AgentServer] After creation attempt, found ${verifyServers.length} servers`);
        verifyServers.forEach((s) => {
          logger29.debug(`[AgentServer] Server after creation: ID=${s.id}, Name=${s.name}`);
        });
        const verifyDefault = verifyServers.find(
          (s) => s.id === "00000000-0000-0000-0000-000000000000"
        );
        if (!verifyDefault) {
          throw new Error(`Failed to create or verify default server with ID ${DEFAULT_SERVER_ID5}`);
        } else {
          logger29.success("[AgentServer] Default server creation verified successfully");
        }
      } else {
        logger29.info("[AgentServer] Default server already exists with ID:", defaultServer.id);
      }
    } catch (error) {
      logger29.error("[AgentServer] Error ensuring default server:", error);
      throw error;
    }
  }
  /**
   * Initializes the server with the provided options.
   *
   * @param {ServerOptions} [options] - Optional server options.
   * @returns {Promise<void>} - A promise that resolves once the server is initialized.
   */
  async initializeServer(options) {
    try {
      this.app = express30();
      const isProd = process.env.NODE_ENV === "production";
      logger29.debug("Setting up security headers...");
      if (!isProd) {
        logger29.debug(`NODE_ENV: ${process.env.NODE_ENV}`);
        logger29.debug(`CSP will be: ${isProd ? "ENABLED" : "MINIMAL_DEV"}`);
      }
      this.app.use(
        helmet2({
          // Content Security Policy - environment-aware configuration
          contentSecurityPolicy: isProd ? {
            // Production CSP - includes upgrade-insecure-requests
            directives: {
              defaultSrc: ["'self'"],
              styleSrc: ["'self'", "'unsafe-inline'", "https:"],
              scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
              imgSrc: ["'self'", "data:", "blob:", "https:", "http:"],
              fontSrc: ["'self'", "https:", "data:"],
              connectSrc: ["'self'", "ws:", "wss:", "https:", "http:"],
              mediaSrc: ["'self'", "blob:", "data:"],
              objectSrc: ["'none'"],
              frameSrc: ["'none'"],
              baseUri: ["'self'"],
              formAction: ["'self'"]
              // upgrade-insecure-requests is added by helmet automatically
            },
            useDefaults: true
          } : {
            // Development CSP - minimal policy without upgrade-insecure-requests
            directives: {
              defaultSrc: ["'self'"],
              styleSrc: ["'self'", "'unsafe-inline'", "https:", "http:"],
              scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
              imgSrc: ["'self'", "data:", "blob:", "https:", "http:"],
              fontSrc: ["'self'", "https:", "http:", "data:"],
              connectSrc: ["'self'", "ws:", "wss:", "https:", "http:"],
              mediaSrc: ["'self'", "blob:", "data:"],
              objectSrc: ["'none'"],
              frameSrc: ["'self'", "data:"],
              baseUri: ["'self'"],
              formAction: ["'self'"]
              // Note: upgrade-insecure-requests is intentionally omitted for Safari compatibility
            },
            useDefaults: false
          },
          // Cross-Origin Embedder Policy - disabled for compatibility
          crossOriginEmbedderPolicy: false,
          // Cross-Origin Resource Policy
          crossOriginResourcePolicy: { policy: "cross-origin" },
          // Frame Options - allow same-origin iframes to align with frameSrc CSP
          frameguard: { action: "sameorigin" },
          // Hide Powered-By header
          hidePoweredBy: true,
          // HTTP Strict Transport Security - only in production
          hsts: isProd ? {
            maxAge: 31536e3,
            // 1 year
            includeSubDomains: true,
            preload: true
          } : false,
          // No Sniff
          noSniff: true,
          // Referrer Policy
          referrerPolicy: { policy: "no-referrer-when-downgrade" },
          // X-XSS-Protection
          xssFilter: true
        })
      );
      if (options?.middlewares) {
        logger29.debug("Applying custom middlewares...");
        for (const middleware of options.middlewares) {
          this.app.use(middleware);
        }
      }
      logger29.debug("Setting up standard middlewares...");
      this.app.use(
        (0, import_cors2.default)({
          origin: process.env.CORS_ORIGIN || true,
          credentials: true,
          methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
          allowedHeaders: ["Content-Type", "Authorization", "X-API-KEY"]
        })
      );
      this.app.use(
        express30.json({
          limit: process.env.EXPRESS_MAX_PAYLOAD || "100kb"
        })
      );
      const serverAuthToken = process.env.ELIZA_SERVER_AUTH_TOKEN;
      if (serverAuthToken) {
        logger29.info("Server authentication enabled. Requires X-API-KEY header for /api routes.");
        this.app.use("/api", (req, res, next) => {
          apiKeyAuthMiddleware(req, res, next);
        });
      } else {
        logger29.warn(
          "Server authentication is disabled. Set ELIZA_SERVER_AUTH_TOKEN environment variable to enable."
        );
      }
      const uploadsBasePath = path9.join(process.cwd(), ".eliza", "data", "uploads", "agents");
      const generatedBasePath = path9.join(process.cwd(), ".eliza", "data", "generated");
      fs9.mkdirSync(uploadsBasePath, { recursive: true });
      fs9.mkdirSync(generatedBasePath, { recursive: true });
      this.app.get(
        "/media/uploads/agents/:agentId/:filename",
        // @ts-expect-error - this is a valid express route
        (req, res) => {
          const agentId = req.params.agentId;
          const filename = req.params.filename;
          const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
          if (!uuidRegex.test(agentId)) {
            return res.status(400).json({ error: "Invalid agent ID format" });
          }
          const sanitizedFilename = basename(filename);
          const agentUploadsPath = join(uploadsBasePath, agentId);
          const filePath = join(agentUploadsPath, sanitizedFilename);
          if (!filePath.startsWith(agentUploadsPath)) {
            return res.status(403).json({ error: "Access denied" });
          }
          if (!fs9.existsSync(filePath)) {
            return res.status(404).json({ error: "File does not exist!!!!!!!" });
          }
          res.sendFile(sanitizedFilename, { root: agentUploadsPath }, (err) => {
            if (err) {
              if (err.message === "Request aborted") {
                logger29.warn(`[MEDIA] Download aborted: ${req.originalUrl}`);
              } else if (!res.headersSent) {
                logger29.warn(`[MEDIA] File not found: ${agentUploadsPath}/${sanitizedFilename}`);
                res.status(404).json({ error: "File not found" });
              }
            } else {
              logger29.debug(`[MEDIA] Successfully served: ${sanitizedFilename}`);
            }
          });
        }
      );
      this.app.get(
        "/media/generated/:agentId/:filename",
        // @ts-expect-error - this is a valid express route
        (req, res) => {
          const agentId = req.params.agentId;
          const filename = req.params.filename;
          const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
          if (!uuidRegex.test(agentId)) {
            return res.status(400).json({ error: "Invalid agent ID format" });
          }
          const sanitizedFilename = basename(filename);
          const agentGeneratedPath = join(generatedBasePath, agentId);
          const filePath = join(agentGeneratedPath, sanitizedFilename);
          if (!filePath.startsWith(agentGeneratedPath)) {
            return res.status(403).json({ error: "Access denied" });
          }
          res.sendFile(filePath, (err) => {
            if (err) {
              res.status(404).json({ error: "File not found" });
            }
          });
        }
      );
      this.app.get(
        "/media/uploads/channels/:channelId/:filename",
        (req, res) => {
          const channelId = req.params.channelId;
          const filename = req.params.filename;
          const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
          if (!uuidRegex.test(channelId)) {
            res.status(400).json({ error: "Invalid channel ID format" });
            return;
          }
          const sanitizedFilename = basename(filename);
          const channelUploadsPath = join(uploadsBasePath, "channels", channelId);
          const filePath = join(channelUploadsPath, sanitizedFilename);
          if (!filePath.startsWith(channelUploadsPath)) {
            res.status(403).json({ error: "Access denied" });
            return;
          }
          res.sendFile(filePath, (err) => {
            if (err) {
              logger29.warn(`[STATIC] Channel media file not found: ${filePath}`, err);
              if (!res.headersSent) {
                res.status(404).json({ error: "File not found" });
              }
            } else {
              logger29.debug(`[STATIC] Served channel media file: ${filePath}`);
            }
          });
        }
      );
      this.app.use((req, res, next) => {
        const ext = extname(req.path).toLowerCase();
        if (ext === ".js" || ext === ".mjs") {
          res.setHeader("Content-Type", "application/javascript");
        } else if (ext === ".css") {
          res.setHeader("Content-Type", "text/css");
        } else if (ext === ".svg") {
          res.setHeader("Content-Type", "image/svg+xml");
        } else if (ext === ".png") {
          res.setHeader("Content-Type", "image/png");
        } else if (ext === ".jpg" || ext === ".jpeg") {
          res.setHeader("Content-Type", "image/jpeg");
        }
        next();
      });
      const staticOptions = {
        etag: true,
        lastModified: true,
        setHeaders: (res, filePath) => {
          const ext = extname(filePath).toLowerCase();
          if (ext === ".css") {
            res.setHeader("Content-Type", "text/css");
          } else if (ext === ".js") {
            res.setHeader("Content-Type", "application/javascript");
          } else if (ext === ".html") {
            res.setHeader("Content-Type", "text/html");
          } else if (ext === ".png") {
            res.setHeader("Content-Type", "image/png");
          } else if (ext === ".jpg" || ext === ".jpeg") {
            res.setHeader("Content-Type", "image/jpeg");
          } else if (ext === ".svg") {
            res.setHeader("Content-Type", "image/svg+xml");
          }
        }
      };
      try {
        const clientPath = this.resolveClientPath();
        this.app.use(express30.static(clientPath, staticOptions));
        logger29.info(`[STATIC] Serving client files from: ${clientPath}`);
      } catch (error) {
        logger29.error("[STATIC] Failed to resolve client path:", error);
        logger29.warn("[STATIC] Client UI will not be available. API endpoints will still work.");
      }
      const pluginRouteHandler = createPluginRouteHandler(this.agents);
      this.app.use(pluginRouteHandler);
      const apiRouter = createApiRouter(this.agents, this);
      this.app.use(
        "/api",
        (req, _res, next) => {
          if (req.path !== "/ping") {
            logger29.debug(`API request: ${req.method} ${req.path}`);
          }
          next();
        },
        apiRouter,
        (err, req, res, _next) => {
          logger29.error(`API error: ${req.method} ${req.path}`, err);
          res.status(500).json({
            success: false,
            error: {
              message: err.message || "Internal Server Error",
              code: err.code || 500
            }
          });
        }
      );
      this.app.use((req, res, next) => {
        if (req.path.startsWith("/api/")) {
          res.status(404).json({
            success: false,
            error: {
              message: "API endpoint not found",
              code: 404
            }
          });
        } else {
          next();
        }
      });
      this.app.use((req, res) => {
        if (req.path.endsWith(".js") || req.path.includes(".js?") || req.path.match(/\/[a-zA-Z0-9_-]+-[A-Za-z0-9]{8}\.js/)) {
          res.setHeader("Content-Type", "application/javascript");
          return res.status(404).send(`// JavaScript module not found: ${req.path}`);
        }
        try {
          const cliDistPath = this.resolveClientPath();
          res.sendFile(path9.join(cliDistPath, "index.html"), (err) => {
            if (err && !res.headersSent) {
              logger29.error("[STATIC] Failed to serve index.html:", err);
              res.status(404).json({
                success: false,
                error: {
                  message: "Client UI not available. Please ensure @elizaos/cli is properly installed.",
                  code: 404
                }
              });
            }
          });
        } catch (error) {
          logger29.error("[STATIC] Failed to resolve client path for fallback route:", error);
          res.status(404).json({
            success: false,
            error: {
              message: "Client UI not available. API endpoints are still accessible at /api/*",
              code: 404
            }
          });
        }
      });
      this.server = http.createServer(this.app);
      this.socketIO = setupSocketIO(this.server, this.agents, this);
      logger29.success("AgentServer HTTP server and Socket.IO initialized");
    } catch (error) {
      logger29.error("Failed to complete server initialization:", error);
      throw error;
    }
  }
  /**
   * Registers an agent with the provided runtime.
   *
   * @param {IAgentRuntime} runtime - The runtime object containing agent information.
   * @throws {Error} if the runtime is null/undefined, if agentId is missing, if character configuration is missing,
   * or if there are any errors during registration.
   */
  async registerAgent(runtime) {
    try {
      if (!runtime) {
        throw new Error("Attempted to register null/undefined runtime");
      }
      if (!runtime.agentId) {
        throw new Error("Runtime missing agentId");
      }
      if (!runtime.character) {
        throw new Error("Runtime missing character configuration");
      }
      this.agents.set(runtime.agentId, runtime);
      logger29.debug(`Agent ${runtime.character.name} (${runtime.agentId}) added to agents map`);
      try {
        if (messageBusConnectorPlugin) {
          await runtime.registerPlugin(messageBusConnectorPlugin);
          logger29.info(
            `[AgentServer] Automatically registered MessageBusConnector for agent ${runtime.character.name}`
          );
        } else {
          logger29.error(`[AgentServer] CRITICAL: MessageBusConnector plugin definition not found.`);
        }
      } catch (e) {
        logger29.error(
          `[AgentServer] CRITICAL: Failed to register MessageBusConnector for agent ${runtime.character.name}`,
          e
        );
      }
      const teePlugin = runtime.plugins.find((p) => p.name === "phala-tee-plugin");
      if (teePlugin) {
        logger29.debug(`Found TEE plugin for agent ${runtime.agentId}`);
        if (teePlugin.providers) {
          for (const provider of teePlugin.providers) {
            runtime.registerProvider(provider);
            logger29.debug(`Registered TEE provider: ${provider.name}`);
          }
        }
        if (teePlugin.actions) {
          for (const action of teePlugin.actions) {
            runtime.registerAction(action);
            logger29.debug(`Registered TEE action: ${action.name}`);
          }
        }
      }
      logger29.success(
        `Successfully registered agent ${runtime.character.name} (${runtime.agentId}) with core services.`
      );
      await this.addAgentToServer(DEFAULT_SERVER_ID5, runtime.agentId);
      logger29.info(
        `[AgentServer] Auto-associated agent ${runtime.character.name} with server ID: ${DEFAULT_SERVER_ID5}`
      );
    } catch (error) {
      logger29.error("Failed to register agent:", error);
      throw error;
    }
  }
  /**
   * Unregisters an agent from the system.
   *
   * @param {UUID} agentId - The unique identifier of the agent to unregister.
   * @returns {void}
   */
  unregisterAgent(agentId) {
    if (!agentId) {
      logger29.warn("[AGENT UNREGISTER] Attempted to unregister undefined or invalid agent runtime");
      return;
    }
    try {
      const agent = this.agents.get(agentId);
      if (agent) {
        try {
          agent.stop().catch((stopError) => {
            logger29.error(
              `[AGENT UNREGISTER] Error stopping agent services for ${agentId}:`,
              stopError
            );
          });
          logger29.debug(`[AGENT UNREGISTER] Stopping services for agent ${agentId}`);
        } catch (stopError) {
          logger29.error(`[AGENT UNREGISTER] Error initiating stop for agent ${agentId}:`, stopError);
        }
      }
      this.agents.delete(agentId);
      logger29.debug(`Agent ${agentId} removed from agents map`);
    } catch (error) {
      logger29.error(`Error removing agent ${agentId}:`, error);
    }
  }
  /**
   * Add middleware to the server's request handling pipeline
   * @param {ServerMiddleware} middleware - The middleware function to be registered
   */
  registerMiddleware(middleware) {
    this.app.use(middleware);
  }
  /**
   * Starts the server on the specified port.
   *
   * @param {number} port - The port number on which the server should listen.
   * @throws {Error} If the port is invalid or if there is an error while starting the server.
   */
  start(port) {
    try {
      if (!port || typeof port !== "number") {
        throw new Error(`Invalid port number: ${port}`);
      }
      logger29.debug(`Starting server on port ${port}...`);
      logger29.debug(`Current agents count: ${this.agents.size}`);
      logger29.debug(`Environment: ${process.env.NODE_ENV}`);
      const host = process.env.SERVER_HOST || "0.0.0.0";
      this.server.listen(port, host, () => {
        if (process.env.NODE_ENV !== "development") {
          console.log(
            `\x1B[32mStartup successful!
Go to the dashboard at \x1B[1mhttp://localhost:${port}\x1B[22m\x1B[0m`
          );
        }
        console.log(`AgentServer is listening on port ${port}`);
        logger29.success(
          `REST API bound to ${host}:${port}. If running locally, access it at http://localhost:${port}.`
        );
        logger29.debug(`Active agents: ${this.agents.size}`);
        this.agents.forEach((agent, id) => {
          logger29.debug(`- Agent ${id}: ${agent.character.name}`);
        });
      }).on("error", (error) => {
        logger29.error(`Failed to bind server to ${host}:${port}:`, error);
        if (error.code === "EADDRINUSE") {
          logger29.error(
            `Port ${port} is already in use. Please try a different port or stop the process using that port.`
          );
        } else if (error.code === "EACCES") {
          logger29.error(
            `Permission denied to bind to port ${port}. Try using a port above 1024 or running with appropriate permissions.`
          );
        } else if (error.code === "EADDRNOTAVAIL") {
          logger29.error(
            `Cannot bind to ${host}:${port} - address not available. Check if the host address is correct.`
          );
        }
        throw error;
      });
      const gracefulShutdown = async () => {
        logger29.info("Received shutdown signal, initiating graceful shutdown...");
        logger29.debug("Stopping all agents...");
        for (const [id, agent] of this.agents.entries()) {
          try {
            await agent.stop();
            logger29.debug(`Stopped agent ${id}`);
          } catch (error) {
            logger29.error(`Error stopping agent ${id}:`, error);
          }
        }
        if (this.database) {
          try {
            await this.database.close();
            logger29.info("Database closed.");
          } catch (error) {
            logger29.error("Error closing database:", error);
          }
        }
        this.server.close(() => {
          logger29.success("Server closed successfully");
          process.exit(0);
        });
        setTimeout(() => {
          logger29.error("Could not close connections in time, forcing shutdown");
          process.exit(1);
        }, 5e3);
      };
      process.on("SIGTERM", gracefulShutdown);
      process.on("SIGINT", gracefulShutdown);
      logger29.debug("Shutdown handlers registered");
    } catch (error) {
      logger29.error("Failed to start server:", error);
      throw error;
    }
  }
  /**
   * Stops the server if it is running. Closes the server connection,
   * stops the database connection, and logs a success message.
   */
  async stop() {
    if (this.server) {
      this.server.close(() => {
        logger29.success("Server stopped");
      });
    }
  }
  // Central DB Data Access Methods
  async createServer(data) {
    return this.database.createMessageServer(data);
  }
  async getServers() {
    return this.database.getMessageServers();
  }
  async getServerById(serverId) {
    return this.database.getMessageServerById(serverId);
  }
  async getServerBySourceType(sourceType) {
    const servers = await this.database.getMessageServers();
    const filtered = servers.filter((s) => s.sourceType === sourceType);
    return filtered.length > 0 ? filtered[0] : null;
  }
  async createChannel(data, participantIds) {
    return this.database.createChannel(data, participantIds);
  }
  async addParticipantsToChannel(channelId, userIds) {
    return this.database.addChannelParticipants(channelId, userIds);
  }
  async getChannelsForServer(serverId) {
    return this.database.getChannelsForServer(serverId);
  }
  async getChannelDetails(channelId) {
    return this.database.getChannelDetails(channelId);
  }
  async getChannelParticipants(channelId) {
    return this.database.getChannelParticipants(channelId);
  }
  async deleteMessage(messageId) {
    return this.database.deleteMessage(messageId);
  }
  async updateChannel(channelId, updates) {
    return this.database.updateChannel(channelId, updates);
  }
  async deleteChannel(channelId) {
    return this.database.deleteChannel(channelId);
  }
  async clearChannelMessages(channelId) {
    const messages = await this.database.getMessagesForChannel(channelId, 1e3);
    for (const message of messages) {
      await this.database.deleteMessage(message.id);
    }
    logger29.info(`[AgentServer] Cleared all messages for central channel: ${channelId}`);
  }
  async findOrCreateCentralDmChannel(user1Id, user2Id, messageServerId) {
    return this.database.findOrCreateDmChannel(user1Id, user2Id, messageServerId);
  }
  async createMessage(data) {
    const createdMessage = await this.database.createMessage(data);
    const channel = await this.getChannelDetails(createdMessage.channelId);
    if (channel) {
      const messageForBus = {
        id: createdMessage.id,
        channel_id: createdMessage.channelId,
        server_id: channel.messageServerId,
        author_id: createdMessage.authorId,
        content: createdMessage.content,
        raw_message: createdMessage.rawMessage,
        source_id: createdMessage.sourceId,
        source_type: createdMessage.sourceType,
        in_reply_to_message_id: createdMessage.inReplyToRootMessageId,
        created_at: createdMessage.createdAt.getTime(),
        metadata: createdMessage.metadata
      };
      bus_default.emit("new_message", messageForBus);
      logger29.info(`[AgentServer] Published message ${createdMessage.id} to internal message bus`);
    }
    return createdMessage;
  }
  async getMessagesForChannel(channelId, limit = 50, beforeTimestamp) {
    return this.database.getMessagesForChannel(channelId, limit, beforeTimestamp);
  }
  // Optional: Method to remove a participant
  async removeParticipantFromChannel() {
    logger29.warn(
      `[AgentServer] Remove participant operation not directly supported in database adapter`
    );
  }
  // ===============================
  // Server-Agent Association Methods
  // ===============================
  /**
   * Add an agent to a server
   * @param {UUID} serverId - The server ID
   * @param {UUID} agentId - The agent ID to add
   */
  async addAgentToServer(serverId, agentId) {
    const server = await this.getServerById(serverId);
    if (!server) {
      throw new Error(`Server ${serverId} not found`);
    }
    return this.database.addAgentToServer(serverId, agentId);
  }
  /**
   * Remove an agent from a server
   * @param {UUID} serverId - The server ID
   * @param {UUID} agentId - The agent ID to remove
   */
  async removeAgentFromServer(serverId, agentId) {
    return this.database.removeAgentFromServer(serverId, agentId);
  }
  /**
   * Get all agents associated with a server
   * @param {UUID} serverId - The server ID
   * @returns {Promise<UUID[]>} Array of agent IDs
   */
  async getAgentsForServer(serverId) {
    return this.database.getAgentsForServer(serverId);
  }
  /**
   * Get all servers an agent belongs to
   * @param {UUID} agentId - The agent ID
   * @returns {Promise<UUID[]>} Array of server IDs
   */
  async getServersForAgent(agentId) {
    const servers = await this.database.getMessageServers();
    const serverIds = [];
    for (const server of servers) {
      const agents = await this.database.getAgentsForServer(server.id);
      if (agents.includes(agentId)) {
        serverIds.push(server.id);
      }
    }
    return serverIds;
  }
};
export {
  AgentServer,
  expandTildePath,
  hasValidRemoteUrls,
  jsonToCharacter,
  loadCharacter,
  loadCharacterTryPath,
  loadCharacters,
  loadCharactersFromUrl,
  resolvePgliteDir,
  tryLoadFile
};
/*! Bundled license information:

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

vary/index.js:
  (*!
   * vary
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=index.js.map