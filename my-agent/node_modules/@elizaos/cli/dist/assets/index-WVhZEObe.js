import { p as process$1, l as getAugmentedNamespace, g as getDefaultExportFromCjs } from './vendor-DSdxb8P-.js';
import { r as requireStreamBrowserify, a as requireString_decoder, b as requireUtil, c as requireShams, d as requireCallBound$1, e as requireEsObjectAtoms, f as requireCallBind, g as requireGetIntrinsic, h as requireDefineDataProperty, i as requireHasPropertyDescriptors, j as requireEvents, B as Buffer } from './index-BHRtDt-w.js';

function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== 'string' && !Array.isArray(e)) { for (const k in e) {
      if (k !== 'default' && !(k in n)) {
        const d = Object.getOwnPropertyDescriptor(e, k);
        if (d) {
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: () => e[k]
          });
        }
      }
    } }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }));
}

var pinoPretty = {exports: {}};

var colorette = {};

var ttyBrowserify = {};

var hasRequiredTtyBrowserify;

function requireTtyBrowserify () {
	if (hasRequiredTtyBrowserify) return ttyBrowserify;
	hasRequiredTtyBrowserify = 1;
	ttyBrowserify.isatty = function () { return false; };

	function ReadStream() {
	  throw new Error('tty.ReadStream is not implemented');
	}
	ttyBrowserify.ReadStream = ReadStream;

	function WriteStream() {
	  throw new Error('tty.WriteStream is not implemented');
	}
	ttyBrowserify.WriteStream = WriteStream;
	return ttyBrowserify;
}

var hasRequiredColorette;

function requireColorette () {
	if (hasRequiredColorette) return colorette;
	hasRequiredColorette = 1;

	Object.defineProperty(colorette, '__esModule', { value: true });

	var tty = requireTtyBrowserify();

	function _interopNamespace(e) {
	  if (e && e.__esModule) return e;
	  var n = Object.create(null);
	  if (e) {
	    Object.keys(e).forEach(function (k) {
	      if (k !== 'default') {
	        var d = Object.getOwnPropertyDescriptor(e, k);
	        Object.defineProperty(n, k, d.get ? d : {
	          enumerable: true,
	          get: function () { return e[k]; }
	        });
	      }
	    });
	  }
	  n["default"] = e;
	  return Object.freeze(n);
	}

	var tty__namespace = /*#__PURE__*/_interopNamespace(tty);

	const {
	  env = {},
	  argv = [],
	  platform = "",
	} = typeof process$1 === "undefined" ? {} : process$1;

	const isDisabled = "NO_COLOR" in env || argv.includes("--no-color");
	const isForced = "FORCE_COLOR" in env || argv.includes("--color");
	const isWindows = platform === "win32";
	const isDumbTerminal = env.TERM === "dumb";

	const isCompatibleTerminal =
	  tty__namespace && tty__namespace.isatty && tty__namespace.isatty(1) && env.TERM && !isDumbTerminal;

	const isCI =
	  "CI" in env &&
	  ("GITHUB_ACTIONS" in env || "GITLAB_CI" in env || "CIRCLECI" in env);

	const isColorSupported =
	  !isDisabled &&
	  (isForced || (isWindows && !isDumbTerminal) || isCompatibleTerminal || isCI);

	const replaceClose = (
	  index,
	  string,
	  close,
	  replace,
	  head = string.substring(0, index) + replace,
	  tail = string.substring(index + close.length),
	  next = tail.indexOf(close)
	) => head + (next < 0 ? tail : replaceClose(next, tail, close, replace));

	const clearBleed = (index, string, open, close, replace) =>
	  index < 0
	    ? open + string + close
	    : open + replaceClose(index, string, close, replace) + close;

	const filterEmpty =
	  (open, close, replace = open, at = open.length + 1) =>
	  (string) =>
	    string || !(string === "" || string === undefined)
	      ? clearBleed(
	          ("" + string).indexOf(close, at),
	          string,
	          open,
	          close,
	          replace
	        )
	      : "";

	const init = (open, close, replace) =>
	  filterEmpty(`\x1b[${open}m`, `\x1b[${close}m`, replace);

	const colors = {
	  reset: init(0, 0),
	  bold: init(1, 22, "\x1b[22m\x1b[1m"),
	  dim: init(2, 22, "\x1b[22m\x1b[2m"),
	  italic: init(3, 23),
	  underline: init(4, 24),
	  inverse: init(7, 27),
	  hidden: init(8, 28),
	  strikethrough: init(9, 29),
	  black: init(30, 39),
	  red: init(31, 39),
	  green: init(32, 39),
	  yellow: init(33, 39),
	  blue: init(34, 39),
	  magenta: init(35, 39),
	  cyan: init(36, 39),
	  white: init(37, 39),
	  gray: init(90, 39),
	  bgBlack: init(40, 49),
	  bgRed: init(41, 49),
	  bgGreen: init(42, 49),
	  bgYellow: init(43, 49),
	  bgBlue: init(44, 49),
	  bgMagenta: init(45, 49),
	  bgCyan: init(46, 49),
	  bgWhite: init(47, 49),
	  blackBright: init(90, 39),
	  redBright: init(91, 39),
	  greenBright: init(92, 39),
	  yellowBright: init(93, 39),
	  blueBright: init(94, 39),
	  magentaBright: init(95, 39),
	  cyanBright: init(96, 39),
	  whiteBright: init(97, 39),
	  bgBlackBright: init(100, 49),
	  bgRedBright: init(101, 49),
	  bgGreenBright: init(102, 49),
	  bgYellowBright: init(103, 49),
	  bgBlueBright: init(104, 49),
	  bgMagentaBright: init(105, 49),
	  bgCyanBright: init(106, 49),
	  bgWhiteBright: init(107, 49),
	};

	const createColors = ({ useColor = isColorSupported } = {}) =>
	  useColor
	    ? colors
	    : Object.keys(colors).reduce(
	        (colors, key) => ({ ...colors, [key]: String }),
	        {}
	      );

	const {
	  reset,
	  bold,
	  dim,
	  italic,
	  underline,
	  inverse,
	  hidden,
	  strikethrough,
	  black,
	  red,
	  green,
	  yellow,
	  blue,
	  magenta,
	  cyan,
	  white,
	  gray,
	  bgBlack,
	  bgRed,
	  bgGreen,
	  bgYellow,
	  bgBlue,
	  bgMagenta,
	  bgCyan,
	  bgWhite,
	  blackBright,
	  redBright,
	  greenBright,
	  yellowBright,
	  blueBright,
	  magentaBright,
	  cyanBright,
	  whiteBright,
	  bgBlackBright,
	  bgRedBright,
	  bgGreenBright,
	  bgYellowBright,
	  bgBlueBright,
	  bgMagentaBright,
	  bgCyanBright,
	  bgWhiteBright,
	} = createColors();

	colorette.bgBlack = bgBlack;
	colorette.bgBlackBright = bgBlackBright;
	colorette.bgBlue = bgBlue;
	colorette.bgBlueBright = bgBlueBright;
	colorette.bgCyan = bgCyan;
	colorette.bgCyanBright = bgCyanBright;
	colorette.bgGreen = bgGreen;
	colorette.bgGreenBright = bgGreenBright;
	colorette.bgMagenta = bgMagenta;
	colorette.bgMagentaBright = bgMagentaBright;
	colorette.bgRed = bgRed;
	colorette.bgRedBright = bgRedBright;
	colorette.bgWhite = bgWhite;
	colorette.bgWhiteBright = bgWhiteBright;
	colorette.bgYellow = bgYellow;
	colorette.bgYellowBright = bgYellowBright;
	colorette.black = black;
	colorette.blackBright = blackBright;
	colorette.blue = blue;
	colorette.blueBright = blueBright;
	colorette.bold = bold;
	colorette.createColors = createColors;
	colorette.cyan = cyan;
	colorette.cyanBright = cyanBright;
	colorette.dim = dim;
	colorette.gray = gray;
	colorette.green = green;
	colorette.greenBright = greenBright;
	colorette.hidden = hidden;
	colorette.inverse = inverse;
	colorette.isColorSupported = isColorSupported;
	colorette.italic = italic;
	colorette.magenta = magenta;
	colorette.magentaBright = magentaBright;
	colorette.red = red;
	colorette.redBright = redBright;
	colorette.reset = reset;
	colorette.strikethrough = strikethrough;
	colorette.underline = underline;
	colorette.white = white;
	colorette.whiteBright = whiteBright;
	colorette.yellow = yellow;
	colorette.yellowBright = yellowBright;
	return colorette;
}

var once = {exports: {}};

var wrappy_1;
var hasRequiredWrappy;

function requireWrappy () {
	if (hasRequiredWrappy) return wrappy_1;
	hasRequiredWrappy = 1;
	// Returns a wrapper function that returns a wrapped callback
	// The wrapper function should do some stuff, and return a
	// presumably different callback function.
	// This makes sure that own properties are retained, so that
	// decorations and such are not lost along the way.
	wrappy_1 = wrappy;
	function wrappy (fn, cb) {
	  if (fn && cb) return wrappy(fn)(cb)

	  if (typeof fn !== 'function')
	    throw new TypeError('need wrapper function')

	  Object.keys(fn).forEach(function (k) {
	    wrapper[k] = fn[k];
	  });

	  return wrapper

	  function wrapper() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    var ret = fn.apply(this, args);
	    var cb = args[args.length-1];
	    if (typeof ret === 'function' && ret !== cb) {
	      Object.keys(cb).forEach(function (k) {
	        ret[k] = cb[k];
	      });
	    }
	    return ret
	  }
	}
	return wrappy_1;
}

var hasRequiredOnce;

function requireOnce () {
	if (hasRequiredOnce) return once.exports;
	hasRequiredOnce = 1;
	var wrappy = requireWrappy();
	once.exports = wrappy(once$1);
	once.exports.strict = wrappy(onceStrict);

	once$1.proto = once$1(function () {
	  Object.defineProperty(Function.prototype, 'once', {
	    value: function () {
	      return once$1(this)
	    },
	    configurable: true
	  });

	  Object.defineProperty(Function.prototype, 'onceStrict', {
	    value: function () {
	      return onceStrict(this)
	    },
	    configurable: true
	  });
	});

	function once$1 (fn) {
	  var f = function () {
	    if (f.called) return f.value
	    f.called = true;
	    return f.value = fn.apply(this, arguments)
	  };
	  f.called = false;
	  return f
	}

	function onceStrict (fn) {
	  var f = function () {
	    if (f.called)
	      throw new Error(f.onceError)
	    f.called = true;
	    return f.value = fn.apply(this, arguments)
	  };
	  var name = fn.name || 'Function wrapped with `once`';
	  f.onceError = name + " shouldn't be called more than once";
	  f.called = false;
	  return f
	}
	return once.exports;
}

var endOfStream;
var hasRequiredEndOfStream;

function requireEndOfStream () {
	if (hasRequiredEndOfStream) return endOfStream;
	hasRequiredEndOfStream = 1;
	var once = requireOnce();
	var noop = function() {
	};
	var qnt = globalThis.Bare ? queueMicrotask : process$1.nextTick.bind(process$1);
	var isRequest = function(stream) {
	  return stream.setHeader && typeof stream.abort === "function";
	};
	var isChildProcess = function(stream) {
	  return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
	};
	var eos = function(stream, opts, callback) {
	  if (typeof opts === "function") return eos(stream, null, opts);
	  if (!opts) opts = {};
	  callback = once(callback || noop);
	  var ws = stream._writableState;
	  var rs = stream._readableState;
	  var readable = opts.readable || opts.readable !== false && stream.readable;
	  var writable = opts.writable || opts.writable !== false && stream.writable;
	  var cancelled = false;
	  var onlegacyfinish = function() {
	    if (!stream.writable) onfinish();
	  };
	  var onfinish = function() {
	    writable = false;
	    if (!readable) callback.call(stream);
	  };
	  var onend = function() {
	    readable = false;
	    if (!writable) callback.call(stream);
	  };
	  var onexit = function(exitCode) {
	    callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
	  };
	  var onerror = function(err) {
	    callback.call(stream, err);
	  };
	  var onclose = function() {
	    qnt(onclosenexttick);
	  };
	  var onclosenexttick = function() {
	    if (cancelled) return;
	    if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error("premature close"));
	    if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error("premature close"));
	  };
	  var onrequest = function() {
	    stream.req.on("finish", onfinish);
	  };
	  if (isRequest(stream)) {
	    stream.on("complete", onfinish);
	    stream.on("abort", onclose);
	    if (stream.req) onrequest();
	    else stream.on("request", onrequest);
	  } else if (writable && !ws) {
	    stream.on("end", onlegacyfinish);
	    stream.on("close", onlegacyfinish);
	  }
	  if (isChildProcess(stream)) stream.on("exit", onexit);
	  stream.on("end", onend);
	  stream.on("finish", onfinish);
	  if (opts.error !== false) stream.on("error", onerror);
	  stream.on("close", onclose);
	  return function() {
	    cancelled = true;
	    stream.removeListener("complete", onfinish);
	    stream.removeListener("abort", onclose);
	    stream.removeListener("request", onrequest);
	    if (stream.req) stream.req.removeListener("finish", onfinish);
	    stream.removeListener("end", onlegacyfinish);
	    stream.removeListener("close", onlegacyfinish);
	    stream.removeListener("finish", onfinish);
	    stream.removeListener("exit", onexit);
	    stream.removeListener("end", onend);
	    stream.removeListener("error", onerror);
	    stream.removeListener("close", onclose);
	  };
	};
	endOfStream = eos;
	return endOfStream;
}

var empty = null;

const empty$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: empty
}, Symbol.toStringTag, { value: 'Module' }));

const require$$0$1 = /*@__PURE__*/getAugmentedNamespace(empty$1);

var pump_1;
var hasRequiredPump;

function requirePump () {
	if (hasRequiredPump) return pump_1;
	hasRequiredPump = 1;
	var once = requireOnce();
	var eos = requireEndOfStream();
	var fs;

	try {
	  fs = require$$0$1; // we only need fs to get the ReadStream and WriteStream prototypes
	} catch (e) {}

	var noop = function () {};
	var ancient = typeof process$1 === 'undefined' ? false : /^v?\.0/.test(process$1.version);

	var isFn = function (fn) {
	  return typeof fn === 'function'
	};

	var isFS = function (stream) {
	  if (!ancient) return false // newer node version do not need to care about fs is a special way
	  if (!fs) return false // browser
	  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
	};

	var isRequest = function (stream) {
	  return stream.setHeader && isFn(stream.abort)
	};

	var destroyer = function (stream, reading, writing, callback) {
	  callback = once(callback);

	  var closed = false;
	  stream.on('close', function () {
	    closed = true;
	  });

	  eos(stream, {readable: reading, writable: writing}, function (err) {
	    if (err) return callback(err)
	    closed = true;
	    callback();
	  });

	  var destroyed = false;
	  return function (err) {
	    if (closed) return
	    if (destroyed) return
	    destroyed = true;

	    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
	    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

	    if (isFn(stream.destroy)) return stream.destroy()

	    callback(err || new Error('stream was destroyed'));
	  }
	};

	var call = function (fn) {
	  fn();
	};

	var pipe = function (from, to) {
	  return from.pipe(to)
	};

	var pump = function () {
	  var streams = Array.prototype.slice.call(arguments);
	  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;

	  if (Array.isArray(streams[0])) streams = streams[0];
	  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

	  var error;
	  var destroys = streams.map(function (stream, i) {
	    var reading = i < streams.length - 1;
	    var writing = i > 0;
	    return destroyer(stream, reading, writing, function (err) {
	      if (!error) error = err;
	      if (err) destroys.forEach(call);
	      if (reading) return
	      destroys.forEach(call);
	      callback(error);
	    })
	  });

	  return streams.reduce(pipe)
	};

	pump_1 = pump;
	return pump_1;
}

/*
Copyright (c) 2014-2021, Matteo Collina <hello@matteocollina.com>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

var split2;
var hasRequiredSplit2;

function requireSplit2 () {
	if (hasRequiredSplit2) return split2;
	hasRequiredSplit2 = 1;

	const { Transform } = requireStreamBrowserify();
	const { StringDecoder } = requireString_decoder();
	const kLast = Symbol('last');
	const kDecoder = Symbol('decoder');

	function transform (chunk, enc, cb) {
	  let list;
	  if (this.overflow) { // Line buffer is full. Skip to start of next line.
	    const buf = this[kDecoder].write(chunk);
	    list = buf.split(this.matcher);

	    if (list.length === 1) return cb() // Line ending not found. Discard entire chunk.

	    // Line ending found. Discard trailing fragment of previous line and reset overflow state.
	    list.shift();
	    this.overflow = false;
	  } else {
	    this[kLast] += this[kDecoder].write(chunk);
	    list = this[kLast].split(this.matcher);
	  }

	  this[kLast] = list.pop();

	  for (let i = 0; i < list.length; i++) {
	    try {
	      push(this, this.mapper(list[i]));
	    } catch (error) {
	      return cb(error)
	    }
	  }

	  this.overflow = this[kLast].length > this.maxLength;
	  if (this.overflow && !this.skipOverflow) {
	    cb(new Error('maximum buffer reached'));
	    return
	  }

	  cb();
	}

	function flush (cb) {
	  // forward any gibberish left in there
	  this[kLast] += this[kDecoder].end();

	  if (this[kLast]) {
	    try {
	      push(this, this.mapper(this[kLast]));
	    } catch (error) {
	      return cb(error)
	    }
	  }

	  cb();
	}

	function push (self, val) {
	  if (val !== undefined) {
	    self.push(val);
	  }
	}

	function noop (incoming) {
	  return incoming
	}

	function split (matcher, mapper, options) {
	  // Set defaults for any arguments not supplied.
	  matcher = matcher || /\r?\n/;
	  mapper = mapper || noop;
	  options = options || {};

	  // Test arguments explicitly.
	  switch (arguments.length) {
	    case 1:
	      // If mapper is only argument.
	      if (typeof matcher === 'function') {
	        mapper = matcher;
	        matcher = /\r?\n/;
	      // If options is only argument.
	      } else if (typeof matcher === 'object' && !(matcher instanceof RegExp) && !matcher[Symbol.split]) {
	        options = matcher;
	        matcher = /\r?\n/;
	      }
	      break

	    case 2:
	      // If mapper and options are arguments.
	      if (typeof matcher === 'function') {
	        options = mapper;
	        mapper = matcher;
	        matcher = /\r?\n/;
	      // If matcher and options are arguments.
	      } else if (typeof mapper === 'object') {
	        options = mapper;
	        mapper = noop;
	      }
	  }

	  options = Object.assign({}, options);
	  options.autoDestroy = true;
	  options.transform = transform;
	  options.flush = flush;
	  options.readableObjectMode = true;

	  const stream = new Transform(options);

	  stream[kLast] = '';
	  stream[kDecoder] = new StringDecoder('utf8');
	  stream.matcher = matcher;
	  stream.mapper = mapper;
	  stream.maxLength = options.maxLength;
	  stream.skipOverflow = options.skipOverflow || false;
	  stream.overflow = false;
	  stream._destroy = function (err, cb) {
	    // Weird Node v12 bug that we need to work around
	    this._writableState.errorEmitted = false;
	    cb(err);
	  };

	  return stream
	}

	split2 = split;
	return split2;
}

const __viteBrowserExternal = {};

const __viteBrowserExternal$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: 'Module' }));

const require$$0 = /*@__PURE__*/getAugmentedNamespace(__viteBrowserExternal$1);

var pinoAbstractTransport;
var hasRequiredPinoAbstractTransport;

function requirePinoAbstractTransport () {
	if (hasRequiredPinoAbstractTransport) return pinoAbstractTransport;
	hasRequiredPinoAbstractTransport = 1;

	const metadata = Symbol.for('pino.metadata');
	const split = requireSplit2();
	const { Duplex } = requireStreamBrowserify();
	const { parentPort, workerData } = require$$0;

	function createDeferred () {
	  let resolve;
	  let reject;
	  const promise = new Promise((_resolve, _reject) => {
	    resolve = _resolve;
	    reject = _reject;
	  });
	  promise.resolve = resolve;
	  promise.reject = reject;
	  return promise
	}

	pinoAbstractTransport = function build (fn, opts = {}) {
	  const waitForConfig = opts.expectPinoConfig === true && workerData?.workerData?.pinoWillSendConfig === true;
	  const parseLines = opts.parse === 'lines';
	  const parseLine = typeof opts.parseLine === 'function' ? opts.parseLine : JSON.parse;
	  const close = opts.close || defaultClose;
	  const stream = split(function (line) {
	    let value;

	    try {
	      value = parseLine(line);
	    } catch (error) {
	      this.emit('unknown', line, error);
	      return
	    }

	    if (value === null) {
	      this.emit('unknown', line, 'Null value ignored');
	      return
	    }

	    if (typeof value !== 'object') {
	      value = {
	        data: value,
	        time: Date.now()
	      };
	    }

	    if (stream[metadata]) {
	      stream.lastTime = value.time;
	      stream.lastLevel = value.level;
	      stream.lastObj = value;
	    }

	    if (parseLines) {
	      return line
	    }

	    return value
	  }, { autoDestroy: true });

	  stream._destroy = function (err, cb) {
	    const promise = close(err, cb);
	    if (promise && typeof promise.then === 'function') {
	      promise.then(cb, cb);
	    }
	  };

	  if (opts.expectPinoConfig === true && workerData?.workerData?.pinoWillSendConfig !== true) {
	    setImmediate(() => {
	      stream.emit('error', new Error('This transport is not compatible with the current version of pino. Please upgrade pino to the latest version.'));
	    });
	  }

	  if (opts.metadata !== false) {
	    stream[metadata] = true;
	    stream.lastTime = 0;
	    stream.lastLevel = 0;
	    stream.lastObj = null;
	  }

	  if (waitForConfig) {
	    let pinoConfig = {};
	    const configReceived = createDeferred();
	    parentPort.on('message', function handleMessage (message) {
	      if (message.code === 'PINO_CONFIG') {
	        pinoConfig = message.config;
	        configReceived.resolve();
	        parentPort.off('message', handleMessage);
	      }
	    });

	    Object.defineProperties(stream, {
	      levels: {
	        get () { return pinoConfig.levels }
	      },
	      messageKey: {
	        get () { return pinoConfig.messageKey }
	      },
	      errorKey: {
	        get () { return pinoConfig.errorKey }
	      }
	    });

	    return configReceived.then(finish)
	  }

	  return finish()

	  function finish () {
	    let res = fn(stream);

	    if (res && typeof res.catch === 'function') {
	      res.catch((err) => {
	        stream.destroy(err);
	      });

	      // set it to null to not retain a reference to the promise
	      res = null;
	    } else if (opts.enablePipelining && res) {
	      return Duplex.from({ writable: stream, readable: res })
	    }

	    return stream
	  }
	};

	function defaultClose (err, cb) {
	  process$1.nextTick(cb, err);
	}
	return pinoAbstractTransport;
}

var constants;
var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;

	/**
	 * A set of property names that indicate the value represents an error object.
	 *
	 * @typedef {string[]} K_ERROR_LIKE_KEYS
	 */

	constants = {
	  DATE_FORMAT: 'yyyy-mm-dd HH:MM:ss.l o',
	  DATE_FORMAT_SIMPLE: 'HH:MM:ss.l',

	  /**
	   * @type {K_ERROR_LIKE_KEYS}
	   */
	  ERROR_LIKE_KEYS: ['err', 'error'],

	  MESSAGE_KEY: 'msg',

	  LEVEL_KEY: 'level',

	  LEVEL_LABEL: 'levelLabel',

	  TIMESTAMP_KEY: 'time',

	  LEVELS: {
	    default: 'USERLVL',
	    60: 'FATAL',
	    50: 'ERROR',
	    40: 'WARN',
	    30: 'INFO',
	    20: 'DEBUG',
	    10: 'TRACE'
	  },

	  LEVEL_NAMES: {
	    fatal: 60,
	    error: 50,
	    warn: 40,
	    info: 30,
	    debug: 20,
	    trace: 10
	  },

	  // Object keys that probably came from a logger like Pino or Bunyan.
	  LOGGER_KEYS: [
	    'pid',
	    'hostname',
	    'name',
	    'level',
	    'time',
	    'timestamp',
	    'caller'
	  ]
	};
	return constants;
}

var getLevelLabelData_1;
var hasRequiredGetLevelLabelData;

function requireGetLevelLabelData () {
	if (hasRequiredGetLevelLabelData) return getLevelLabelData_1;
	hasRequiredGetLevelLabelData = 1;

	getLevelLabelData_1 = getLevelLabelData;
	const { LEVELS, LEVEL_NAMES } = requireConstants();

	/**
	 * Given initial settings for custom levels/names and use of only custom props
	 * get the level label that corresponds with a given level number
	 *
	 * @param {boolean} useOnlyCustomProps
	 * @param {object} customLevels
	 * @param {object} customLevelNames
	 *
	 * @returns {function} A function that takes a number level and returns the level's label string
	 */
	function getLevelLabelData (useOnlyCustomProps, customLevels, customLevelNames) {
	  const levels = useOnlyCustomProps ? customLevels || LEVELS : Object.assign({}, LEVELS, customLevels);
	  const levelNames = useOnlyCustomProps ? customLevelNames || LEVEL_NAMES : Object.assign({}, LEVEL_NAMES, customLevelNames);
	  return function (level) {
	    let levelNum = 'default';
	    if (Number.isInteger(+level)) {
	      levelNum = Object.prototype.hasOwnProperty.call(levels, level) ? level : levelNum;
	    } else {
	      levelNum = Object.prototype.hasOwnProperty.call(levelNames, level.toLowerCase()) ? levelNames[level.toLowerCase()] : levelNum;
	    }

	    return [levels[levelNum], levelNum]
	  }
	}
	return getLevelLabelData_1;
}

var colors;
var hasRequiredColors;

function requireColors () {
	if (hasRequiredColors) return colors;
	hasRequiredColors = 1;

	const nocolor = input => input;
	const plain = {
	  default: nocolor,
	  60: nocolor,
	  50: nocolor,
	  40: nocolor,
	  30: nocolor,
	  20: nocolor,
	  10: nocolor,
	  message: nocolor,
	  greyMessage: nocolor
	};

	const { createColors } = requireColorette();
	const getLevelLabelData = requireGetLevelLabelData();
	const availableColors = createColors({ useColor: true });
	const { white, bgRed, red, yellow, green, blue, gray, cyan } = availableColors;

	const colored = {
	  default: white,
	  60: bgRed,
	  50: red,
	  40: yellow,
	  30: green,
	  20: blue,
	  10: gray,
	  message: cyan,
	  greyMessage: gray
	};

	function resolveCustomColoredColorizer (customColors) {
	  return customColors.reduce(
	    function (agg, [level, color]) {
	      agg[level] = typeof availableColors[color] === 'function' ? availableColors[color] : white;

	      return agg
	    },
	    { default: white, message: cyan, greyMessage: gray }
	  )
	}

	function colorizeLevel (useOnlyCustomProps) {
	  return function (level, colorizer, { customLevels, customLevelNames } = {}) {
	    const [levelStr, levelNum] = getLevelLabelData(useOnlyCustomProps, customLevels, customLevelNames)(level);

	    return Object.prototype.hasOwnProperty.call(colorizer, levelNum) ? colorizer[levelNum](levelStr) : colorizer.default(levelStr)
	  }
	}

	function plainColorizer (useOnlyCustomProps) {
	  const newPlainColorizer = colorizeLevel(useOnlyCustomProps);
	  const customColoredColorizer = function (level, opts) {
	    return newPlainColorizer(level, plain, opts)
	  };
	  customColoredColorizer.message = plain.message;
	  customColoredColorizer.greyMessage = plain.greyMessage;
	  customColoredColorizer.colors = createColors({ useColor: false });
	  return customColoredColorizer
	}

	function coloredColorizer (useOnlyCustomProps) {
	  const newColoredColorizer = colorizeLevel(useOnlyCustomProps);
	  const customColoredColorizer = function (level, opts) {
	    return newColoredColorizer(level, colored, opts)
	  };
	  customColoredColorizer.message = colored.message;
	  customColoredColorizer.greyMessage = colored.greyMessage;
	  customColoredColorizer.colors = availableColors;
	  return customColoredColorizer
	}

	function customColoredColorizerFactory (customColors, useOnlyCustomProps) {
	  const onlyCustomColored = resolveCustomColoredColorizer(customColors);
	  const customColored = useOnlyCustomProps ? onlyCustomColored : Object.assign({}, colored, onlyCustomColored);
	  const colorizeLevelCustom = colorizeLevel(useOnlyCustomProps);

	  const customColoredColorizer = function (level, opts) {
	    return colorizeLevelCustom(level, customColored, opts)
	  };
	  customColoredColorizer.colors = availableColors;
	  customColoredColorizer.message = customColoredColorizer.message || customColored.message;
	  customColoredColorizer.greyMessage = customColoredColorizer.greyMessage || customColored.greyMessage;

	  return customColoredColorizer
	}

	/**
	 * Applies colorization, if possible, to a string representing the passed in
	 * `level`. For example, the default colorizer will return a "green" colored
	 * string for the "info" level.
	 *
	 * @typedef {function} ColorizerFunc
	 * @param {string|number} level In either case, the input will map to a color
	 * for the specified level or to the color for `USERLVL` if the level is not
	 * recognized.
	 * @property {function} message Accepts one string parameter that will be
	 * colorized to a predefined color.
	 * @property {Colorette.Colorette} colors Available color functions based on `useColor` (or `colorize`) context
	 */

	/**
	 * Factory function get a function to colorized levels. The returned function
	 * also includes a `.message(str)` method to colorize strings.
	 *
	 * @param {boolean} [useColors=false] When `true` a function that applies standard
	 * terminal colors is returned.
	 * @param {array[]} [customColors] Tuple where first item of each array is the
	 * level index and the second item is the color
	 * @param {boolean} [useOnlyCustomProps] When `true`, only use the provided
	 * custom colors provided and not fallback to default
	 *
	 * @returns {ColorizerFunc} `function (level) {}` has a `.message(str)` method to
	 * apply colorization to a string. The core function accepts either an integer
	 * `level` or a `string` level. The integer level will map to a known level
	 * string or to `USERLVL` if not known.  The string `level` will map to the same
	 * colors as the integer `level` and will also default to `USERLVL` if the given
	 * string is not a recognized level name.
	 */
	colors = function getColorizer (useColors = false, customColors, useOnlyCustomProps) {
	  if (useColors && customColors !== undefined) {
	    return customColoredColorizerFactory(customColors, useOnlyCustomProps)
	  } else if (useColors) {
	    return coloredColorizer(useOnlyCustomProps)
	  }

	  return plainColorizer(useOnlyCustomProps)
	};
	return colors;
}

var pathBrowserify;
var hasRequiredPathBrowserify;

function requirePathBrowserify () {
	if (hasRequiredPathBrowserify) return pathBrowserify;
	hasRequiredPathBrowserify = 1;

	function assertPath(path) {
	  if (typeof path !== 'string') {
	    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
	  }
	}

	// Resolves . and .. elements in a path with directory names
	function normalizeStringPosix(path, allowAboveRoot) {
	  var res = '';
	  var lastSegmentLength = 0;
	  var lastSlash = -1;
	  var dots = 0;
	  var code;
	  for (var i = 0; i <= path.length; ++i) {
	    if (i < path.length)
	      code = path.charCodeAt(i);
	    else if (code === 47 /*/*/)
	      break;
	    else
	      code = 47 /*/*/;
	    if (code === 47 /*/*/) {
	      if (lastSlash === i - 1 || dots === 1) ; else if (lastSlash !== i - 1 && dots === 2) {
	        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
	          if (res.length > 2) {
	            var lastSlashIndex = res.lastIndexOf('/');
	            if (lastSlashIndex !== res.length - 1) {
	              if (lastSlashIndex === -1) {
	                res = '';
	                lastSegmentLength = 0;
	              } else {
	                res = res.slice(0, lastSlashIndex);
	                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
	              }
	              lastSlash = i;
	              dots = 0;
	              continue;
	            }
	          } else if (res.length === 2 || res.length === 1) {
	            res = '';
	            lastSegmentLength = 0;
	            lastSlash = i;
	            dots = 0;
	            continue;
	          }
	        }
	        if (allowAboveRoot) {
	          if (res.length > 0)
	            res += '/..';
	          else
	            res = '..';
	          lastSegmentLength = 2;
	        }
	      } else {
	        if (res.length > 0)
	          res += '/' + path.slice(lastSlash + 1, i);
	        else
	          res = path.slice(lastSlash + 1, i);
	        lastSegmentLength = i - lastSlash - 1;
	      }
	      lastSlash = i;
	      dots = 0;
	    } else if (code === 46 /*.*/ && dots !== -1) {
	      ++dots;
	    } else {
	      dots = -1;
	    }
	  }
	  return res;
	}

	function _format(sep, pathObject) {
	  var dir = pathObject.dir || pathObject.root;
	  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
	  if (!dir) {
	    return base;
	  }
	  if (dir === pathObject.root) {
	    return dir + base;
	  }
	  return dir + sep + base;
	}

	var posix = {
	  // path.resolve([from ...], to)
	  resolve: function resolve() {
	    var resolvedPath = '';
	    var resolvedAbsolute = false;
	    var cwd;

	    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	      var path;
	      if (i >= 0)
	        path = arguments[i];
	      else {
	        if (cwd === undefined)
	          cwd = process$1.cwd();
	        path = cwd;
	      }

	      assertPath(path);

	      // Skip empty entries
	      if (path.length === 0) {
	        continue;
	      }

	      resolvedPath = path + '/' + resolvedPath;
	      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
	    }

	    // At this point the path should be resolved to a full absolute path, but
	    // handle relative paths to be safe (might happen when process.cwd() fails)

	    // Normalize the path
	    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

	    if (resolvedAbsolute) {
	      if (resolvedPath.length > 0)
	        return '/' + resolvedPath;
	      else
	        return '/';
	    } else if (resolvedPath.length > 0) {
	      return resolvedPath;
	    } else {
	      return '.';
	    }
	  },

	  normalize: function normalize(path) {
	    assertPath(path);

	    if (path.length === 0) return '.';

	    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
	    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

	    // Normalize the path
	    path = normalizeStringPosix(path, !isAbsolute);

	    if (path.length === 0 && !isAbsolute) path = '.';
	    if (path.length > 0 && trailingSeparator) path += '/';

	    if (isAbsolute) return '/' + path;
	    return path;
	  },

	  isAbsolute: function isAbsolute(path) {
	    assertPath(path);
	    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
	  },

	  join: function join() {
	    if (arguments.length === 0)
	      return '.';
	    var joined;
	    for (var i = 0; i < arguments.length; ++i) {
	      var arg = arguments[i];
	      assertPath(arg);
	      if (arg.length > 0) {
	        if (joined === undefined)
	          joined = arg;
	        else
	          joined += '/' + arg;
	      }
	    }
	    if (joined === undefined)
	      return '.';
	    return posix.normalize(joined);
	  },

	  relative: function relative(from, to) {
	    assertPath(from);
	    assertPath(to);

	    if (from === to) return '';

	    from = posix.resolve(from);
	    to = posix.resolve(to);

	    if (from === to) return '';

	    // Trim any leading backslashes
	    var fromStart = 1;
	    for (; fromStart < from.length; ++fromStart) {
	      if (from.charCodeAt(fromStart) !== 47 /*/*/)
	        break;
	    }
	    var fromEnd = from.length;
	    var fromLen = fromEnd - fromStart;

	    // Trim any leading backslashes
	    var toStart = 1;
	    for (; toStart < to.length; ++toStart) {
	      if (to.charCodeAt(toStart) !== 47 /*/*/)
	        break;
	    }
	    var toEnd = to.length;
	    var toLen = toEnd - toStart;

	    // Compare paths to find the longest common path from root
	    var length = fromLen < toLen ? fromLen : toLen;
	    var lastCommonSep = -1;
	    var i = 0;
	    for (; i <= length; ++i) {
	      if (i === length) {
	        if (toLen > length) {
	          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
	            // We get here if `from` is the exact base path for `to`.
	            // For example: from='/foo/bar'; to='/foo/bar/baz'
	            return to.slice(toStart + i + 1);
	          } else if (i === 0) {
	            // We get here if `from` is the root
	            // For example: from='/'; to='/foo'
	            return to.slice(toStart + i);
	          }
	        } else if (fromLen > length) {
	          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
	            // We get here if `to` is the exact base path for `from`.
	            // For example: from='/foo/bar/baz'; to='/foo/bar'
	            lastCommonSep = i;
	          } else if (i === 0) {
	            // We get here if `to` is the root.
	            // For example: from='/foo'; to='/'
	            lastCommonSep = 0;
	          }
	        }
	        break;
	      }
	      var fromCode = from.charCodeAt(fromStart + i);
	      var toCode = to.charCodeAt(toStart + i);
	      if (fromCode !== toCode)
	        break;
	      else if (fromCode === 47 /*/*/)
	        lastCommonSep = i;
	    }

	    var out = '';
	    // Generate the relative path based on the path difference between `to`
	    // and `from`
	    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
	      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
	        if (out.length === 0)
	          out += '..';
	        else
	          out += '/..';
	      }
	    }

	    // Lastly, append the rest of the destination (`to`) path that comes after
	    // the common path parts
	    if (out.length > 0)
	      return out + to.slice(toStart + lastCommonSep);
	    else {
	      toStart += lastCommonSep;
	      if (to.charCodeAt(toStart) === 47 /*/*/)
	        ++toStart;
	      return to.slice(toStart);
	    }
	  },

	  _makeLong: function _makeLong(path) {
	    return path;
	  },

	  dirname: function dirname(path) {
	    assertPath(path);
	    if (path.length === 0) return '.';
	    var code = path.charCodeAt(0);
	    var hasRoot = code === 47 /*/*/;
	    var end = -1;
	    var matchedSlash = true;
	    for (var i = path.length - 1; i >= 1; --i) {
	      code = path.charCodeAt(i);
	      if (code === 47 /*/*/) {
	          if (!matchedSlash) {
	            end = i;
	            break;
	          }
	        } else {
	        // We saw the first non-path separator
	        matchedSlash = false;
	      }
	    }

	    if (end === -1) return hasRoot ? '/' : '.';
	    if (hasRoot && end === 1) return '//';
	    return path.slice(0, end);
	  },

	  basename: function basename(path, ext) {
	    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
	    assertPath(path);

	    var start = 0;
	    var end = -1;
	    var matchedSlash = true;
	    var i;

	    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
	      if (ext.length === path.length && ext === path) return '';
	      var extIdx = ext.length - 1;
	      var firstNonSlashEnd = -1;
	      for (i = path.length - 1; i >= 0; --i) {
	        var code = path.charCodeAt(i);
	        if (code === 47 /*/*/) {
	            // If we reached a path separator that was not part of a set of path
	            // separators at the end of the string, stop now
	            if (!matchedSlash) {
	              start = i + 1;
	              break;
	            }
	          } else {
	          if (firstNonSlashEnd === -1) {
	            // We saw the first non-path separator, remember this index in case
	            // we need it if the extension ends up not matching
	            matchedSlash = false;
	            firstNonSlashEnd = i + 1;
	          }
	          if (extIdx >= 0) {
	            // Try to match the explicit extension
	            if (code === ext.charCodeAt(extIdx)) {
	              if (--extIdx === -1) {
	                // We matched the extension, so mark this as the end of our path
	                // component
	                end = i;
	              }
	            } else {
	              // Extension does not match, so our result is the entire path
	              // component
	              extIdx = -1;
	              end = firstNonSlashEnd;
	            }
	          }
	        }
	      }

	      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
	      return path.slice(start, end);
	    } else {
	      for (i = path.length - 1; i >= 0; --i) {
	        if (path.charCodeAt(i) === 47 /*/*/) {
	            // If we reached a path separator that was not part of a set of path
	            // separators at the end of the string, stop now
	            if (!matchedSlash) {
	              start = i + 1;
	              break;
	            }
	          } else if (end === -1) {
	          // We saw the first non-path separator, mark this as the end of our
	          // path component
	          matchedSlash = false;
	          end = i + 1;
	        }
	      }

	      if (end === -1) return '';
	      return path.slice(start, end);
	    }
	  },

	  extname: function extname(path) {
	    assertPath(path);
	    var startDot = -1;
	    var startPart = 0;
	    var end = -1;
	    var matchedSlash = true;
	    // Track the state of characters (if any) we see before our first dot and
	    // after any path separator we find
	    var preDotState = 0;
	    for (var i = path.length - 1; i >= 0; --i) {
	      var code = path.charCodeAt(i);
	      if (code === 47 /*/*/) {
	          // If we reached a path separator that was not part of a set of path
	          // separators at the end of the string, stop now
	          if (!matchedSlash) {
	            startPart = i + 1;
	            break;
	          }
	          continue;
	        }
	      if (end === -1) {
	        // We saw the first non-path separator, mark this as the end of our
	        // extension
	        matchedSlash = false;
	        end = i + 1;
	      }
	      if (code === 46 /*.*/) {
	          // If this is our first dot, mark it as the start of our extension
	          if (startDot === -1)
	            startDot = i;
	          else if (preDotState !== 1)
	            preDotState = 1;
	      } else if (startDot !== -1) {
	        // We saw a non-dot and non-path separator before our dot, so we should
	        // have a good chance at having a non-empty extension
	        preDotState = -1;
	      }
	    }

	    if (startDot === -1 || end === -1 ||
	        // We saw a non-dot character immediately before the dot
	        preDotState === 0 ||
	        // The (right-most) trimmed path component is exactly '..'
	        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
	      return '';
	    }
	    return path.slice(startDot, end);
	  },

	  format: function format(pathObject) {
	    if (pathObject === null || typeof pathObject !== 'object') {
	      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
	    }
	    return _format('/', pathObject);
	  },

	  parse: function parse(path) {
	    assertPath(path);

	    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
	    if (path.length === 0) return ret;
	    var code = path.charCodeAt(0);
	    var isAbsolute = code === 47 /*/*/;
	    var start;
	    if (isAbsolute) {
	      ret.root = '/';
	      start = 1;
	    } else {
	      start = 0;
	    }
	    var startDot = -1;
	    var startPart = 0;
	    var end = -1;
	    var matchedSlash = true;
	    var i = path.length - 1;

	    // Track the state of characters (if any) we see before our first dot and
	    // after any path separator we find
	    var preDotState = 0;

	    // Get non-dir info
	    for (; i >= start; --i) {
	      code = path.charCodeAt(i);
	      if (code === 47 /*/*/) {
	          // If we reached a path separator that was not part of a set of path
	          // separators at the end of the string, stop now
	          if (!matchedSlash) {
	            startPart = i + 1;
	            break;
	          }
	          continue;
	        }
	      if (end === -1) {
	        // We saw the first non-path separator, mark this as the end of our
	        // extension
	        matchedSlash = false;
	        end = i + 1;
	      }
	      if (code === 46 /*.*/) {
	          // If this is our first dot, mark it as the start of our extension
	          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
	        } else if (startDot !== -1) {
	        // We saw a non-dot and non-path separator before our dot, so we should
	        // have a good chance at having a non-empty extension
	        preDotState = -1;
	      }
	    }

	    if (startDot === -1 || end === -1 ||
	    // We saw a non-dot character immediately before the dot
	    preDotState === 0 ||
	    // The (right-most) trimmed path component is exactly '..'
	    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
	      if (end !== -1) {
	        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
	      }
	    } else {
	      if (startPart === 0 && isAbsolute) {
	        ret.name = path.slice(1, startDot);
	        ret.base = path.slice(1, end);
	      } else {
	        ret.name = path.slice(startPart, startDot);
	        ret.base = path.slice(startPart, end);
	      }
	      ret.ext = path.slice(startDot, end);
	    }

	    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

	    return ret;
	  },

	  sep: '/',
	  delimiter: ':',
	  win32: null,
	  posix: null
	};

	posix.posix = posix;

	pathBrowserify = posix;
	return pathBrowserify;
}

var atomicSleep = {exports: {}};

var hasRequiredAtomicSleep;

function requireAtomicSleep () {
	if (hasRequiredAtomicSleep) return atomicSleep.exports;
	hasRequiredAtomicSleep = 1;
	if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
	  let sleep = function(ms) {
	    const valid = ms > 0 && ms < Infinity;
	    if (valid === false) {
	      if (typeof ms !== "number" && typeof ms !== "bigint") {
	        throw TypeError("sleep: ms must be a number");
	      }
	      throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
	    }
	    Atomics.wait(nil, 0, 0, Number(ms));
	  };
	  const nil = new Int32Array(new SharedArrayBuffer(4));
	  atomicSleep.exports = sleep;
	} else {
	  let sleep = function(ms) {
	    const valid = ms > 0 && ms < Infinity;
	    if (valid === false) {
	      if (typeof ms !== "number" && typeof ms !== "bigint") {
	        throw TypeError("sleep: ms must be a number");
	      }
	      throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
	    }
	  };
	  atomicSleep.exports = sleep;
	}
	return atomicSleep.exports;
}

var assert = {exports: {}};

var errors = {};

var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;

	// The whole point behind this internal module is to allow Node.js to no
	// longer be forced to treat every error message change as a semver-major
	// change. The NodeError classes here all expose a `code` property whose
	// value statically and permanently identifies the error. While the error
	// message may change, the code should not.
	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _createClass(Constructor, protoProps, staticProps) { Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
	var codes = {};

	// Lazy loaded
	var assert;
	var util;
	function createErrorType(code, message, Base) {
	  if (!Base) {
	    Base = Error;
	  }
	  function getMessage(arg1, arg2, arg3) {
	    if (typeof message === 'string') {
	      return message;
	    } else {
	      return message(arg1, arg2, arg3);
	    }
	  }
	  var NodeError = /*#__PURE__*/function (_Base) {
	    _inherits(NodeError, _Base);
	    var _super = _createSuper(NodeError);
	    function NodeError(arg1, arg2, arg3) {
	      var _this;
	      _classCallCheck(this, NodeError);
	      _this = _super.call(this, getMessage(arg1, arg2, arg3));
	      _this.code = code;
	      return _this;
	    }
	    return _createClass(NodeError);
	  }(Base);
	  codes[code] = NodeError;
	}

	// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
	function oneOf(expected, thing) {
	  if (Array.isArray(expected)) {
	    var len = expected.length;
	    expected = expected.map(function (i) {
	      return String(i);
	    });
	    if (len > 2) {
	      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
	    } else if (len === 2) {
	      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
	    } else {
	      return "of ".concat(thing, " ").concat(expected[0]);
	    }
	  } else {
	    return "of ".concat(thing, " ").concat(String(expected));
	  }
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
	function startsWith(str, search, pos) {
	  return str.substr(0 , search.length) === search;
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
	function endsWith(str, search, this_len) {
	  if (this_len === undefined || this_len > str.length) {
	    this_len = str.length;
	  }
	  return str.substring(this_len - search.length, this_len) === search;
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
	function includes(str, search, start) {
	  if (typeof start !== 'number') {
	    start = 0;
	  }
	  if (start + search.length > str.length) {
	    return false;
	  } else {
	    return str.indexOf(search, start) !== -1;
	  }
	}
	createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
	createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
	  if (assert === undefined) assert = requireAssert();
	  assert(typeof name === 'string', "'name' must be a string");

	  // determiner: 'must be' or 'must not be'
	  var determiner;
	  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
	    determiner = 'must not be';
	    expected = expected.replace(/^not /, '');
	  } else {
	    determiner = 'must be';
	  }
	  var msg;
	  if (endsWith(name, ' argument')) {
	    // For cases like 'first argument'
	    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
	  } else {
	    var type = includes(name, '.') ? 'property' : 'argument';
	    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
	  }

	  // TODO(BridgeAR): Improve the output by showing `null` and similar.
	  msg += ". Received type ".concat(_typeof(actual));
	  return msg;
	}, TypeError);
	createErrorType('ERR_INVALID_ARG_VALUE', function (name, value) {
	  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
	  if (util === undefined) util = requireUtil();
	  var inspected = util.inspect(value);
	  if (inspected.length > 128) {
	    inspected = "".concat(inspected.slice(0, 128), "...");
	  }
	  return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
	}, TypeError);
	createErrorType('ERR_INVALID_RETURN_VALUE', function (input, name, value) {
	  var type;
	  if (value && value.constructor && value.constructor.name) {
	    type = "instance of ".concat(value.constructor.name);
	  } else {
	    type = "type ".concat(_typeof(value));
	  }
	  return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
	}, TypeError);
	createErrorType('ERR_MISSING_ARGS', function () {
	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }
	  if (assert === undefined) assert = requireAssert();
	  assert(args.length > 0, 'At least one arg needs to be specified');
	  var msg = 'The ';
	  var len = args.length;
	  args = args.map(function (a) {
	    return "\"".concat(a, "\"");
	  });
	  switch (len) {
	    case 1:
	      msg += "".concat(args[0], " argument");
	      break;
	    case 2:
	      msg += "".concat(args[0], " and ").concat(args[1], " arguments");
	      break;
	    default:
	      msg += args.slice(0, len - 1).join(', ');
	      msg += ", and ".concat(args[len - 1], " arguments");
	      break;
	  }
	  return "".concat(msg, " must be specified");
	}, TypeError);
	errors.codes = codes;
	return errors;
}

var assertion_error;
var hasRequiredAssertion_error;

function requireAssertion_error () {
	if (hasRequiredAssertion_error) return assertion_error;
	hasRequiredAssertion_error = 1;

	function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
	function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(input); }
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
	function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
	function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
	function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
	function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
	function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
	function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	var _require = requireUtil(),
	  inspect = _require.inspect;
	var _require2 = requireErrors(),
	  ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
	function endsWith(str, search, this_len) {
	  if (this_len === undefined || this_len > str.length) {
	    this_len = str.length;
	  }
	  return str.substring(this_len - search.length, this_len) === search;
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
	function repeat(str, count) {
	  count = Math.floor(count);
	  if (str.length == 0 || count == 0) return '';
	  var maxCount = str.length * count;
	  count = Math.floor(Math.log(count) / Math.log(2));
	  while (count) {
	    str += str;
	    count--;
	  }
	  str += str.substring(0, maxCount - str.length);
	  return str;
	}
	var blue = '';
	var green = '';
	var red = '';
	var white = '';
	var kReadableOperator = {
	  deepStrictEqual: 'Expected values to be strictly deep-equal:',
	  strictEqual: 'Expected values to be strictly equal:',
	  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
	  deepEqual: 'Expected values to be loosely deep-equal:',
	  equal: 'Expected values to be loosely equal:',
	  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
	  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
	  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
	  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
	  notEqual: 'Expected "actual" to be loosely unequal to:',
	  notIdentical: 'Values identical but not reference-equal:'
	};

	// Comparing short primitives should just show === / !== instead of using the
	// diff.
	var kMaxShortLength = 10;
	function copyError(source) {
	  var keys = Object.keys(source);
	  var target = Object.create(Object.getPrototypeOf(source));
	  keys.forEach(function (key) {
	    target[key] = source[key];
	  });
	  Object.defineProperty(target, 'message', {
	    value: source.message
	  });
	  return target;
	}
	function inspectValue(val) {
	  // The util.inspect default values could be changed. This makes sure the
	  // error messages contain the necessary information nevertheless.
	  return inspect(val, {
	    compact: false,
	    customInspect: false,
	    depth: 1000,
	    maxArrayLength: Infinity,
	    // Assert compares only enumerable properties (with a few exceptions).
	    showHidden: false,
	    // Having a long line as error is better than wrapping the line for
	    // comparison for now.
	    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
	    // have meta information about the inspected properties (i.e., know where
	    // in what line the property starts and ends).
	    breakLength: Infinity,
	    // Assert does not detect proxies currently.
	    showProxy: false,
	    sorted: true,
	    // Inspect getters as we also check them when comparing entries.
	    getters: true
	  });
	}
	function createErrDiff(actual, expected, operator) {
	  var other = '';
	  var res = '';
	  var lastPos = 0;
	  var end = '';
	  var skipped = false;
	  var actualInspected = inspectValue(actual);
	  var actualLines = actualInspected.split('\n');
	  var expectedLines = inspectValue(expected).split('\n');
	  var i = 0;
	  var indicator = '';

	  // In case both values are objects explicitly mark them as not reference equal
	  // for the `strictEqual` operator.
	  if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
	    operator = 'strictEqualObject';
	  }

	  // If "actual" and "expected" fit on a single line and they are not strictly
	  // equal, check further special handling.
	  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
	    var inputLength = actualLines[0].length + expectedLines[0].length;
	    // If the character length of "actual" and "expected" together is less than
	    // kMaxShortLength and if neither is an object and at least one of them is
	    // not `zero`, use the strict equal comparison to visualize the output.
	    if (inputLength <= kMaxShortLength) {
	      if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
	        // -0 === +0
	        return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
	      }
	    } else if (operator !== 'strictEqualObject') {
	      // If the stderr is a tty and the input length is lower than the current
	      // columns per line, add a mismatch indicator below the output. If it is
	      // not a tty, use a default value of 80 characters.
	      var maxLength = process$1.stderr && process$1.stderr.isTTY ? process$1.stderr.columns : 80;
	      if (inputLength < maxLength) {
	        while (actualLines[0][i] === expectedLines[0][i]) {
	          i++;
	        }
	        // Ignore the first characters.
	        if (i > 2) {
	          // Add position indicator for the first mismatch in case it is a
	          // single line and the input length is less than the column length.
	          indicator = "\n  ".concat(repeat(' ', i), "^");
	          i = 0;
	        }
	      }
	    }
	  }

	  // Remove all ending lines that match (this optimizes the output for
	  // readability by reducing the number of total changed lines).
	  var a = actualLines[actualLines.length - 1];
	  var b = expectedLines[expectedLines.length - 1];
	  while (a === b) {
	    if (i++ < 2) {
	      end = "\n  ".concat(a).concat(end);
	    } else {
	      other = a;
	    }
	    actualLines.pop();
	    expectedLines.pop();
	    if (actualLines.length === 0 || expectedLines.length === 0) break;
	    a = actualLines[actualLines.length - 1];
	    b = expectedLines[expectedLines.length - 1];
	  }
	  var maxLines = Math.max(actualLines.length, expectedLines.length);
	  // Strict equal with identical objects that are not identical by reference.
	  // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
	  if (maxLines === 0) {
	    // We have to get the result again. The lines were all removed before.
	    var _actualLines = actualInspected.split('\n');

	    // Only remove lines in case it makes sense to collapse those.
	    // TODO: Accept env to always show the full error.
	    if (_actualLines.length > 30) {
	      _actualLines[26] = "".concat(blue, "...").concat(white);
	      while (_actualLines.length > 27) {
	        _actualLines.pop();
	      }
	    }
	    return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
	  }
	  if (i > 3) {
	    end = "\n".concat(blue, "...").concat(white).concat(end);
	    skipped = true;
	  }
	  if (other !== '') {
	    end = "\n  ".concat(other).concat(end);
	    other = '';
	  }
	  var printedLines = 0;
	  var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
	  var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
	  for (i = 0; i < maxLines; i++) {
	    // Only extra expected lines exist
	    var cur = i - lastPos;
	    if (actualLines.length < i + 1) {
	      // If the last diverging line is more than one line above and the
	      // current line is at least line three, add some of the former lines and
	      // also add dots to indicate skipped entries.
	      if (cur > 1 && i > 2) {
	        if (cur > 4) {
	          res += "\n".concat(blue, "...").concat(white);
	          skipped = true;
	        } else if (cur > 3) {
	          res += "\n  ".concat(expectedLines[i - 2]);
	          printedLines++;
	        }
	        res += "\n  ".concat(expectedLines[i - 1]);
	        printedLines++;
	      }
	      // Mark the current line as the last diverging one.
	      lastPos = i;
	      // Add the expected line to the cache.
	      other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
	      printedLines++;
	      // Only extra actual lines exist
	    } else if (expectedLines.length < i + 1) {
	      // If the last diverging line is more than one line above and the
	      // current line is at least line three, add some of the former lines and
	      // also add dots to indicate skipped entries.
	      if (cur > 1 && i > 2) {
	        if (cur > 4) {
	          res += "\n".concat(blue, "...").concat(white);
	          skipped = true;
	        } else if (cur > 3) {
	          res += "\n  ".concat(actualLines[i - 2]);
	          printedLines++;
	        }
	        res += "\n  ".concat(actualLines[i - 1]);
	        printedLines++;
	      }
	      // Mark the current line as the last diverging one.
	      lastPos = i;
	      // Add the actual line to the result.
	      res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
	      printedLines++;
	      // Lines diverge
	    } else {
	      var expectedLine = expectedLines[i];
	      var actualLine = actualLines[i];
	      // If the lines diverge, specifically check for lines that only diverge by
	      // a trailing comma. In that case it is actually identical and we should
	      // mark it as such.
	      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine);
	      // If the expected line has a trailing comma but is otherwise identical,
	      // add a comma at the end of the actual line. Otherwise the output could
	      // look weird as in:
	      //
	      //   [
	      //     1         // No comma at the end!
	      // +   2
	      //   ]
	      //
	      if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
	        divergingLines = false;
	        actualLine += ',';
	      }
	      if (divergingLines) {
	        // If the last diverging line is more than one line above and the
	        // current line is at least line three, add some of the former lines and
	        // also add dots to indicate skipped entries.
	        if (cur > 1 && i > 2) {
	          if (cur > 4) {
	            res += "\n".concat(blue, "...").concat(white);
	            skipped = true;
	          } else if (cur > 3) {
	            res += "\n  ".concat(actualLines[i - 2]);
	            printedLines++;
	          }
	          res += "\n  ".concat(actualLines[i - 1]);
	          printedLines++;
	        }
	        // Mark the current line as the last diverging one.
	        lastPos = i;
	        // Add the actual line to the result and cache the expected diverging
	        // line so consecutive diverging lines show up as +++--- and not +-+-+-.
	        res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
	        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
	        printedLines += 2;
	        // Lines are identical
	      } else {
	        // Add all cached information to the result before adding other things
	        // and reset the cache.
	        res += other;
	        other = '';
	        // If the last diverging line is exactly one line above or if it is the
	        // very first line, add the line to the result.
	        if (cur === 1 || i === 0) {
	          res += "\n  ".concat(actualLine);
	          printedLines++;
	        }
	      }
	    }
	    // Inspected object to big (Show ~20 rows max)
	    if (printedLines > 20 && i < maxLines - 2) {
	      return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
	    }
	  }
	  return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
	}
	var AssertionError = /*#__PURE__*/function (_Error, _inspect$custom) {
	  _inherits(AssertionError, _Error);
	  var _super = _createSuper(AssertionError);
	  function AssertionError(options) {
	    var _this;
	    _classCallCheck(this, AssertionError);
	    if (_typeof(options) !== 'object' || options === null) {
	      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
	    }
	    var message = options.message,
	      operator = options.operator,
	      stackStartFn = options.stackStartFn;
	    var actual = options.actual,
	      expected = options.expected;
	    var limit = Error.stackTraceLimit;
	    Error.stackTraceLimit = 0;
	    if (message != null) {
	      _this = _super.call(this, String(message));
	    } else {
	      if (process$1.stderr && process$1.stderr.isTTY) {
	        // Reset on each call to make sure we handle dynamically set environment
	        // variables correct.
	        if (process$1.stderr && process$1.stderr.getColorDepth && process$1.stderr.getColorDepth() !== 1) {
	          blue = "\x1B[34m";
	          green = "\x1B[32m";
	          white = "\x1B[39m";
	          red = "\x1B[31m";
	        } else {
	          blue = '';
	          green = '';
	          white = '';
	          red = '';
	        }
	      }
	      // Prevent the error stack from being visible by duplicating the error
	      // in a very close way to the original in case both sides are actually
	      // instances of Error.
	      if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
	        actual = copyError(actual);
	        expected = copyError(expected);
	      }
	      if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
	        _this = _super.call(this, createErrDiff(actual, expected, operator));
	      } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
	        // In case the objects are equal but the operator requires unequal, show
	        // the first object and say A equals B
	        var base = kReadableOperator[operator];
	        var res = inspectValue(actual).split('\n');

	        // In case "actual" is an object, it should not be reference equal.
	        if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
	          base = kReadableOperator.notStrictEqualObject;
	        }

	        // Only remove lines in case it makes sense to collapse those.
	        // TODO: Accept env to always show the full error.
	        if (res.length > 30) {
	          res[26] = "".concat(blue, "...").concat(white);
	          while (res.length > 27) {
	            res.pop();
	          }
	        }

	        // Only print a single input.
	        if (res.length === 1) {
	          _this = _super.call(this, "".concat(base, " ").concat(res[0]));
	        } else {
	          _this = _super.call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n"));
	        }
	      } else {
	        var _res = inspectValue(actual);
	        var other = '';
	        var knownOperators = kReadableOperator[operator];
	        if (operator === 'notDeepEqual' || operator === 'notEqual') {
	          _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
	          if (_res.length > 1024) {
	            _res = "".concat(_res.slice(0, 1021), "...");
	          }
	        } else {
	          other = "".concat(inspectValue(expected));
	          if (_res.length > 512) {
	            _res = "".concat(_res.slice(0, 509), "...");
	          }
	          if (other.length > 512) {
	            other = "".concat(other.slice(0, 509), "...");
	          }
	          if (operator === 'deepEqual' || operator === 'equal') {
	            _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
	          } else {
	            other = " ".concat(operator, " ").concat(other);
	          }
	        }
	        _this = _super.call(this, "".concat(_res).concat(other));
	      }
	    }
	    Error.stackTraceLimit = limit;
	    _this.generatedMessage = !message;
	    Object.defineProperty(_assertThisInitialized(_this), 'name', {
	      value: 'AssertionError [ERR_ASSERTION]',
	      enumerable: false,
	      writable: true,
	      configurable: true
	    });
	    _this.code = 'ERR_ASSERTION';
	    _this.actual = actual;
	    _this.expected = expected;
	    _this.operator = operator;
	    if (Error.captureStackTrace) {
	      // eslint-disable-next-line no-restricted-syntax
	      Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
	    }
	    // Create error message including the error code in the name.
	    _this.stack;
	    // Reset the name.
	    _this.name = 'AssertionError';
	    return _possibleConstructorReturn(_this);
	  }
	  _createClass(AssertionError, [{
	    key: "toString",
	    value: function toString() {
	      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
	    }
	  }, {
	    key: _inspect$custom,
	    value: function value(recurseTimes, ctx) {
	      // This limits the `actual` and `expected` property default inspection to
	      // the minimum depth. Otherwise those values would be too verbose compared
	      // to the actual error message which contains a combined view of these two
	      // input values.
	      return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {
	        customInspect: false,
	        depth: 0
	      }));
	    }
	  }]);
	  return AssertionError;
	}( /*#__PURE__*/_wrapNativeSuper(Error), inspect.custom);
	assertion_error = AssertionError;
	return assertion_error;
}

var isArguments;
var hasRequiredIsArguments;

function requireIsArguments () {
	if (hasRequiredIsArguments) return isArguments;
	hasRequiredIsArguments = 1;

	var toStr = Object.prototype.toString;

	isArguments = function isArguments(value) {
		var str = toStr.call(value);
		var isArgs = str === '[object Arguments]';
		if (!isArgs) {
			isArgs = str !== '[object Array]' &&
				value !== null &&
				typeof value === 'object' &&
				typeof value.length === 'number' &&
				value.length >= 0 &&
				toStr.call(value.callee) === '[object Function]';
		}
		return isArgs;
	};
	return isArguments;
}

var implementation$3;
var hasRequiredImplementation$3;

function requireImplementation$3 () {
	if (hasRequiredImplementation$3) return implementation$3;
	hasRequiredImplementation$3 = 1;
	var keysShim;
	if (!Object.keys) {
	  var has = Object.prototype.hasOwnProperty;
	  var toStr = Object.prototype.toString;
	  var isArgs = requireIsArguments();
	  var isEnumerable = Object.prototype.propertyIsEnumerable;
	  var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
	  var hasProtoEnumBug = isEnumerable.call(function() {
	  }, "prototype");
	  var dontEnums = [
	    "toString",
	    "toLocaleString",
	    "valueOf",
	    "hasOwnProperty",
	    "isPrototypeOf",
	    "propertyIsEnumerable",
	    "constructor"
	  ];
	  var equalsConstructorPrototype = function(o) {
	    var ctor = o.constructor;
	    return ctor && ctor.prototype === o;
	  };
	  var excludedKeys = {
	    $applicationCache: true,
	    $console: true,
	    $external: true,
	    $frame: true,
	    $frameElement: true,
	    $frames: true,
	    $innerHeight: true,
	    $innerWidth: true,
	    $onmozfullscreenchange: true,
	    $onmozfullscreenerror: true,
	    $outerHeight: true,
	    $outerWidth: true,
	    $pageXOffset: true,
	    $pageYOffset: true,
	    $parent: true,
	    $scrollLeft: true,
	    $scrollTop: true,
	    $scrollX: true,
	    $scrollY: true,
	    $self: true,
	    $webkitIndexedDB: true,
	    $webkitStorageInfo: true,
	    $window: true
	  };
	  var hasAutomationEqualityBug = function() {
	    if (typeof window === "undefined") {
	      return false;
	    }
	    for (var k in window) {
	      try {
	        if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
	          try {
	            equalsConstructorPrototype(window[k]);
	          } catch (e) {
	            return true;
	          }
	        }
	      } catch (e) {
	        return true;
	      }
	    }
	    return false;
	  }();
	  var equalsConstructorPrototypeIfNotBuggy = function(o) {
	    if (typeof window === "undefined" || !hasAutomationEqualityBug) {
	      return equalsConstructorPrototype(o);
	    }
	    try {
	      return equalsConstructorPrototype(o);
	    } catch (e) {
	      return false;
	    }
	  };
	  keysShim = function keys(object) {
	    var isObject = object !== null && typeof object === "object";
	    var isFunction = toStr.call(object) === "[object Function]";
	    var isArguments = isArgs(object);
	    var isString = isObject && toStr.call(object) === "[object String]";
	    var theKeys = [];
	    if (!isObject && !isFunction && !isArguments) {
	      throw new TypeError("Object.keys called on a non-object");
	    }
	    var skipProto = hasProtoEnumBug && isFunction;
	    if (isString && object.length > 0 && !has.call(object, 0)) {
	      for (var i = 0; i < object.length; ++i) {
	        theKeys.push(String(i));
	      }
	    }
	    if (isArguments && object.length > 0) {
	      for (var j = 0; j < object.length; ++j) {
	        theKeys.push(String(j));
	      }
	    } else {
	      for (var name in object) {
	        if (!(skipProto && name === "prototype") && has.call(object, name)) {
	          theKeys.push(String(name));
	        }
	      }
	    }
	    if (hasDontEnumBug) {
	      var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
	      for (var k = 0; k < dontEnums.length; ++k) {
	        if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
	          theKeys.push(dontEnums[k]);
	        }
	      }
	    }
	    return theKeys;
	  };
	}
	implementation$3 = keysShim;
	return implementation$3;
}

var objectKeys;
var hasRequiredObjectKeys;

function requireObjectKeys () {
	if (hasRequiredObjectKeys) return objectKeys;
	hasRequiredObjectKeys = 1;

	var slice = Array.prototype.slice;
	var isArgs = requireIsArguments();

	var origKeys = Object.keys;
	var keysShim = origKeys ? function keys(o) { return origKeys(o); } : requireImplementation$3();

	var originalKeys = Object.keys;

	keysShim.shim = function shimObjectKeys() {
		if (Object.keys) {
			var keysWorksWithArguments = (function () {
				// Safari 5.0 bug
				var args = Object.keys(arguments);
				return args && args.length === arguments.length;
			}(1, 2));
			if (!keysWorksWithArguments) {
				Object.keys = function keys(object) { // eslint-disable-line func-name-matching
					if (isArgs(object)) {
						return originalKeys(slice.call(object));
					}
					return originalKeys(object);
				};
			}
		} else {
			Object.keys = keysShim;
		}
		return Object.keys || keysShim;
	};

	objectKeys = keysShim;
	return objectKeys;
}

var implementation$2;
var hasRequiredImplementation$2;

function requireImplementation$2 () {
	if (hasRequiredImplementation$2) return implementation$2;
	hasRequiredImplementation$2 = 1;

	// modified from https://github.com/es-shims/es6-shim
	var objectKeys = requireObjectKeys();
	var hasSymbols = requireShams()();
	var callBound = /*@__PURE__*/ requireCallBound$1();
	var $Object = /*@__PURE__*/ requireEsObjectAtoms();
	var $push = callBound('Array.prototype.push');
	var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
	var originalGetSymbols = hasSymbols ? $Object.getOwnPropertySymbols : null;

	// eslint-disable-next-line no-unused-vars
	implementation$2 = function assign(target, source1) {
		if (target == null) { throw new TypeError('target must be an object'); }
		var to = $Object(target); // step 1
		if (arguments.length === 1) {
			return to; // step 2
		}
		for (var s = 1; s < arguments.length; ++s) {
			var from = $Object(arguments[s]); // step 3.a.i

			// step 3.a.ii:
			var keys = objectKeys(from);
			var getSymbols = hasSymbols && ($Object.getOwnPropertySymbols || originalGetSymbols);
			if (getSymbols) {
				var syms = getSymbols(from);
				for (var j = 0; j < syms.length; ++j) {
					var key = syms[j];
					if ($propIsEnumerable(from, key)) {
						$push(keys, key);
					}
				}
			}

			// step 3.a.iii:
			for (var i = 0; i < keys.length; ++i) {
				var nextKey = keys[i];
				if ($propIsEnumerable(from, nextKey)) { // step 3.a.iii.2
					var propValue = from[nextKey]; // step 3.a.iii.2.a
					to[nextKey] = propValue; // step 3.a.iii.2.b
				}
			}
		}

		return to; // step 4
	};
	return implementation$2;
}

var polyfill$2;
var hasRequiredPolyfill$2;

function requirePolyfill$2 () {
	if (hasRequiredPolyfill$2) return polyfill$2;
	hasRequiredPolyfill$2 = 1;

	var implementation = requireImplementation$2();

	var lacksProperEnumerationOrder = function () {
		if (!Object.assign) {
			return false;
		}
		/*
		 * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
		 * note: this does not detect the bug unless there's 20 characters
		 */
		var str = 'abcdefghijklmnopqrst';
		var letters = str.split('');
		var map = {};
		for (var i = 0; i < letters.length; ++i) {
			map[letters[i]] = letters[i];
		}
		var obj = Object.assign({}, map);
		var actual = '';
		for (var k in obj) {
			actual += k;
		}
		return str !== actual;
	};

	var assignHasPendingExceptions = function () {
		if (!Object.assign || !Object.preventExtensions) {
			return false;
		}
		/*
		 * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
		 * which is 72% slower than our shim, and Firefox 40's native implementation.
		 */
		var thrower = Object.preventExtensions({ 1: 2 });
		try {
			Object.assign(thrower, 'xy');
		} catch (e) {
			return thrower[1] === 'y';
		}
		return false;
	};

	polyfill$2 = function getPolyfill() {
		if (!Object.assign) {
			return implementation;
		}
		if (lacksProperEnumerationOrder()) {
			return implementation;
		}
		if (assignHasPendingExceptions()) {
			return implementation;
		}
		return Object.assign;
	};
	return polyfill$2;
}

var implementation$1;
var hasRequiredImplementation$1;

function requireImplementation$1 () {
	if (hasRequiredImplementation$1) return implementation$1;
	hasRequiredImplementation$1 = 1;

	var numberIsNaN = function (value) {
		return value !== value;
	};

	implementation$1 = function is(a, b) {
		if (a === 0 && b === 0) {
			return 1 / a === 1 / b;
		}
		if (a === b) {
			return true;
		}
		if (numberIsNaN(a) && numberIsNaN(b)) {
			return true;
		}
		return false;
	};
	return implementation$1;
}

var polyfill$1;
var hasRequiredPolyfill$1;

function requirePolyfill$1 () {
	if (hasRequiredPolyfill$1) return polyfill$1;
	hasRequiredPolyfill$1 = 1;

	var implementation = requireImplementation$1();

	polyfill$1 = function getPolyfill() {
		return typeof Object.is === 'function' ? Object.is : implementation;
	};
	return polyfill$1;
}

var callBound;
var hasRequiredCallBound;

function requireCallBound () {
	if (hasRequiredCallBound) return callBound;
	hasRequiredCallBound = 1;

	var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();

	var callBind = requireCallBind();

	var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

	callBound = function callBoundIntrinsic(name, allowMissing) {
		var intrinsic = GetIntrinsic(name, !!allowMissing);
		if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
			return callBind(intrinsic);
		}
		return intrinsic;
	};
	return callBound;
}

var defineProperties_1;
var hasRequiredDefineProperties;

function requireDefineProperties () {
	if (hasRequiredDefineProperties) return defineProperties_1;
	hasRequiredDefineProperties = 1;

	var keys = requireObjectKeys();
	var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

	var toStr = Object.prototype.toString;
	var concat = Array.prototype.concat;
	var defineDataProperty = /*@__PURE__*/ requireDefineDataProperty();

	var isFunction = function (fn) {
		return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
	};

	var supportsDescriptors = /*@__PURE__*/ requireHasPropertyDescriptors()();

	var defineProperty = function (object, name, value, predicate) {
		if (name in object) {
			if (predicate === true) {
				if (object[name] === value) {
					return;
				}
			} else if (!isFunction(predicate) || !predicate()) {
				return;
			}
		}

		if (supportsDescriptors) {
			defineDataProperty(object, name, value, true);
		} else {
			defineDataProperty(object, name, value);
		}
	};

	var defineProperties = function (object, map) {
		var predicates = arguments.length > 2 ? arguments[2] : {};
		var props = keys(map);
		if (hasSymbols) {
			props = concat.call(props, Object.getOwnPropertySymbols(map));
		}
		for (var i = 0; i < props.length; i += 1) {
			defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
		}
	};

	defineProperties.supportsDescriptors = !!supportsDescriptors;

	defineProperties_1 = defineProperties;
	return defineProperties_1;
}

var shim$1;
var hasRequiredShim$1;

function requireShim$1 () {
	if (hasRequiredShim$1) return shim$1;
	hasRequiredShim$1 = 1;

	var getPolyfill = requirePolyfill$1();
	var define = requireDefineProperties();

	shim$1 = function shimObjectIs() {
		var polyfill = getPolyfill();
		define(Object, { is: polyfill }, {
			is: function testObjectIs() {
				return Object.is !== polyfill;
			}
		});
		return polyfill;
	};
	return shim$1;
}

var objectIs;
var hasRequiredObjectIs;

function requireObjectIs () {
	if (hasRequiredObjectIs) return objectIs;
	hasRequiredObjectIs = 1;

	var define = requireDefineProperties();
	var callBind = requireCallBind();

	var implementation = requireImplementation$1();
	var getPolyfill = requirePolyfill$1();
	var shim = requireShim$1();

	var polyfill = callBind(getPolyfill(), Object);

	define(polyfill, {
		getPolyfill: getPolyfill,
		implementation: implementation,
		shim: shim
	});

	objectIs = polyfill;
	return objectIs;
}

var implementation;
var hasRequiredImplementation;

function requireImplementation () {
	if (hasRequiredImplementation) return implementation;
	hasRequiredImplementation = 1;

	/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

	implementation = function isNaN(value) {
		return value !== value;
	};
	return implementation;
}

var polyfill;
var hasRequiredPolyfill;

function requirePolyfill () {
	if (hasRequiredPolyfill) return polyfill;
	hasRequiredPolyfill = 1;

	var implementation = requireImplementation();

	polyfill = function getPolyfill() {
		if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
			return Number.isNaN;
		}
		return implementation;
	};
	return polyfill;
}

var shim;
var hasRequiredShim;

function requireShim () {
	if (hasRequiredShim) return shim;
	hasRequiredShim = 1;

	var define = requireDefineProperties();
	var getPolyfill = requirePolyfill();

	/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

	shim = function shimNumberIsNaN() {
		var polyfill = getPolyfill();
		define(Number, { isNaN: polyfill }, {
			isNaN: function testIsNaN() {
				return Number.isNaN !== polyfill;
			}
		});
		return polyfill;
	};
	return shim;
}

var isNan;
var hasRequiredIsNan;

function requireIsNan () {
	if (hasRequiredIsNan) return isNan;
	hasRequiredIsNan = 1;

	var callBind = requireCallBind();
	var define = requireDefineProperties();

	var implementation = requireImplementation();
	var getPolyfill = requirePolyfill();
	var shim = requireShim();

	var polyfill = callBind(getPolyfill(), Number);

	/* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */

	define(polyfill, {
		getPolyfill: getPolyfill,
		implementation: implementation,
		shim: shim
	});

	isNan = polyfill;
	return isNan;
}

var comparisons;
var hasRequiredComparisons;

function requireComparisons () {
	if (hasRequiredComparisons) return comparisons;
	hasRequiredComparisons = 1;

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
	function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = true, o = false; try { if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = true, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	var regexFlagsSupported = /a/g.flags !== undefined;
	var arrayFromSet = function arrayFromSet(set) {
	  var array = [];
	  set.forEach(function (value) {
	    return array.push(value);
	  });
	  return array;
	};
	var arrayFromMap = function arrayFromMap(map) {
	  var array = [];
	  map.forEach(function (value, key) {
	    return array.push([key, value]);
	  });
	  return array;
	};
	var objectIs = Object.is ? Object.is : requireObjectIs();
	var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () {
	  return [];
	};
	var numberIsNaN = Number.isNaN ? Number.isNaN : requireIsNan();
	function uncurryThis(f) {
	  return f.call.bind(f);
	}
	var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
	var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
	var objectToString = uncurryThis(Object.prototype.toString);
	var _require$types = requireUtil().types,
	  isAnyArrayBuffer = _require$types.isAnyArrayBuffer,
	  isArrayBufferView = _require$types.isArrayBufferView,
	  isDate = _require$types.isDate,
	  isMap = _require$types.isMap,
	  isRegExp = _require$types.isRegExp,
	  isSet = _require$types.isSet,
	  isNativeError = _require$types.isNativeError,
	  isBoxedPrimitive = _require$types.isBoxedPrimitive,
	  isNumberObject = _require$types.isNumberObject,
	  isStringObject = _require$types.isStringObject,
	  isBooleanObject = _require$types.isBooleanObject,
	  isBigIntObject = _require$types.isBigIntObject,
	  isSymbolObject = _require$types.isSymbolObject,
	  isFloat32Array = _require$types.isFloat32Array,
	  isFloat64Array = _require$types.isFloat64Array;
	function isNonIndex(key) {
	  if (key.length === 0 || key.length > 10) return true;
	  for (var i = 0; i < key.length; i++) {
	    var code = key.charCodeAt(i);
	    if (code < 48 || code > 57) return true;
	  }
	  // The maximum size for an array is 2 ** 32 -1.
	  return key.length === 10 && key >= Math.pow(2, 32);
	}
	function getOwnNonIndexProperties(value) {
	  return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
	}

	// Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
	// original notice:
	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	function compare(a, b) {
	  if (a === b) {
	    return 0;
	  }
	  var x = a.length;
	  var y = b.length;
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }
	  if (x < y) {
	    return -1;
	  }
	  if (y < x) {
	    return 1;
	  }
	  return 0;
	}
	var kStrict = true;
	var kLoose = false;
	var kNoIterator = 0;
	var kIsArray = 1;
	var kIsSet = 2;
	var kIsMap = 3;

	// Check if they have the same source and flags
	function areSimilarRegExps(a, b) {
	  return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
	}
	function areSimilarFloatArrays(a, b) {
	  if (a.byteLength !== b.byteLength) {
	    return false;
	  }
	  for (var offset = 0; offset < a.byteLength; offset++) {
	    if (a[offset] !== b[offset]) {
	      return false;
	    }
	  }
	  return true;
	}
	function areSimilarTypedArrays(a, b) {
	  if (a.byteLength !== b.byteLength) {
	    return false;
	  }
	  return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
	}
	function areEqualArrayBuffers(buf1, buf2) {
	  return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
	}
	function isEqualBoxedPrimitive(val1, val2) {
	  if (isNumberObject(val1)) {
	    return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
	  }
	  if (isStringObject(val1)) {
	    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
	  }
	  if (isBooleanObject(val1)) {
	    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
	  }
	  if (isBigIntObject(val1)) {
	    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
	  }
	  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
	}

	// Notes: Type tags are historical [[Class]] properties that can be set by
	// FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
	// and retrieved using Object.prototype.toString.call(obj) in JS
	// See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
	// for a list of tags pre-defined in the spec.
	// There are some unspecified tags in the wild too (e.g. typed array tags).
	// Since tags can be altered, they only serve fast failures
	//
	// Typed arrays and buffers are checked by comparing the content in their
	// underlying ArrayBuffer. This optimization requires that it's
	// reasonable to interpret their underlying memory in the same way,
	// which is checked by comparing their type tags.
	// (e.g. a Uint8Array and a Uint16Array with the same memory content
	// could still be different because they will be interpreted differently).
	//
	// For strict comparison, objects should have
	// a) The same built-in type tags
	// b) The same prototypes.

	function innerDeepEqual(val1, val2, strict, memos) {
	  // All identical values are equivalent, as determined by ===.
	  if (val1 === val2) {
	    if (val1 !== 0) return true;
	    return strict ? objectIs(val1, val2) : true;
	  }

	  // Check more closely if val1 and val2 are equal.
	  if (strict) {
	    if (_typeof(val1) !== 'object') {
	      return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
	    }
	    if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
	      return false;
	    }
	    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
	      return false;
	    }
	  } else {
	    if (val1 === null || _typeof(val1) !== 'object') {
	      if (val2 === null || _typeof(val2) !== 'object') {
	        // eslint-disable-next-line eqeqeq
	        return val1 == val2;
	      }
	      return false;
	    }
	    if (val2 === null || _typeof(val2) !== 'object') {
	      return false;
	    }
	  }
	  var val1Tag = objectToString(val1);
	  var val2Tag = objectToString(val2);
	  if (val1Tag !== val2Tag) {
	    return false;
	  }
	  if (Array.isArray(val1)) {
	    // Check for sparse arrays and general fast path
	    if (val1.length !== val2.length) {
	      return false;
	    }
	    var keys1 = getOwnNonIndexProperties(val1);
	    var keys2 = getOwnNonIndexProperties(val2);
	    if (keys1.length !== keys2.length) {
	      return false;
	    }
	    return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
	  }
	  // [browserify] This triggers on certain types in IE (Map/Set) so we don't
	  // wan't to early return out of the rest of the checks. However we can check
	  // if the second value is one of these values and the first isn't.
	  if (val1Tag === '[object Object]') {
	    // return keyCheck(val1, val2, strict, memos, kNoIterator);
	    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
	      return false;
	    }
	  }
	  if (isDate(val1)) {
	    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
	      return false;
	    }
	  } else if (isRegExp(val1)) {
	    if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
	      return false;
	    }
	  } else if (isNativeError(val1) || val1 instanceof Error) {
	    // Do not compare the stack as it might differ even though the error itself
	    // is otherwise identical.
	    if (val1.message !== val2.message || val1.name !== val2.name) {
	      return false;
	    }
	  } else if (isArrayBufferView(val1)) {
	    if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
	      if (!areSimilarFloatArrays(val1, val2)) {
	        return false;
	      }
	    } else if (!areSimilarTypedArrays(val1, val2)) {
	      return false;
	    }
	    // Buffer.compare returns true, so val1.length === val2.length. If they both
	    // only contain numeric keys, we don't need to exam further than checking
	    // the symbols.
	    var _keys = getOwnNonIndexProperties(val1);
	    var _keys2 = getOwnNonIndexProperties(val2);
	    if (_keys.length !== _keys2.length) {
	      return false;
	    }
	    return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
	  } else if (isSet(val1)) {
	    if (!isSet(val2) || val1.size !== val2.size) {
	      return false;
	    }
	    return keyCheck(val1, val2, strict, memos, kIsSet);
	  } else if (isMap(val1)) {
	    if (!isMap(val2) || val1.size !== val2.size) {
	      return false;
	    }
	    return keyCheck(val1, val2, strict, memos, kIsMap);
	  } else if (isAnyArrayBuffer(val1)) {
	    if (!areEqualArrayBuffers(val1, val2)) {
	      return false;
	    }
	  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
	    return false;
	  }
	  return keyCheck(val1, val2, strict, memos, kNoIterator);
	}
	function getEnumerables(val, keys) {
	  return keys.filter(function (k) {
	    return propertyIsEnumerable(val, k);
	  });
	}
	function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
	  // For all remaining Object pairs, including Array, objects and Maps,
	  // equivalence is determined by having:
	  // a) The same number of owned enumerable properties
	  // b) The same set of keys/indexes (although not necessarily the same order)
	  // c) Equivalent values for every corresponding key/index
	  // d) For Sets and Maps, equal contents
	  // Note: this accounts for both named and indexed properties on Arrays.
	  if (arguments.length === 5) {
	    aKeys = Object.keys(val1);
	    var bKeys = Object.keys(val2);

	    // The pair must have the same number of owned properties.
	    if (aKeys.length !== bKeys.length) {
	      return false;
	    }
	  }

	  // Cheap key test
	  var i = 0;
	  for (; i < aKeys.length; i++) {
	    if (!hasOwnProperty(val2, aKeys[i])) {
	      return false;
	    }
	  }
	  if (strict && arguments.length === 5) {
	    var symbolKeysA = objectGetOwnPropertySymbols(val1);
	    if (symbolKeysA.length !== 0) {
	      var count = 0;
	      for (i = 0; i < symbolKeysA.length; i++) {
	        var key = symbolKeysA[i];
	        if (propertyIsEnumerable(val1, key)) {
	          if (!propertyIsEnumerable(val2, key)) {
	            return false;
	          }
	          aKeys.push(key);
	          count++;
	        } else if (propertyIsEnumerable(val2, key)) {
	          return false;
	        }
	      }
	      var symbolKeysB = objectGetOwnPropertySymbols(val2);
	      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
	        return false;
	      }
	    } else {
	      var _symbolKeysB = objectGetOwnPropertySymbols(val2);
	      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
	        return false;
	      }
	    }
	  }
	  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
	    return true;
	  }

	  // Use memos to handle cycles.
	  if (memos === undefined) {
	    memos = {
	      val1: new Map(),
	      val2: new Map(),
	      position: 0
	    };
	  } else {
	    // We prevent up to two map.has(x) calls by directly retrieving the value
	    // and checking for undefined. The map can only contain numbers, so it is
	    // safe to check for undefined only.
	    var val2MemoA = memos.val1.get(val1);
	    if (val2MemoA !== undefined) {
	      var val2MemoB = memos.val2.get(val2);
	      if (val2MemoB !== undefined) {
	        return val2MemoA === val2MemoB;
	      }
	    }
	    memos.position++;
	  }
	  memos.val1.set(val1, memos.position);
	  memos.val2.set(val2, memos.position);
	  var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
	  memos.val1.delete(val1);
	  memos.val2.delete(val2);
	  return areEq;
	}
	function setHasEqualElement(set, val1, strict, memo) {
	  // Go looking.
	  var setValues = arrayFromSet(set);
	  for (var i = 0; i < setValues.length; i++) {
	    var val2 = setValues[i];
	    if (innerDeepEqual(val1, val2, strict, memo)) {
	      // Remove the matching element to make sure we do not check that again.
	      set.delete(val2);
	      return true;
	    }
	  }
	  return false;
	}

	// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
	// Sadly it is not possible to detect corresponding values properly in case the
	// type is a string, number, bigint or boolean. The reason is that those values
	// can match lots of different string values (e.g., 1n == '+00001').
	function findLooseMatchingPrimitives(prim) {
	  switch (_typeof(prim)) {
	    case 'undefined':
	      return null;
	    case 'object':
	      // Only pass in null as object!
	      return undefined;
	    case 'symbol':
	      return false;
	    case 'string':
	      prim = +prim;
	    // Loose equal entries exist only if the string is possible to convert to
	    // a regular number and not NaN.
	    // Fall through
	    case 'number':
	      if (numberIsNaN(prim)) {
	        return false;
	      }
	  }
	  return true;
	}
	function setMightHaveLoosePrim(a, b, prim) {
	  var altValue = findLooseMatchingPrimitives(prim);
	  if (altValue != null) return altValue;
	  return b.has(altValue) && !a.has(altValue);
	}
	function mapMightHaveLoosePrim(a, b, prim, item, memo) {
	  var altValue = findLooseMatchingPrimitives(prim);
	  if (altValue != null) {
	    return altValue;
	  }
	  var curB = b.get(altValue);
	  if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
	    return false;
	  }
	  return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
	}
	function setEquiv(a, b, strict, memo) {
	  // This is a lazily initiated Set of entries which have to be compared
	  // pairwise.
	  var set = null;
	  var aValues = arrayFromSet(a);
	  for (var i = 0; i < aValues.length; i++) {
	    var val = aValues[i];
	    // Note: Checking for the objects first improves the performance for object
	    // heavy sets but it is a minor slow down for primitives. As they are fast
	    // to check this improves the worst case scenario instead.
	    if (_typeof(val) === 'object' && val !== null) {
	      if (set === null) {
	        set = new Set();
	      }
	      // If the specified value doesn't exist in the second set its an not null
	      // object (or non strict only: a not matching primitive) we'll need to go
	      // hunting for something thats deep-(strict-)equal to it. To make this
	      // O(n log n) complexity we have to copy these values in a new set first.
	      set.add(val);
	    } else if (!b.has(val)) {
	      if (strict) return false;

	      // Fast path to detect missing string, symbol, undefined and null values.
	      if (!setMightHaveLoosePrim(a, b, val)) {
	        return false;
	      }
	      if (set === null) {
	        set = new Set();
	      }
	      set.add(val);
	    }
	  }
	  if (set !== null) {
	    var bValues = arrayFromSet(b);
	    for (var _i = 0; _i < bValues.length; _i++) {
	      var _val = bValues[_i];
	      // We have to check if a primitive value is already
	      // matching and only if it's not, go hunting for it.
	      if (_typeof(_val) === 'object' && _val !== null) {
	        if (!setHasEqualElement(set, _val, strict, memo)) return false;
	      } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
	        return false;
	      }
	    }
	    return set.size === 0;
	  }
	  return true;
	}
	function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
	  // To be able to handle cases like:
	  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
	  // ... we need to consider *all* matching keys, not just the first we find.
	  var setValues = arrayFromSet(set);
	  for (var i = 0; i < setValues.length; i++) {
	    var key2 = setValues[i];
	    if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
	      set.delete(key2);
	      return true;
	    }
	  }
	  return false;
	}
	function mapEquiv(a, b, strict, memo) {
	  var set = null;
	  var aEntries = arrayFromMap(a);
	  for (var i = 0; i < aEntries.length; i++) {
	    var _aEntries$i = _slicedToArray(aEntries[i], 2),
	      key = _aEntries$i[0],
	      item1 = _aEntries$i[1];
	    if (_typeof(key) === 'object' && key !== null) {
	      if (set === null) {
	        set = new Set();
	      }
	      set.add(key);
	    } else {
	      // By directly retrieving the value we prevent another b.has(key) check in
	      // almost all possible cases.
	      var item2 = b.get(key);
	      if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
	        if (strict) return false;
	        // Fast path to detect missing string, symbol, undefined and null
	        // keys.
	        if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
	        if (set === null) {
	          set = new Set();
	        }
	        set.add(key);
	      }
	    }
	  }
	  if (set !== null) {
	    var bEntries = arrayFromMap(b);
	    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
	      var _bEntries$_i = _slicedToArray(bEntries[_i2], 2),
	        _key = _bEntries$_i[0],
	        item = _bEntries$_i[1];
	      if (_typeof(_key) === 'object' && _key !== null) {
	        if (!mapHasEqualEntry(set, a, _key, item, strict, memo)) return false;
	      } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a, _key, item, false, memo)) {
	        return false;
	      }
	    }
	    return set.size === 0;
	  }
	  return true;
	}
	function objEquiv(a, b, strict, keys, memos, iterationType) {
	  // Sets and maps don't have their entries accessible via normal object
	  // properties.
	  var i = 0;
	  if (iterationType === kIsSet) {
	    if (!setEquiv(a, b, strict, memos)) {
	      return false;
	    }
	  } else if (iterationType === kIsMap) {
	    if (!mapEquiv(a, b, strict, memos)) {
	      return false;
	    }
	  } else if (iterationType === kIsArray) {
	    for (; i < a.length; i++) {
	      if (hasOwnProperty(a, i)) {
	        if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
	          return false;
	        }
	      } else if (hasOwnProperty(b, i)) {
	        return false;
	      } else {
	        // Array is sparse.
	        var keysA = Object.keys(a);
	        for (; i < keysA.length; i++) {
	          var key = keysA[i];
	          if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
	            return false;
	          }
	        }
	        if (keysA.length !== Object.keys(b).length) {
	          return false;
	        }
	        return true;
	      }
	    }
	  }

	  // The pair must have equivalent values for every corresponding key.
	  // Possibly expensive deep test:
	  for (i = 0; i < keys.length; i++) {
	    var _key2 = keys[i];
	    if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) {
	      return false;
	    }
	  }
	  return true;
	}
	function isDeepEqual(val1, val2) {
	  return innerDeepEqual(val1, val2, kLoose);
	}
	function isDeepStrictEqual(val1, val2) {
	  return innerDeepEqual(val1, val2, kStrict);
	}
	comparisons = {
	  isDeepEqual: isDeepEqual,
	  isDeepStrictEqual: isDeepStrictEqual
	};
	return comparisons;
}

var hasRequiredAssert;

function requireAssert () {
	if (hasRequiredAssert) return assert.exports;
	hasRequiredAssert = 1;

	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function _createClass(Constructor, protoProps, staticProps) { Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	var _require = requireErrors(),
	  _require$codes = _require.codes,
	  ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT,
	  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
	  ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE,
	  ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE,
	  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
	var AssertionError = requireAssertion_error();
	var _require2 = requireUtil(),
	  inspect = _require2.inspect;
	var _require$types = requireUtil().types,
	  isPromise = _require$types.isPromise,
	  isRegExp = _require$types.isRegExp;
	var objectAssign = requirePolyfill$2()();
	var objectIs = requirePolyfill$1()();
	var RegExpPrototypeTest = requireCallBound()('RegExp.prototype.test');
	var isDeepEqual;
	var isDeepStrictEqual;
	function lazyLoadComparison() {
	  var comparison = requireComparisons();
	  isDeepEqual = comparison.isDeepEqual;
	  isDeepStrictEqual = comparison.isDeepStrictEqual;
	}
	var warned = false;

	// The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.

	var assert$1 = assert.exports = ok;
	var NO_EXCEPTION_SENTINEL = {};

	// All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided. All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.

	function innerFail(obj) {
	  if (obj.message instanceof Error) throw obj.message;
	  throw new AssertionError(obj);
	}
	function fail(actual, expected, message, operator, stackStartFn) {
	  var argsLen = arguments.length;
	  var internalMessage;
	  if (argsLen === 0) {
	    internalMessage = 'Failed';
	  } else if (argsLen === 1) {
	    message = actual;
	    actual = undefined;
	  } else {
	    if (warned === false) {
	      warned = true;
	      var warn = process$1.emitWarning ? process$1.emitWarning : console.warn.bind(console);
	      warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
	    }
	    if (argsLen === 2) operator = '!=';
	  }
	  if (message instanceof Error) throw message;
	  var errArgs = {
	    actual: actual,
	    expected: expected,
	    operator: operator === undefined ? 'fail' : operator,
	    stackStartFn: stackStartFn || fail
	  };
	  if (message !== undefined) {
	    errArgs.message = message;
	  }
	  var err = new AssertionError(errArgs);
	  if (internalMessage) {
	    err.message = internalMessage;
	    err.generatedMessage = true;
	  }
	  throw err;
	}
	assert$1.fail = fail;

	// The AssertionError is defined in internal/error.
	assert$1.AssertionError = AssertionError;
	function innerOk(fn, argLen, value, message) {
	  if (!value) {
	    var generatedMessage = false;
	    if (argLen === 0) {
	      generatedMessage = true;
	      message = 'No value argument passed to `assert.ok()`';
	    } else if (message instanceof Error) {
	      throw message;
	    }
	    var err = new AssertionError({
	      actual: value,
	      expected: true,
	      message: message,
	      operator: '==',
	      stackStartFn: fn
	    });
	    err.generatedMessage = generatedMessage;
	    throw err;
	  }
	}

	// Pure assertion tests whether a value is truthy, as determined
	// by !!value.
	function ok() {
	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }
	  innerOk.apply(void 0, [ok, args.length].concat(args));
	}
	assert$1.ok = ok;

	// The equality assertion tests shallow, coercive equality with ==.
	/* eslint-disable no-restricted-properties */
	assert$1.equal = function equal(actual, expected, message) {
	  if (arguments.length < 2) {
	    throw new ERR_MISSING_ARGS('actual', 'expected');
	  }
	  // eslint-disable-next-line eqeqeq
	  if (actual != expected) {
	    innerFail({
	      actual: actual,
	      expected: expected,
	      message: message,
	      operator: '==',
	      stackStartFn: equal
	    });
	  }
	};

	// The non-equality assertion tests for whether two objects are not
	// equal with !=.
	assert$1.notEqual = function notEqual(actual, expected, message) {
	  if (arguments.length < 2) {
	    throw new ERR_MISSING_ARGS('actual', 'expected');
	  }
	  // eslint-disable-next-line eqeqeq
	  if (actual == expected) {
	    innerFail({
	      actual: actual,
	      expected: expected,
	      message: message,
	      operator: '!=',
	      stackStartFn: notEqual
	    });
	  }
	};

	// The equivalence assertion tests a deep equality relation.
	assert$1.deepEqual = function deepEqual(actual, expected, message) {
	  if (arguments.length < 2) {
	    throw new ERR_MISSING_ARGS('actual', 'expected');
	  }
	  if (isDeepEqual === undefined) lazyLoadComparison();
	  if (!isDeepEqual(actual, expected)) {
	    innerFail({
	      actual: actual,
	      expected: expected,
	      message: message,
	      operator: 'deepEqual',
	      stackStartFn: deepEqual
	    });
	  }
	};

	// The non-equivalence assertion tests for any deep inequality.
	assert$1.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (arguments.length < 2) {
	    throw new ERR_MISSING_ARGS('actual', 'expected');
	  }
	  if (isDeepEqual === undefined) lazyLoadComparison();
	  if (isDeepEqual(actual, expected)) {
	    innerFail({
	      actual: actual,
	      expected: expected,
	      message: message,
	      operator: 'notDeepEqual',
	      stackStartFn: notDeepEqual
	    });
	  }
	};
	/* eslint-enable */

	assert$1.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
	  if (arguments.length < 2) {
	    throw new ERR_MISSING_ARGS('actual', 'expected');
	  }
	  if (isDeepEqual === undefined) lazyLoadComparison();
	  if (!isDeepStrictEqual(actual, expected)) {
	    innerFail({
	      actual: actual,
	      expected: expected,
	      message: message,
	      operator: 'deepStrictEqual',
	      stackStartFn: deepStrictEqual
	    });
	  }
	};
	assert$1.notDeepStrictEqual = notDeepStrictEqual;
	function notDeepStrictEqual(actual, expected, message) {
	  if (arguments.length < 2) {
	    throw new ERR_MISSING_ARGS('actual', 'expected');
	  }
	  if (isDeepEqual === undefined) lazyLoadComparison();
	  if (isDeepStrictEqual(actual, expected)) {
	    innerFail({
	      actual: actual,
	      expected: expected,
	      message: message,
	      operator: 'notDeepStrictEqual',
	      stackStartFn: notDeepStrictEqual
	    });
	  }
	}
	assert$1.strictEqual = function strictEqual(actual, expected, message) {
	  if (arguments.length < 2) {
	    throw new ERR_MISSING_ARGS('actual', 'expected');
	  }
	  if (!objectIs(actual, expected)) {
	    innerFail({
	      actual: actual,
	      expected: expected,
	      message: message,
	      operator: 'strictEqual',
	      stackStartFn: strictEqual
	    });
	  }
	};
	assert$1.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (arguments.length < 2) {
	    throw new ERR_MISSING_ARGS('actual', 'expected');
	  }
	  if (objectIs(actual, expected)) {
	    innerFail({
	      actual: actual,
	      expected: expected,
	      message: message,
	      operator: 'notStrictEqual',
	      stackStartFn: notStrictEqual
	    });
	  }
	};
	var Comparison = /*#__PURE__*/_createClass(function Comparison(obj, keys, actual) {
	  var _this = this;
	  _classCallCheck(this, Comparison);
	  keys.forEach(function (key) {
	    if (key in obj) {
	      if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) {
	        _this[key] = actual[key];
	      } else {
	        _this[key] = obj[key];
	      }
	    }
	  });
	});
	function compareExceptionKey(actual, expected, key, message, keys, fn) {
	  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
	    if (!message) {
	      // Create placeholder objects to create a nice output.
	      var a = new Comparison(actual, keys);
	      var b = new Comparison(expected, keys, actual);
	      var err = new AssertionError({
	        actual: a,
	        expected: b,
	        operator: 'deepStrictEqual',
	        stackStartFn: fn
	      });
	      err.actual = actual;
	      err.expected = expected;
	      err.operator = fn.name;
	      throw err;
	    }
	    innerFail({
	      actual: actual,
	      expected: expected,
	      message: message,
	      operator: fn.name,
	      stackStartFn: fn
	    });
	  }
	}
	function expectedException(actual, expected, msg, fn) {
	  if (typeof expected !== 'function') {
	    if (isRegExp(expected)) return RegExpPrototypeTest(expected, actual);
	    // assert.doesNotThrow does not accept objects.
	    if (arguments.length === 2) {
	      throw new ERR_INVALID_ARG_TYPE('expected', ['Function', 'RegExp'], expected);
	    }

	    // Handle primitives properly.
	    if (_typeof(actual) !== 'object' || actual === null) {
	      var err = new AssertionError({
	        actual: actual,
	        expected: expected,
	        message: msg,
	        operator: 'deepStrictEqual',
	        stackStartFn: fn
	      });
	      err.operator = fn.name;
	      throw err;
	    }
	    var keys = Object.keys(expected);
	    // Special handle errors to make sure the name and the message are compared
	    // as well.
	    if (expected instanceof Error) {
	      keys.push('name', 'message');
	    } else if (keys.length === 0) {
	      throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
	    }
	    if (isDeepEqual === undefined) lazyLoadComparison();
	    keys.forEach(function (key) {
	      if (typeof actual[key] === 'string' && isRegExp(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) {
	        return;
	      }
	      compareExceptionKey(actual, expected, key, msg, keys, fn);
	    });
	    return true;
	  }
	  // Guard instanceof against arrow functions as they don't have a prototype.
	  if (expected.prototype !== undefined && actual instanceof expected) {
	    return true;
	  }
	  if (Error.isPrototypeOf(expected)) {
	    return false;
	  }
	  return expected.call({}, actual) === true;
	}
	function getActual(fn) {
	  if (typeof fn !== 'function') {
	    throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
	  }
	  try {
	    fn();
	  } catch (e) {
	    return e;
	  }
	  return NO_EXCEPTION_SENTINEL;
	}
	function checkIsPromise(obj) {
	  // Accept native ES6 promises and promises that are implemented in a similar
	  // way. Do not accept thenables that use a function as `obj` and that have no
	  // `catch` handler.

	  // TODO: thenables are checked up until they have the correct methods,
	  // but according to documentation, the `then` method should receive
	  // the `fulfill` and `reject` arguments as well or it may be never resolved.

	  return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
	}
	function waitForActual(promiseFn) {
	  return Promise.resolve().then(function () {
	    var resultPromise;
	    if (typeof promiseFn === 'function') {
	      // Return a rejected promise if `promiseFn` throws synchronously.
	      resultPromise = promiseFn();
	      // Fail in case no promise is returned.
	      if (!checkIsPromise(resultPromise)) {
	        throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
	      }
	    } else if (checkIsPromise(promiseFn)) {
	      resultPromise = promiseFn;
	    } else {
	      throw new ERR_INVALID_ARG_TYPE('promiseFn', ['Function', 'Promise'], promiseFn);
	    }
	    return Promise.resolve().then(function () {
	      return resultPromise;
	    }).then(function () {
	      return NO_EXCEPTION_SENTINEL;
	    }).catch(function (e) {
	      return e;
	    });
	  });
	}
	function expectsError(stackStartFn, actual, error, message) {
	  if (typeof error === 'string') {
	    if (arguments.length === 4) {
	      throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
	    }
	    if (_typeof(actual) === 'object' && actual !== null) {
	      if (actual.message === error) {
	        throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
	      }
	    } else if (actual === error) {
	      throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
	    }
	    message = error;
	    error = undefined;
	  } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
	    throw new ERR_INVALID_ARG_TYPE('error', ['Object', 'Error', 'Function', 'RegExp'], error);
	  }
	  if (actual === NO_EXCEPTION_SENTINEL) {
	    var details = '';
	    if (error && error.name) {
	      details += " (".concat(error.name, ")");
	    }
	    details += message ? ": ".concat(message) : '.';
	    var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
	    innerFail({
	      actual: undefined,
	      expected: error,
	      operator: stackStartFn.name,
	      message: "Missing expected ".concat(fnType).concat(details),
	      stackStartFn: stackStartFn
	    });
	  }
	  if (error && !expectedException(actual, error, message, stackStartFn)) {
	    throw actual;
	  }
	}
	function expectsNoError(stackStartFn, actual, error, message) {
	  if (actual === NO_EXCEPTION_SENTINEL) return;
	  if (typeof error === 'string') {
	    message = error;
	    error = undefined;
	  }
	  if (!error || expectedException(actual, error)) {
	    var details = message ? ": ".concat(message) : '.';
	    var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
	    innerFail({
	      actual: actual,
	      expected: error,
	      operator: stackStartFn.name,
	      message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
	      stackStartFn: stackStartFn
	    });
	  }
	  throw actual;
	}
	assert$1.throws = function throws(promiseFn) {
	  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	    args[_key2 - 1] = arguments[_key2];
	  }
	  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
	};
	assert$1.rejects = function rejects(promiseFn) {
	  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
	    args[_key3 - 1] = arguments[_key3];
	  }
	  return waitForActual(promiseFn).then(function (result) {
	    return expectsError.apply(void 0, [rejects, result].concat(args));
	  });
	};
	assert$1.doesNotThrow = function doesNotThrow(fn) {
	  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
	    args[_key4 - 1] = arguments[_key4];
	  }
	  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
	};
	assert$1.doesNotReject = function doesNotReject(fn) {
	  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
	    args[_key5 - 1] = arguments[_key5];
	  }
	  return waitForActual(fn).then(function (result) {
	    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
	  });
	};
	assert$1.ifError = function ifError(err) {
	  if (err !== null && err !== undefined) {
	    var message = 'ifError got unwanted exception: ';
	    if (_typeof(err) === 'object' && typeof err.message === 'string') {
	      if (err.message.length === 0 && err.constructor) {
	        message += err.constructor.name;
	      } else {
	        message += err.message;
	      }
	    } else {
	      message += inspect(err);
	    }
	    var newErr = new AssertionError({
	      actual: err,
	      expected: null,
	      operator: 'ifError',
	      message: message,
	      stackStartFn: ifError
	    });

	    // Make sure we actually have a stack trace!
	    var origStack = err.stack;
	    if (typeof origStack === 'string') {
	      // This will remove any duplicated frames from the error frames taken
	      // from within `ifError` and add the original error frames to the newly
	      // created ones.
	      var tmp2 = origStack.split('\n');
	      tmp2.shift();
	      // Filter all frames existing in err.stack.
	      var tmp1 = newErr.stack.split('\n');
	      for (var i = 0; i < tmp2.length; i++) {
	        // Find the first occurrence of the frame.
	        var pos = tmp1.indexOf(tmp2[i]);
	        if (pos !== -1) {
	          // Only keep new frames.
	          tmp1 = tmp1.slice(0, pos);
	          break;
	        }
	      }
	      newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
	    }
	    throw newErr;
	  }
	};

	// Currently in sync with Node.js lib/assert.js
	// https://github.com/nodejs/node/commit/2a871df3dfb8ea663ef5e1f8f62701ec51384ecb
	function internalMatch(string, regexp, message, fn, fnName) {
	  if (!isRegExp(regexp)) {
	    throw new ERR_INVALID_ARG_TYPE('regexp', 'RegExp', regexp);
	  }
	  var match = fnName === 'match';
	  if (typeof string !== 'string' || RegExpPrototypeTest(regexp, string) !== match) {
	    if (message instanceof Error) {
	      throw message;
	    }
	    var generatedMessage = !message;

	    // 'The input was expected to not match the regular expression ' +
	    message = message || (typeof string !== 'string' ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect(string), ")") : (match ? 'The input did not match the regular expression ' : 'The input was expected to not match the regular expression ') + "".concat(inspect(regexp), ". Input:\n\n").concat(inspect(string), "\n"));
	    var err = new AssertionError({
	      actual: string,
	      expected: regexp,
	      message: message,
	      operator: fnName,
	      stackStartFn: fn
	    });
	    err.generatedMessage = generatedMessage;
	    throw err;
	  }
	}
	assert$1.match = function match(string, regexp, message) {
	  internalMatch(string, regexp, message, match, 'match');
	};
	assert$1.doesNotMatch = function doesNotMatch(string, regexp, message) {
	  internalMatch(string, regexp, message, doesNotMatch, 'doesNotMatch');
	};

	// Expose a strict only variant of assert
	function strict() {
	  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
	    args[_key6] = arguments[_key6];
	  }
	  innerOk.apply(void 0, [strict, args.length].concat(args));
	}
	assert$1.strict = objectAssign(strict, assert$1, {
	  equal: assert$1.strictEqual,
	  deepEqual: assert$1.deepStrictEqual,
	  notEqual: assert$1.notStrictEqual,
	  notDeepEqual: assert$1.notDeepStrictEqual
	});
	assert$1.strict.strict = assert$1.strict;
	return assert.exports;
}

var sonicBoom;
var hasRequiredSonicBoom;

function requireSonicBoom () {
	if (hasRequiredSonicBoom) return sonicBoom;
	hasRequiredSonicBoom = 1;

	const fs = require$$0$1;
	const EventEmitter = requireEvents();
	const inherits = requireUtil().inherits;
	const path = requirePathBrowserify();
	const sleep = requireAtomicSleep();
	const assert = requireAssert();

	const BUSY_WRITE_TIMEOUT = 100;
	const kEmptyBuffer = Buffer.allocUnsafe(0);

	// 16 KB. Don't write more than docker buffer size.
	// https://github.com/moby/moby/blob/513ec73831269947d38a644c278ce3cac36783b2/daemon/logger/copier.go#L13
	const MAX_WRITE = 16 * 1024;

	const kContentModeBuffer = 'buffer';
	const kContentModeUtf8 = 'utf8';

	const [major, minor] = (process$1.versions.node || '0.0').split('.').map(Number);
	const kCopyBuffer = major >= 22 && minor >= 7;

	function openFile (file, sonic) {
	  sonic._opening = true;
	  sonic._writing = true;
	  sonic._asyncDrainScheduled = false;

	  // NOTE: 'error' and 'ready' events emitted below only relevant when sonic.sync===false
	  // for sync mode, there is no way to add a listener that will receive these

	  function fileOpened (err, fd) {
	    if (err) {
	      sonic._reopening = false;
	      sonic._writing = false;
	      sonic._opening = false;

	      if (sonic.sync) {
	        process$1.nextTick(() => {
	          if (sonic.listenerCount('error') > 0) {
	            sonic.emit('error', err);
	          }
	        });
	      } else {
	        sonic.emit('error', err);
	      }
	      return
	    }

	    const reopening = sonic._reopening;

	    sonic.fd = fd;
	    sonic.file = file;
	    sonic._reopening = false;
	    sonic._opening = false;
	    sonic._writing = false;

	    if (sonic.sync) {
	      process$1.nextTick(() => sonic.emit('ready'));
	    } else {
	      sonic.emit('ready');
	    }

	    if (sonic.destroyed) {
	      return
	    }

	    // start
	    if ((!sonic._writing && sonic._len > sonic.minLength) || sonic._flushPending) {
	      sonic._actualWrite();
	    } else if (reopening) {
	      process$1.nextTick(() => sonic.emit('drain'));
	    }
	  }

	  const flags = sonic.append ? 'a' : 'w';
	  const mode = sonic.mode;

	  if (sonic.sync) {
	    try {
	      if (sonic.mkdir) fs.mkdirSync(path.dirname(file), { recursive: true });
	      const fd = fs.openSync(file, flags, mode);
	      fileOpened(null, fd);
	    } catch (err) {
	      fileOpened(err);
	      throw err
	    }
	  } else if (sonic.mkdir) {
	    fs.mkdir(path.dirname(file), { recursive: true }, (err) => {
	      if (err) return fileOpened(err)
	      fs.open(file, flags, mode, fileOpened);
	    });
	  } else {
	    fs.open(file, flags, mode, fileOpened);
	  }
	}

	function SonicBoom (opts) {
	  if (!(this instanceof SonicBoom)) {
	    return new SonicBoom(opts)
	  }

	  let { fd, dest, minLength, maxLength, maxWrite, periodicFlush, sync, append = true, mkdir, retryEAGAIN, fsync, contentMode, mode } = opts || {};

	  fd = fd || dest;

	  this._len = 0;
	  this.fd = -1;
	  this._bufs = [];
	  this._lens = [];
	  this._writing = false;
	  this._ending = false;
	  this._reopening = false;
	  this._asyncDrainScheduled = false;
	  this._flushPending = false;
	  this._hwm = Math.max(minLength || 0, 16387);
	  this.file = null;
	  this.destroyed = false;
	  this.minLength = minLength || 0;
	  this.maxLength = maxLength || 0;
	  this.maxWrite = maxWrite || MAX_WRITE;
	  this._periodicFlush = periodicFlush || 0;
	  this._periodicFlushTimer = undefined;
	  this.sync = sync || false;
	  this.writable = true;
	  this._fsync = fsync || false;
	  this.append = append || false;
	  this.mode = mode;
	  this.retryEAGAIN = retryEAGAIN || (() => true);
	  this.mkdir = mkdir || false;

	  let fsWriteSync;
	  let fsWrite;
	  if (contentMode === kContentModeBuffer) {
	    this._writingBuf = kEmptyBuffer;
	    this.write = writeBuffer;
	    this.flush = flushBuffer;
	    this.flushSync = flushBufferSync;
	    this._actualWrite = actualWriteBuffer;
	    fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf);
	    fsWrite = () => fs.write(this.fd, this._writingBuf, this.release);
	  } else if (contentMode === undefined || contentMode === kContentModeUtf8) {
	    this._writingBuf = '';
	    this.write = write;
	    this.flush = flush;
	    this.flushSync = flushSync;
	    this._actualWrite = actualWrite;
	    fsWriteSync = () => fs.writeSync(this.fd, this._writingBuf, 'utf8');
	    fsWrite = () => fs.write(this.fd, this._writingBuf, 'utf8', this.release);
	  } else {
	    throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`)
	  }

	  if (typeof fd === 'number') {
	    this.fd = fd;
	    process$1.nextTick(() => this.emit('ready'));
	  } else if (typeof fd === 'string') {
	    openFile(fd, this);
	  } else {
	    throw new Error('SonicBoom supports only file descriptors and files')
	  }
	  if (this.minLength >= this.maxWrite) {
	    throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`)
	  }

	  this.release = (err, n) => {
	    if (err) {
	      if ((err.code === 'EAGAIN' || err.code === 'EBUSY') && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
	        if (this.sync) {
	          // This error code should not happen in sync mode, because it is
	          // not using the underlining operating system asynchronous functions.
	          // However it happens, and so we handle it.
	          // Ref: https://github.com/pinojs/pino/issues/783
	          try {
	            sleep(BUSY_WRITE_TIMEOUT);
	            this.release(undefined, 0);
	          } catch (err) {
	            this.release(err);
	          }
	        } else {
	          // Let's give the destination some time to process the chunk.
	          setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
	        }
	      } else {
	        this._writing = false;

	        this.emit('error', err);
	      }
	      return
	    }

	    this.emit('write', n);
	    const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
	    this._len = releasedBufObj.len;
	    this._writingBuf = releasedBufObj.writingBuf;

	    if (this._writingBuf.length) {
	      if (!this.sync) {
	        fsWrite();
	        return
	      }

	      try {
	        do {
	          const n = fsWriteSync();
	          const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
	          this._len = releasedBufObj.len;
	          this._writingBuf = releasedBufObj.writingBuf;
	        } while (this._writingBuf.length)
	      } catch (err) {
	        this.release(err);
	        return
	      }
	    }

	    if (this._fsync) {
	      fs.fsyncSync(this.fd);
	    }

	    const len = this._len;
	    if (this._reopening) {
	      this._writing = false;
	      this._reopening = false;
	      this.reopen();
	    } else if (len > this.minLength) {
	      this._actualWrite();
	    } else if (this._ending) {
	      if (len > 0) {
	        this._actualWrite();
	      } else {
	        this._writing = false;
	        actualClose(this);
	      }
	    } else {
	      this._writing = false;
	      if (this.sync) {
	        if (!this._asyncDrainScheduled) {
	          this._asyncDrainScheduled = true;
	          process$1.nextTick(emitDrain, this);
	        }
	      } else {
	        this.emit('drain');
	      }
	    }
	  };

	  this.on('newListener', function (name) {
	    if (name === 'drain') {
	      this._asyncDrainScheduled = false;
	    }
	  });

	  if (this._periodicFlush !== 0) {
	    this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush);
	    this._periodicFlushTimer.unref();
	  }
	}

	/**
	 * Release the writingBuf after fs.write n bytes data
	 * @param {string | Buffer} writingBuf - currently writing buffer, usually be instance._writingBuf.
	 * @param {number} len - currently buffer length, usually be instance._len.
	 * @param {number} n - number of bytes fs already written
	 * @returns {{writingBuf: string | Buffer, len: number}} released writingBuf and length
	 */
	function releaseWritingBuf (writingBuf, len, n) {
	  // if Buffer.byteLength is equal to n, that means writingBuf contains no multi-byte character
	  if (typeof writingBuf === 'string' && Buffer.byteLength(writingBuf) !== n) {
	    // Since the fs.write callback parameter `n` means how many bytes the passed of string
	    // We calculate the original string length for avoiding the multi-byte character issue
	    n = Buffer.from(writingBuf).subarray(0, n).toString().length;
	  }
	  len = Math.max(len - n, 0);
	  writingBuf = writingBuf.slice(n);
	  return { writingBuf, len }
	}

	function emitDrain (sonic) {
	  const hasListeners = sonic.listenerCount('drain') > 0;
	  if (!hasListeners) return
	  sonic._asyncDrainScheduled = false;
	  sonic.emit('drain');
	}

	inherits(SonicBoom, EventEmitter);

	function mergeBuf (bufs, len) {
	  if (bufs.length === 0) {
	    return kEmptyBuffer
	  }

	  if (bufs.length === 1) {
	    return bufs[0]
	  }

	  return Buffer.concat(bufs, len)
	}

	function write (data) {
	  if (this.destroyed) {
	    throw new Error('SonicBoom destroyed')
	  }

	  const len = this._len + data.length;
	  const bufs = this._bufs;

	  if (this.maxLength && len > this.maxLength) {
	    this.emit('drop', data);
	    return this._len < this._hwm
	  }

	  if (
	    bufs.length === 0 ||
	    bufs[bufs.length - 1].length + data.length > this.maxWrite
	  ) {
	    bufs.push('' + data);
	  } else {
	    bufs[bufs.length - 1] += data;
	  }

	  this._len = len;

	  if (!this._writing && this._len >= this.minLength) {
	    this._actualWrite();
	  }

	  return this._len < this._hwm
	}

	function writeBuffer (data) {
	  if (this.destroyed) {
	    throw new Error('SonicBoom destroyed')
	  }

	  const len = this._len + data.length;
	  const bufs = this._bufs;
	  const lens = this._lens;

	  if (this.maxLength && len > this.maxLength) {
	    this.emit('drop', data);
	    return this._len < this._hwm
	  }

	  if (
	    bufs.length === 0 ||
	    lens[lens.length - 1] + data.length > this.maxWrite
	  ) {
	    bufs.push([data]);
	    lens.push(data.length);
	  } else {
	    bufs[bufs.length - 1].push(data);
	    lens[lens.length - 1] += data.length;
	  }

	  this._len = len;

	  if (!this._writing && this._len >= this.minLength) {
	    this._actualWrite();
	  }

	  return this._len < this._hwm
	}

	function callFlushCallbackOnDrain (cb) {
	  this._flushPending = true;
	  const onDrain = () => {
	    // only if _fsync is false to avoid double fsync
	    if (!this._fsync) {
	      try {
	        fs.fsync(this.fd, (err) => {
	          this._flushPending = false;
	          cb(err);
	        });
	      } catch (err) {
	        cb(err);
	      }
	    } else {
	      this._flushPending = false;
	      cb();
	    }
	    this.off('error', onError);
	  };
	  const onError = (err) => {
	    this._flushPending = false;
	    cb(err);
	    this.off('drain', onDrain);
	  };

	  this.once('drain', onDrain);
	  this.once('error', onError);
	}

	function flush (cb) {
	  if (cb != null && typeof cb !== 'function') {
	    throw new Error('flush cb must be a function')
	  }

	  if (this.destroyed) {
	    const error = new Error('SonicBoom destroyed');
	    if (cb) {
	      cb(error);
	      return
	    }

	    throw error
	  }

	  if (this.minLength <= 0) {
	    cb?.();
	    return
	  }

	  if (cb) {
	    callFlushCallbackOnDrain.call(this, cb);
	  }

	  if (this._writing) {
	    return
	  }

	  if (this._bufs.length === 0) {
	    this._bufs.push('');
	  }

	  this._actualWrite();
	}

	function flushBuffer (cb) {
	  if (cb != null && typeof cb !== 'function') {
	    throw new Error('flush cb must be a function')
	  }

	  if (this.destroyed) {
	    const error = new Error('SonicBoom destroyed');
	    if (cb) {
	      cb(error);
	      return
	    }

	    throw error
	  }

	  if (this.minLength <= 0) {
	    cb?.();
	    return
	  }

	  if (cb) {
	    callFlushCallbackOnDrain.call(this, cb);
	  }

	  if (this._writing) {
	    return
	  }

	  if (this._bufs.length === 0) {
	    this._bufs.push([]);
	    this._lens.push(0);
	  }

	  this._actualWrite();
	}

	SonicBoom.prototype.reopen = function (file) {
	  if (this.destroyed) {
	    throw new Error('SonicBoom destroyed')
	  }

	  if (this._opening) {
	    this.once('ready', () => {
	      this.reopen(file);
	    });
	    return
	  }

	  if (this._ending) {
	    return
	  }

	  if (!this.file) {
	    throw new Error('Unable to reopen a file descriptor, you must pass a file to SonicBoom')
	  }

	  if (file) {
	    this.file = file;
	  }
	  this._reopening = true;

	  if (this._writing) {
	    return
	  }

	  const fd = this.fd;
	  this.once('ready', () => {
	    if (fd !== this.fd) {
	      fs.close(fd, (err) => {
	        if (err) {
	          return this.emit('error', err)
	        }
	      });
	    }
	  });

	  openFile(this.file, this);
	};

	SonicBoom.prototype.end = function () {
	  if (this.destroyed) {
	    throw new Error('SonicBoom destroyed')
	  }

	  if (this._opening) {
	    this.once('ready', () => {
	      this.end();
	    });
	    return
	  }

	  if (this._ending) {
	    return
	  }

	  this._ending = true;

	  if (this._writing) {
	    return
	  }

	  if (this._len > 0 && this.fd >= 0) {
	    this._actualWrite();
	  } else {
	    actualClose(this);
	  }
	};

	function flushSync () {
	  if (this.destroyed) {
	    throw new Error('SonicBoom destroyed')
	  }

	  if (this.fd < 0) {
	    throw new Error('sonic boom is not ready yet')
	  }

	  if (!this._writing && this._writingBuf.length > 0) {
	    this._bufs.unshift(this._writingBuf);
	    this._writingBuf = '';
	  }

	  let buf = '';
	  while (this._bufs.length || buf) {
	    if (buf.length <= 0) {
	      buf = this._bufs[0];
	    }
	    try {
	      const n = fs.writeSync(this.fd, buf, 'utf8');
	      const releasedBufObj = releaseWritingBuf(buf, this._len, n);
	      buf = releasedBufObj.writingBuf;
	      this._len = releasedBufObj.len;
	      if (buf.length <= 0) {
	        this._bufs.shift();
	      }
	    } catch (err) {
	      const shouldRetry = err.code === 'EAGAIN' || err.code === 'EBUSY';
	      if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
	        throw err
	      }

	      sleep(BUSY_WRITE_TIMEOUT);
	    }
	  }

	  try {
	    fs.fsyncSync(this.fd);
	  } catch {
	    // Skip the error. The fd might not support fsync.
	  }
	}

	function flushBufferSync () {
	  if (this.destroyed) {
	    throw new Error('SonicBoom destroyed')
	  }

	  if (this.fd < 0) {
	    throw new Error('sonic boom is not ready yet')
	  }

	  if (!this._writing && this._writingBuf.length > 0) {
	    this._bufs.unshift([this._writingBuf]);
	    this._writingBuf = kEmptyBuffer;
	  }

	  let buf = kEmptyBuffer;
	  while (this._bufs.length || buf.length) {
	    if (buf.length <= 0) {
	      buf = mergeBuf(this._bufs[0], this._lens[0]);
	    }
	    try {
	      const n = fs.writeSync(this.fd, buf);
	      buf = buf.subarray(n);
	      this._len = Math.max(this._len - n, 0);
	      if (buf.length <= 0) {
	        this._bufs.shift();
	        this._lens.shift();
	      }
	    } catch (err) {
	      const shouldRetry = err.code === 'EAGAIN' || err.code === 'EBUSY';
	      if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
	        throw err
	      }

	      sleep(BUSY_WRITE_TIMEOUT);
	    }
	  }
	}

	SonicBoom.prototype.destroy = function () {
	  if (this.destroyed) {
	    return
	  }
	  actualClose(this);
	};

	function actualWrite () {
	  const release = this.release;
	  this._writing = true;
	  this._writingBuf = this._writingBuf || this._bufs.shift() || '';

	  if (this.sync) {
	    try {
	      const written = fs.writeSync(this.fd, this._writingBuf, 'utf8');
	      release(null, written);
	    } catch (err) {
	      release(err);
	    }
	  } else {
	    fs.write(this.fd, this._writingBuf, 'utf8', release);
	  }
	}

	function actualWriteBuffer () {
	  const release = this.release;
	  this._writing = true;
	  this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());

	  if (this.sync) {
	    try {
	      const written = fs.writeSync(this.fd, this._writingBuf);
	      release(null, written);
	    } catch (err) {
	      release(err);
	    }
	  } else {
	    // fs.write will need to copy string to buffer anyway so
	    // we do it here to avoid the overhead of calculating the buffer size
	    // in releaseWritingBuf.
	    if (kCopyBuffer) {
	      this._writingBuf = Buffer.from(this._writingBuf);
	    }
	    fs.write(this.fd, this._writingBuf, release);
	  }
	}

	function actualClose (sonic) {
	  if (sonic.fd === -1) {
	    sonic.once('ready', actualClose.bind(null, sonic));
	    return
	  }

	  if (sonic._periodicFlushTimer !== undefined) {
	    clearInterval(sonic._periodicFlushTimer);
	  }

	  sonic.destroyed = true;
	  sonic._bufs = [];
	  sonic._lens = [];

	  assert(typeof sonic.fd === 'number', `sonic.fd must be a number, got ${typeof sonic.fd}`);
	  try {
	    fs.fsync(sonic.fd, closeWrapped);
	  } catch {
	  }

	  function closeWrapped () {
	    // We skip errors in fsync

	    if (sonic.fd !== 1 && sonic.fd !== 2) {
	      fs.close(sonic.fd, done);
	    } else {
	      done();
	    }
	  }

	  function done (err) {
	    if (err) {
	      sonic.emit('error', err);
	      return
	    }

	    if (sonic._ending && !sonic._writing) {
	      sonic.emit('finish');
	    }
	    sonic.emit('close');
	  }
	}

	/**
	 * These export configurations enable JS and TS developers
	 * to consumer SonicBoom in whatever way best suits their needs.
	 * Some examples of supported import syntax includes:
	 * - `const SonicBoom = require('SonicBoom')`
	 * - `const { SonicBoom } = require('SonicBoom')`
	 * - `import * as SonicBoom from 'SonicBoom'`
	 * - `import { SonicBoom } from 'SonicBoom'`
	 * - `import SonicBoom from 'SonicBoom'`
	 */
	SonicBoom.SonicBoom = SonicBoom;
	SonicBoom.default = SonicBoom;
	sonicBoom = SonicBoom;
	return sonicBoom;
}

var noop;
var hasRequiredNoop;

function requireNoop () {
	if (hasRequiredNoop) return noop;
	hasRequiredNoop = 1;

	noop = function noop () {};
	return noop;
}

var onExitLeakFree;
var hasRequiredOnExitLeakFree;

function requireOnExitLeakFree () {
	if (hasRequiredOnExitLeakFree) return onExitLeakFree;
	hasRequiredOnExitLeakFree = 1;

	const refs = {
	  exit: [],
	  beforeExit: []
	};
	const functions = {
	  exit: onExit,
	  beforeExit: onBeforeExit
	};

	let registry;

	function ensureRegistry () {
	  if (registry === undefined) {
	    registry = new FinalizationRegistry(clear);
	  }
	}

	function install (event) {
	  if (refs[event].length > 0) {
	    return
	  }

	  process$1.on(event, functions[event]);
	}

	function uninstall (event) {
	  if (refs[event].length > 0) {
	    return
	  }
	  process$1.removeListener(event, functions[event]);
	  if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
	    registry = undefined;
	  }
	}

	function onExit () {
	  callRefs('exit');
	}

	function onBeforeExit () {
	  callRefs('beforeExit');
	}

	function callRefs (event) {
	  for (const ref of refs[event]) {
	    const obj = ref.deref();
	    const fn = ref.fn;

	    // This should always happen, however GC is
	    // undeterministic so it might not happen.
	    /* istanbul ignore else */
	    if (obj !== undefined) {
	      fn(obj, event);
	    }
	  }
	  refs[event] = [];
	}

	function clear (ref) {
	  for (const event of ['exit', 'beforeExit']) {
	    const index = refs[event].indexOf(ref);
	    refs[event].splice(index, index + 1);
	    uninstall(event);
	  }
	}

	function _register (event, obj, fn) {
	  if (obj === undefined) {
	    throw new Error('the object can\'t be undefined')
	  }
	  install(event);
	  const ref = new WeakRef(obj);
	  ref.fn = fn;

	  ensureRegistry();
	  registry.register(obj, ref);
	  refs[event].push(ref);
	}

	function register (obj, fn) {
	  _register('exit', obj, fn);
	}

	function registerBeforeExit (obj, fn) {
	  _register('beforeExit', obj, fn);
	}

	function unregister (obj) {
	  if (registry === undefined) {
	    return
	  }
	  registry.unregister(obj);
	  for (const event of ['exit', 'beforeExit']) {
	    refs[event] = refs[event].filter((ref) => {
	      const _obj = ref.deref();
	      return _obj && _obj !== obj
	    });
	    uninstall(event);
	  }
	}

	onExitLeakFree = {
	  register,
	  registerBeforeExit,
	  unregister
	};
	return onExitLeakFree;
}

var buildSafeSonicBoom_1;
var hasRequiredBuildSafeSonicBoom;

function requireBuildSafeSonicBoom () {
	if (hasRequiredBuildSafeSonicBoom) return buildSafeSonicBoom_1;
	hasRequiredBuildSafeSonicBoom = 1;
	var define_process_env_default = {};
	buildSafeSonicBoom_1 = buildSafeSonicBoom;
	const { isMainThread } = require$$0;
	const SonicBoom = requireSonicBoom();
	const noop = requireNoop();
	function buildSafeSonicBoom(opts) {
	  const stream = new SonicBoom(opts);
	  stream.on("error", filterBrokenPipe);
	  if (!define_process_env_default.NODE_V8_COVERAGE && !opts.sync && isMainThread) {
	    setupOnExit(stream);
	  }
	  return stream;
	  function filterBrokenPipe(err) {
	    if (err.code === "EPIPE") {
	      stream.write = noop;
	      stream.end = noop;
	      stream.flushSync = noop;
	      stream.destroy = noop;
	      return;
	    }
	    stream.removeListener("error", filterBrokenPipe);
	  }
	}
	function setupOnExit(stream) {
	  if (globalThis.WeakRef && globalThis.WeakMap && globalThis.FinalizationRegistry) {
	    const onExit = requireOnExitLeakFree();
	    onExit.register(stream, autoEnd);
	    stream.on("close", function() {
	      onExit.unregister(stream);
	    });
	  }
	}
	function autoEnd(stream, eventName) {
	  if (stream.destroyed) {
	    return;
	  }
	  if (eventName === "beforeExit") {
	    stream.flush();
	    stream.on("drain", function() {
	      stream.end();
	    });
	  } else {
	    stream.flushSync();
	  }
	}
	return buildSafeSonicBoom_1;
}

var isValidDate_1;
var hasRequiredIsValidDate;

function requireIsValidDate () {
	if (hasRequiredIsValidDate) return isValidDate_1;
	hasRequiredIsValidDate = 1;

	isValidDate_1 = isValidDate;

	/**
	 * Checks if the argument is a JS Date and not 'Invalid Date'.
	 *
	 * @param {Date} date The date to check.
	 *
	 * @returns {boolean} true if the argument is a JS Date and not 'Invalid Date'.
	 */
	function isValidDate (date) {
	  return date instanceof Date && !Number.isNaN(date.getTime())
	}
	return isValidDate_1;
}

var createDate_1;
var hasRequiredCreateDate;

function requireCreateDate () {
	if (hasRequiredCreateDate) return createDate_1;
	hasRequiredCreateDate = 1;

	createDate_1 = createDate;

	const isValidDate = requireIsValidDate();

	/**
	 * Constructs a JS Date from a number or string. Accepts any single number
	 * or single string argument that is valid for the Date() constructor,
	 * or an epoch as a string.
	 *
	 * @param {string|number} epoch The representation of the Date.
	 *
	 * @returns {Date} The constructed Date.
	 */
	function createDate (epoch) {
	  // If epoch is already a valid argument, return the valid Date
	  let date = new Date(epoch);
	  if (isValidDate(date)) {
	    return date
	  }

	  // Convert to a number to permit epoch as a string
	  date = new Date(+epoch);
	  return date
	}
	return createDate_1;
}

var splitPropertyKey_1;
var hasRequiredSplitPropertyKey;

function requireSplitPropertyKey () {
	if (hasRequiredSplitPropertyKey) return splitPropertyKey_1;
	hasRequiredSplitPropertyKey = 1;

	splitPropertyKey_1 = splitPropertyKey;

	/**
	 * Splits the property key delimited by a dot character but not when it is preceded
	 * by a backslash.
	 *
	 * @param {string} key A string identifying the property.
	 *
	 * @returns {string[]} Returns a list of string containing each delimited property.
	 * e.g. `'prop2\.domain\.corp.prop2'` should return [ 'prop2.domain.com', 'prop2' ]
	 */
	function splitPropertyKey (key) {
	  const result = [];
	  let backslash = false;
	  let segment = '';

	  for (let i = 0; i < key.length; i++) {
	    const c = key.charAt(i);

	    if (c === '\\') {
	      backslash = true;
	      continue
	    }

	    if (backslash) {
	      backslash = false;
	      segment += c;
	      continue
	    }

	    /* Non-escaped dot, push to result */
	    if (c === '.') {
	      result.push(segment);
	      segment = '';
	      continue
	    }

	    segment += c;
	  }

	  /* Push last entry to result */
	  if (segment.length) {
	    result.push(segment);
	  }

	  return result
	}
	return splitPropertyKey_1;
}

var getPropertyValue_1;
var hasRequiredGetPropertyValue;

function requireGetPropertyValue () {
	if (hasRequiredGetPropertyValue) return getPropertyValue_1;
	hasRequiredGetPropertyValue = 1;

	getPropertyValue_1 = getPropertyValue;

	const splitPropertyKey = requireSplitPropertyKey();

	/**
	 * Gets a specified property from an object if it exists.
	 *
	 * @param {object} obj The object to be searched.
	 * @param {string|string[]} property A string, or an array of strings, identifying
	 * the property to be retrieved from the object.
	 * Accepts nested properties delimited by a `.`.
	 * Delimiter can be escaped to preserve property names that contain the delimiter.
	 * e.g. `'prop1.prop2'` or `'prop2\.domain\.corp.prop2'`.
	 *
	 * @returns {*}
	 */
	function getPropertyValue (obj, property) {
	  const props = Array.isArray(property) ? property : splitPropertyKey(property);

	  for (const prop of props) {
	    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
	      return
	    }
	    obj = obj[prop];
	  }

	  return obj
	}
	return getPropertyValue_1;
}

var deleteLogProperty_1;
var hasRequiredDeleteLogProperty;

function requireDeleteLogProperty () {
	if (hasRequiredDeleteLogProperty) return deleteLogProperty_1;
	hasRequiredDeleteLogProperty = 1;

	deleteLogProperty_1 = deleteLogProperty;

	const getPropertyValue = requireGetPropertyValue();
	const splitPropertyKey = requireSplitPropertyKey();

	/**
	 * Deletes a specified property from a log object if it exists.
	 * This function mutates the passed in `log` object.
	 *
	 * @param {object} log The log object to be modified.
	 * @param {string} property A string identifying the property to be deleted from
	 * the log object. Accepts nested properties delimited by a `.`
	 * Delimiter can be escaped to preserve property names that contain the delimiter.
	 * e.g. `'prop1.prop2'` or `'prop2\.domain\.corp.prop2'`
	 */
	function deleteLogProperty (log, property) {
	  const props = splitPropertyKey(property);
	  const propToDelete = props.pop();

	  log = getPropertyValue(log, props);

	  /* istanbul ignore else */
	  if (log !== null && typeof log === 'object' && Object.prototype.hasOwnProperty.call(log, propToDelete)) {
	    delete log[propToDelete];
	  }
	}
	return deleteLogProperty_1;
}

var cjs = {};

var hasRequiredCjs;

function requireCjs () {
	if (hasRequiredCjs) return cjs;
	hasRequiredCjs = 1;
	Object.defineProperty(cjs, "__esModule", { value: true });
	var toStringFunction = Function.prototype.toString;
	var create = Object.create;
	var toStringObject = Object.prototype.toString;
	var LegacyCache = (
	  /** @class */
	  function() {
	    function LegacyCache2() {
	      this._keys = [];
	      this._values = [];
	    }
	    LegacyCache2.prototype.has = function(key) {
	      return !!~this._keys.indexOf(key);
	    };
	    LegacyCache2.prototype.get = function(key) {
	      return this._values[this._keys.indexOf(key)];
	    };
	    LegacyCache2.prototype.set = function(key, value) {
	      this._keys.push(key);
	      this._values.push(value);
	    };
	    return LegacyCache2;
	  }()
	);
	function createCacheLegacy() {
	  return new LegacyCache();
	}
	function createCacheModern() {
	  return /* @__PURE__ */ new WeakMap();
	}
	var createCache = typeof WeakMap !== "undefined" ? createCacheModern : createCacheLegacy;
	function getCleanClone(prototype) {
	  if (!prototype) {
	    return create(null);
	  }
	  var Constructor = prototype.constructor;
	  if (Constructor === Object) {
	    return prototype === Object.prototype ? {} : create(prototype);
	  }
	  if (Constructor && ~toStringFunction.call(Constructor).indexOf("[native code]")) {
	    try {
	      return new Constructor();
	    } catch (_a2) {
	    }
	  }
	  return create(prototype);
	}
	function getRegExpFlagsLegacy(regExp) {
	  var flags = "";
	  if (regExp.global) {
	    flags += "g";
	  }
	  if (regExp.ignoreCase) {
	    flags += "i";
	  }
	  if (regExp.multiline) {
	    flags += "m";
	  }
	  if (regExp.unicode) {
	    flags += "u";
	  }
	  if (regExp.sticky) {
	    flags += "y";
	  }
	  return flags;
	}
	function getRegExpFlagsModern(regExp) {
	  return regExp.flags;
	}
	var getRegExpFlags = /test/g.flags === "g" ? getRegExpFlagsModern : getRegExpFlagsLegacy;
	function getTagLegacy(value) {
	  var type = toStringObject.call(value);
	  return type.substring(8, type.length - 1);
	}
	function getTagModern(value) {
	  return value[Symbol.toStringTag] || getTagLegacy(value);
	}
	var getTag = typeof Symbol !== "undefined" ? getTagModern : getTagLegacy;
	var defineProperty = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var _a = Object.prototype, hasOwnProperty = _a.hasOwnProperty, propertyIsEnumerable = _a.propertyIsEnumerable;
	var SUPPORTS_SYMBOL = typeof getOwnPropertySymbols === "function";
	function getStrictPropertiesModern(object) {
	  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
	}
	var getStrictProperties = SUPPORTS_SYMBOL ? getStrictPropertiesModern : getOwnPropertyNames;
	function copyOwnPropertiesStrict(value, clone, state) {
	  var properties = getStrictProperties(value);
	  for (var index2 = 0, length_1 = properties.length, property = void 0, descriptor = void 0; index2 < length_1; ++index2) {
	    property = properties[index2];
	    if (property === "callee" || property === "caller") {
	      continue;
	    }
	    descriptor = getOwnPropertyDescriptor(value, property);
	    if (!descriptor) {
	      clone[property] = state.copier(value[property], state);
	      continue;
	    }
	    if (!descriptor.get && !descriptor.set) {
	      descriptor.value = state.copier(descriptor.value, state);
	    }
	    try {
	      defineProperty(clone, property, descriptor);
	    } catch (error) {
	      clone[property] = descriptor.value;
	    }
	  }
	  return clone;
	}
	function copyArrayLoose(array, state) {
	  var clone = new state.Constructor();
	  state.cache.set(array, clone);
	  for (var index2 = 0, length_2 = array.length; index2 < length_2; ++index2) {
	    clone[index2] = state.copier(array[index2], state);
	  }
	  return clone;
	}
	function copyArrayStrict(array, state) {
	  var clone = new state.Constructor();
	  state.cache.set(array, clone);
	  return copyOwnPropertiesStrict(array, clone, state);
	}
	function copyArrayBuffer(arrayBuffer, _state) {
	  return arrayBuffer.slice(0);
	}
	function copyBlob(blob, _state) {
	  return blob.slice(0, blob.size, blob.type);
	}
	function copyDataView(dataView, state) {
	  return new state.Constructor(copyArrayBuffer(dataView.buffer));
	}
	function copyDate(date, state) {
	  return new state.Constructor(date.getTime());
	}
	function copyMapLoose(map, state) {
	  var clone = new state.Constructor();
	  state.cache.set(map, clone);
	  map.forEach(function(value, key) {
	    clone.set(key, state.copier(value, state));
	  });
	  return clone;
	}
	function copyMapStrict(map, state) {
	  return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);
	}
	function copyObjectLooseLegacy(object, state) {
	  var clone = getCleanClone(state.prototype);
	  state.cache.set(object, clone);
	  for (var key in object) {
	    if (hasOwnProperty.call(object, key)) {
	      clone[key] = state.copier(object[key], state);
	    }
	  }
	  return clone;
	}
	function copyObjectLooseModern(object, state) {
	  var clone = getCleanClone(state.prototype);
	  state.cache.set(object, clone);
	  for (var key in object) {
	    if (hasOwnProperty.call(object, key)) {
	      clone[key] = state.copier(object[key], state);
	    }
	  }
	  var symbols = getOwnPropertySymbols(object);
	  for (var index2 = 0, length_3 = symbols.length, symbol = void 0; index2 < length_3; ++index2) {
	    symbol = symbols[index2];
	    if (propertyIsEnumerable.call(object, symbol)) {
	      clone[symbol] = state.copier(object[symbol], state);
	    }
	  }
	  return clone;
	}
	var copyObjectLoose = SUPPORTS_SYMBOL ? copyObjectLooseModern : copyObjectLooseLegacy;
	function copyObjectStrict(object, state) {
	  var clone = getCleanClone(state.prototype);
	  state.cache.set(object, clone);
	  return copyOwnPropertiesStrict(object, clone, state);
	}
	function copyPrimitiveWrapper(primitiveObject, state) {
	  return new state.Constructor(primitiveObject.valueOf());
	}
	function copyRegExp(regExp, state) {
	  var clone = new state.Constructor(regExp.source, getRegExpFlags(regExp));
	  clone.lastIndex = regExp.lastIndex;
	  return clone;
	}
	function copySelf(value, _state) {
	  return value;
	}
	function copySetLoose(set, state) {
	  var clone = new state.Constructor();
	  state.cache.set(set, clone);
	  set.forEach(function(value) {
	    clone.add(state.copier(value, state));
	  });
	  return clone;
	}
	function copySetStrict(set, state) {
	  return copyOwnPropertiesStrict(set, copySetLoose(set, state), state);
	}
	var isArray = Array.isArray;
	var assign = Object.assign;
	var getPrototypeOf = Object.getPrototypeOf || function(obj) {
	  return obj.__proto__;
	};
	var DEFAULT_LOOSE_OPTIONS = {
	  array: copyArrayLoose,
	  arrayBuffer: copyArrayBuffer,
	  blob: copyBlob,
	  dataView: copyDataView,
	  date: copyDate,
	  error: copySelf,
	  map: copyMapLoose,
	  object: copyObjectLoose,
	  regExp: copyRegExp,
	  set: copySetLoose
	};
	var DEFAULT_STRICT_OPTIONS = assign({}, DEFAULT_LOOSE_OPTIONS, {
	  array: copyArrayStrict,
	  map: copyMapStrict,
	  object: copyObjectStrict,
	  set: copySetStrict
	});
	function getTagSpecificCopiers(options) {
	  return {
	    Arguments: options.object,
	    Array: options.array,
	    ArrayBuffer: options.arrayBuffer,
	    Blob: options.blob,
	    Boolean: copyPrimitiveWrapper,
	    DataView: options.dataView,
	    Date: options.date,
	    Error: options.error,
	    Float32Array: options.arrayBuffer,
	    Float64Array: options.arrayBuffer,
	    Int8Array: options.arrayBuffer,
	    Int16Array: options.arrayBuffer,
	    Int32Array: options.arrayBuffer,
	    Map: options.map,
	    Number: copyPrimitiveWrapper,
	    Object: options.object,
	    Promise: copySelf,
	    RegExp: options.regExp,
	    Set: options.set,
	    String: copyPrimitiveWrapper,
	    WeakMap: copySelf,
	    WeakSet: copySelf,
	    Uint8Array: options.arrayBuffer,
	    Uint8ClampedArray: options.arrayBuffer,
	    Uint16Array: options.arrayBuffer,
	    Uint32Array: options.arrayBuffer,
	    Uint64Array: options.arrayBuffer
	  };
	}
	function createCopier(options) {
	  var normalizedOptions = assign({}, DEFAULT_LOOSE_OPTIONS, options);
	  var tagSpecificCopiers = getTagSpecificCopiers(normalizedOptions);
	  var array = tagSpecificCopiers.Array, object = tagSpecificCopiers.Object;
	  function copier(value, state) {
	    state.prototype = state.Constructor = void 0;
	    if (!value || typeof value !== "object") {
	      return value;
	    }
	    if (state.cache.has(value)) {
	      return state.cache.get(value);
	    }
	    state.prototype = getPrototypeOf(value);
	    state.Constructor = state.prototype && state.prototype.constructor;
	    if (!state.Constructor || state.Constructor === Object) {
	      return object(value, state);
	    }
	    if (isArray(value)) {
	      return array(value, state);
	    }
	    var tagSpecificCopier = tagSpecificCopiers[getTag(value)];
	    if (tagSpecificCopier) {
	      return tagSpecificCopier(value, state);
	    }
	    return typeof value.then === "function" ? value : object(value, state);
	  }
	  return function copy(value) {
	    return copier(value, {
	      Constructor: void 0,
	      cache: createCache(),
	      copier,
	      prototype: void 0
	    });
	  };
	}
	function createStrictCopier(options) {
	  return createCopier(assign({}, DEFAULT_STRICT_OPTIONS, options));
	}
	var copyStrict = createStrictCopier({});
	var index = createCopier({});
	cjs.copyStrict = copyStrict;
	cjs.createCopier = createCopier;
	cjs.createStrictCopier = createStrictCopier;
	cjs.default = index;
	return cjs;
}

var filterLog_1;
var hasRequiredFilterLog;

function requireFilterLog () {
	if (hasRequiredFilterLog) return filterLog_1;
	hasRequiredFilterLog = 1;

	filterLog_1 = filterLog;

	const { createCopier } = requireCjs();
	const fastCopy = createCopier({});

	const deleteLogProperty = requireDeleteLogProperty();

	/**
	 * @typedef {object} FilterLogParams
	 * @property {object} log The log object to be modified.
	 * @property {PrettyContext} context The context object built from parsing
	 * the options.
	 */

	/**
	 * Filter a log object by removing or including keys accordingly.
	 * When `includeKeys` is passed, `ignoredKeys` will be ignored.
	 * One of ignoreKeys or includeKeys must be pass in.
	 *
	 * @param {FilterLogParams} input
	 *
	 * @returns {object} A new `log` object instance that
	 *  either only includes the keys in ignoreKeys
	 *  or does not include those in ignoredKeys.
	 */
	function filterLog ({ log, context }) {
	  const { ignoreKeys, includeKeys } = context;
	  const logCopy = fastCopy(log);

	  if (includeKeys) {
	    const logIncluded = {};

	    includeKeys.forEach((key) => {
	      logIncluded[key] = logCopy[key];
	    });
	    return logIncluded
	  }

	  ignoreKeys.forEach((ignoreKey) => {
	    deleteLogProperty(logCopy, ignoreKey);
	  });
	  return logCopy
	}
	return filterLog_1;
}

var dateformat = {exports: {}};

var hasRequiredDateformat;

function requireDateformat () {
	if (hasRequiredDateformat) return dateformat.exports;
	hasRequiredDateformat = 1;
	(function (module, exports) {
		function _typeof(obj) {
		  "@babel/helpers - typeof";
		  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
		    _typeof = function _typeof2(obj2) {
		      return typeof obj2;
		    };
		  } else {
		    _typeof = function _typeof2(obj2) {
		      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
		    };
		  }
		  return _typeof(obj);
		}
		(function(global) {
		  var _arguments = arguments;
		  var dateFormat = /* @__PURE__ */ function() {
		    var token = /d{1,4}|D{3,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|W{1,2}|[LlopSZN]|"[^"]*"|'[^']*'/g;
		    var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
		    var timezoneClip = /[^-+\dA-Z]/g;
		    return function(date, mask, utc, gmt) {
		      if (_arguments.length === 1 && kindOf(date) === "string" && !/\d/.test(date)) {
		        mask = date;
		        date = void 0;
		      }
		      date = date || date === 0 ? date : /* @__PURE__ */ new Date();
		      if (!(date instanceof Date)) {
		        date = new Date(date);
		      }
		      if (isNaN(date)) {
		        throw TypeError("Invalid date");
		      }
		      mask = String(dateFormat.masks[mask] || mask || dateFormat.masks["default"]);
		      var maskSlice = mask.slice(0, 4);
		      if (maskSlice === "UTC:" || maskSlice === "GMT:") {
		        mask = mask.slice(4);
		        utc = true;
		        if (maskSlice === "GMT:") {
		          gmt = true;
		        }
		      }
		      var _ = function _2() {
		        return utc ? "getUTC" : "get";
		      };
		      var _d = function d() {
		        return date[_() + "Date"]();
		      };
		      var D = function D2() {
		        return date[_() + "Day"]();
		      };
		      var _m = function m() {
		        return date[_() + "Month"]();
		      };
		      var y = function y2() {
		        return date[_() + "FullYear"]();
		      };
		      var _H = function H() {
		        return date[_() + "Hours"]();
		      };
		      var _M = function M() {
		        return date[_() + "Minutes"]();
		      };
		      var _s = function s() {
		        return date[_() + "Seconds"]();
		      };
		      var _L = function L() {
		        return date[_() + "Milliseconds"]();
		      };
		      var _o = function o() {
		        return utc ? 0 : date.getTimezoneOffset();
		      };
		      var _W = function W() {
		        return getWeek(date);
		      };
		      var _N = function N() {
		        return getDayOfWeek(date);
		      };
		      var flags = { d: function d() {
		        return _d();
		      }, dd: function dd() {
		        return pad(_d());
		      }, ddd: function ddd() {
		        return dateFormat.i18n.dayNames[D()];
		      }, DDD: function DDD() {
		        return getDayName({ y: y(), m: _m(), d: _d(), _: _(), dayName: dateFormat.i18n.dayNames[D()], short: true });
		      }, dddd: function dddd() {
		        return dateFormat.i18n.dayNames[D() + 7];
		      }, DDDD: function DDDD() {
		        return getDayName({ y: y(), m: _m(), d: _d(), _: _(), dayName: dateFormat.i18n.dayNames[D() + 7] });
		      }, m: function m() {
		        return _m() + 1;
		      }, mm: function mm() {
		        return pad(_m() + 1);
		      }, mmm: function mmm() {
		        return dateFormat.i18n.monthNames[_m()];
		      }, mmmm: function mmmm() {
		        return dateFormat.i18n.monthNames[_m() + 12];
		      }, yy: function yy() {
		        return String(y()).slice(2);
		      }, yyyy: function yyyy() {
		        return pad(y(), 4);
		      }, h: function h() {
		        return _H() % 12 || 12;
		      }, hh: function hh() {
		        return pad(_H() % 12 || 12);
		      }, H: function H() {
		        return _H();
		      }, HH: function HH() {
		        return pad(_H());
		      }, M: function M() {
		        return _M();
		      }, MM: function MM() {
		        return pad(_M());
		      }, s: function s() {
		        return _s();
		      }, ss: function ss() {
		        return pad(_s());
		      }, l: function l() {
		        return pad(_L(), 3);
		      }, L: function L() {
		        return pad(Math.floor(_L() / 10));
		      }, t: function t() {
		        return _H() < 12 ? dateFormat.i18n.timeNames[0] : dateFormat.i18n.timeNames[1];
		      }, tt: function tt() {
		        return _H() < 12 ? dateFormat.i18n.timeNames[2] : dateFormat.i18n.timeNames[3];
		      }, T: function T() {
		        return _H() < 12 ? dateFormat.i18n.timeNames[4] : dateFormat.i18n.timeNames[5];
		      }, TT: function TT() {
		        return _H() < 12 ? dateFormat.i18n.timeNames[6] : dateFormat.i18n.timeNames[7];
		      }, Z: function Z() {
		        return gmt ? "GMT" : utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, "").replace(/GMT\+0000/g, "UTC");
		      }, o: function o() {
		        return (_o() > 0 ? "-" : "+") + pad(Math.floor(Math.abs(_o()) / 60) * 100 + Math.abs(_o()) % 60, 4);
		      }, p: function p() {
		        return (_o() > 0 ? "-" : "+") + pad(Math.floor(Math.abs(_o()) / 60), 2) + ":" + pad(Math.floor(Math.abs(_o()) % 60), 2);
		      }, S: function S() {
		        return ["th", "st", "nd", "rd"][_d() % 10 > 3 ? 0 : (_d() % 100 - _d() % 10 != 10) * _d() % 10];
		      }, W: function W() {
		        return _W();
		      }, WW: function WW() {
		        return pad(_W());
		      }, N: function N() {
		        return _N();
		      } };
		      return mask.replace(token, function(match) {
		        if (match in flags) {
		          return flags[match]();
		        }
		        return match.slice(1, match.length - 1);
		      });
		    };
		  }();
		  dateFormat.masks = { default: "ddd mmm dd yyyy HH:MM:ss", shortDate: "m/d/yy", paddedShortDate: "mm/dd/yyyy", mediumDate: "mmm d, yyyy", longDate: "mmmm d, yyyy", fullDate: "dddd, mmmm d, yyyy", shortTime: "h:MM TT", mediumTime: "h:MM:ss TT", longTime: "h:MM:ss TT Z", isoDate: "yyyy-mm-dd", isoTime: "HH:MM:ss", isoDateTime: "yyyy-mm-dd'T'HH:MM:sso", isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'", expiresHeaderFormat: "ddd, dd mmm yyyy HH:MM:ss Z" };
		  dateFormat.i18n = { dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], timeNames: ["a", "p", "am", "pm", "A", "P", "AM", "PM"] };
		  var pad = function pad2(val, len) {
		    val = String(val);
		    len = len || 2;
		    while (val.length < len) {
		      val = "0" + val;
		    }
		    return val;
		  };
		  var getDayName = function getDayName2(_ref) {
		    var y = _ref.y, m = _ref.m, d = _ref.d, _ = _ref._, dayName = _ref.dayName, _ref$short = _ref["short"], _short = _ref$short === void 0 ? false : _ref$short;
		    var today = /* @__PURE__ */ new Date();
		    var yesterday = /* @__PURE__ */ new Date();
		    yesterday.setDate(yesterday[_ + "Date"]() - 1);
		    var tomorrow = /* @__PURE__ */ new Date();
		    tomorrow.setDate(tomorrow[_ + "Date"]() + 1);
		    var today_d = function today_d2() {
		      return today[_ + "Date"]();
		    };
		    var today_m = function today_m2() {
		      return today[_ + "Month"]();
		    };
		    var today_y = function today_y2() {
		      return today[_ + "FullYear"]();
		    };
		    var yesterday_d = function yesterday_d2() {
		      return yesterday[_ + "Date"]();
		    };
		    var yesterday_m = function yesterday_m2() {
		      return yesterday[_ + "Month"]();
		    };
		    var yesterday_y = function yesterday_y2() {
		      return yesterday[_ + "FullYear"]();
		    };
		    var tomorrow_d = function tomorrow_d2() {
		      return tomorrow[_ + "Date"]();
		    };
		    var tomorrow_m = function tomorrow_m2() {
		      return tomorrow[_ + "Month"]();
		    };
		    var tomorrow_y = function tomorrow_y2() {
		      return tomorrow[_ + "FullYear"]();
		    };
		    if (today_y() === y && today_m() === m && today_d() === d) {
		      return _short ? "Tdy" : "Today";
		    } else if (yesterday_y() === y && yesterday_m() === m && yesterday_d() === d) {
		      return _short ? "Ysd" : "Yesterday";
		    } else if (tomorrow_y() === y && tomorrow_m() === m && tomorrow_d() === d) {
		      return _short ? "Tmw" : "Tomorrow";
		    }
		    return dayName;
		  };
		  var getWeek = function getWeek2(date) {
		    var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());
		    targetThursday.setDate(targetThursday.getDate() - (targetThursday.getDay() + 6) % 7 + 3);
		    var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);
		    firstThursday.setDate(firstThursday.getDate() - (firstThursday.getDay() + 6) % 7 + 3);
		    var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
		    targetThursday.setHours(targetThursday.getHours() - ds);
		    var weekDiff = (targetThursday - firstThursday) / (864e5 * 7);
		    return 1 + Math.floor(weekDiff);
		  };
		  var getDayOfWeek = function getDayOfWeek2(date) {
		    var dow = date.getDay();
		    if (dow === 0) {
		      dow = 7;
		    }
		    return dow;
		  };
		  var kindOf = function kindOf2(val) {
		    if (val === null) {
		      return "null";
		    }
		    if (val === void 0) {
		      return "undefined";
		    }
		    if (_typeof(val) !== "object") {
		      return _typeof(val);
		    }
		    if (Array.isArray(val)) {
		      return "array";
		    }
		    return {}.toString.call(val).slice(8, -1).toLowerCase();
		  };
		  if ((_typeof(exports)) === "object") {
		    module.exports = dateFormat;
		  } else {
		    global.dateFormat = dateFormat;
		  }
		})(void 0); 
	} (dateformat, dateformat.exports));
	return dateformat.exports;
}

var formatTime_1;
var hasRequiredFormatTime;

function requireFormatTime () {
	if (hasRequiredFormatTime) return formatTime_1;
	hasRequiredFormatTime = 1;

	formatTime_1 = formatTime;

	const {
	  DATE_FORMAT,
	  DATE_FORMAT_SIMPLE
	} = requireConstants();

	const dateformat = requireDateformat();
	const createDate = requireCreateDate();
	const isValidDate = requireIsValidDate();

	/**
	 * Converts a given `epoch` to a desired display format.
	 *
	 * @param {number|string} epoch The time to convert. May be any value that is
	 * valid for `new Date()`.
	 * @param {boolean|string} [translateTime=false] When `false`, the given `epoch`
	 * will simply be returned. When `true`, the given `epoch` will be converted
	 * to a string at UTC using the `DATE_FORMAT` constant. If `translateTime` is
	 * a string, the following rules are available:
	 *
	 * - `<format string>`: The string is a literal format string. This format
	 * string will be used to interpret the `epoch` and return a display string
	 * at UTC.
	 * - `SYS:STANDARD`: The returned display string will follow the `DATE_FORMAT`
	 * constant at the system's local timezone.
	 * - `SYS:<format string>`: The returned display string will follow the given
	 * `<format string>` at the system's local timezone.
	 * - `UTC:<format string>`: The returned display string will follow the given
	 * `<format string>` at UTC.
	 *
	 * @returns {number|string} The formatted time.
	 */
	function formatTime (epoch, translateTime = false) {
	  if (translateTime === false) {
	    return epoch
	  }

	  const instant = createDate(epoch);

	  // If the Date is invalid, do not attempt to format
	  if (!isValidDate(instant)) {
	    return epoch
	  }

	  if (translateTime === true) {
	    return dateformat(instant, DATE_FORMAT_SIMPLE)
	  }

	  const upperFormat = translateTime.toUpperCase();
	  if (upperFormat === 'SYS:STANDARD') {
	    return dateformat(instant, DATE_FORMAT)
	  }

	  const prefix = upperFormat.substr(0, 4);
	  if (prefix === 'SYS:' || prefix === 'UTC:') {
	    if (prefix === 'UTC:') {
	      return dateformat(instant, translateTime)
	    }
	    return dateformat(instant, translateTime.slice(4))
	  }

	  return dateformat(instant, `UTC:${translateTime}`)
	}
	return formatTime_1;
}

var handleCustomLevelsNamesOpts_1;
var hasRequiredHandleCustomLevelsNamesOpts;

function requireHandleCustomLevelsNamesOpts () {
	if (hasRequiredHandleCustomLevelsNamesOpts) return handleCustomLevelsNamesOpts_1;
	hasRequiredHandleCustomLevelsNamesOpts = 1;

	handleCustomLevelsNamesOpts_1 = handleCustomLevelsNamesOpts;

	/**
	 * Parse a CSV string or options object that maps level
	 * labels to level values.
	 *
	 * @param {string|object} cLevels An object mapping level
	 * names to level values, e.g. `{ info: 30, debug: 65 }`, or a
	 * CSV string in the format `level_name:level_value`, e.g.
	 * `info:30,debug:65`.
	 *
	 * @returns {object} An object mapping levels names to level values
	 * e.g. `{ info: 30, debug: 65 }`.
	 */
	function handleCustomLevelsNamesOpts (cLevels) {
	  if (!cLevels) return {}

	  if (typeof cLevels === 'string') {
	    return cLevels
	      .split(',')
	      .reduce((agg, value, idx) => {
	        const [levelName, levelNum = idx] = value.split(':');
	        agg[levelName.toLowerCase()] = levelNum;
	        return agg
	      }, {})
	  } else if (Object.prototype.toString.call(cLevels) === '[object Object]') {
	    return Object
	      .keys(cLevels)
	      .reduce((agg, levelName) => {
	        agg[levelName.toLowerCase()] = cLevels[levelName];
	        return agg
	      }, {})
	  } else {
	    return {}
	  }
	}
	return handleCustomLevelsNamesOpts_1;
}

var handleCustomLevelsOpts_1;
var hasRequiredHandleCustomLevelsOpts;

function requireHandleCustomLevelsOpts () {
	if (hasRequiredHandleCustomLevelsOpts) return handleCustomLevelsOpts_1;
	hasRequiredHandleCustomLevelsOpts = 1;

	handleCustomLevelsOpts_1 = handleCustomLevelsOpts;

	/**
	 * Parse a CSV string or options object that specifies
	 * configuration for custom levels.
	 *
	 * @param {string|object} cLevels An object mapping level
	 * names to values, e.g. `{ info: 30, debug: 65 }`, or a
	 * CSV string in the format `level_name:level_value`, e.g.
	 * `info:30,debug:65`.
	 *
	 * @returns {object} An object mapping levels to labels that
	 * appear in logs, e.g. `{ '30': 'INFO', '65': 'DEBUG' }`.
	 */
	function handleCustomLevelsOpts (cLevels) {
	  if (!cLevels) return {}

	  if (typeof cLevels === 'string') {
	    return cLevels
	      .split(',')
	      .reduce((agg, value, idx) => {
	        const [levelName, levelNum = idx] = value.split(':');
	        agg[levelNum] = levelName.toUpperCase();
	        return agg
	      },
	      { default: 'USERLVL' })
	  } else if (Object.prototype.toString.call(cLevels) === '[object Object]') {
	    return Object
	      .keys(cLevels)
	      .reduce((agg, levelName) => {
	        agg[cLevels[levelName]] = levelName.toUpperCase();
	        return agg
	      }, { default: 'USERLVL' })
	  } else {
	    return {}
	  }
	}
	return handleCustomLevelsOpts_1;
}

var interpretConditionals_1;
var hasRequiredInterpretConditionals;

function requireInterpretConditionals () {
	if (hasRequiredInterpretConditionals) return interpretConditionals_1;
	hasRequiredInterpretConditionals = 1;

	interpretConditionals_1 = interpretConditionals;

	const getPropertyValue = requireGetPropertyValue();

	/**
	 * Translates all conditional blocks from within the messageFormat. Translates
	 * any matching {if key}{key}{end} statements and returns everything between
	 * if and else blocks if the key provided was found in log.
	 *
	 * @param {MessageFormatString|MessageFormatFunction} messageFormat A format
	 * string or function that defines how the logged message should be
	 * conditionally formatted.
	 * @param {object} log The log object to be modified.
	 *
	 * @returns {string} The parsed messageFormat.
	 */
	function interpretConditionals (messageFormat, log) {
	  messageFormat = messageFormat.replace(/{if (.*?)}(.*?){end}/g, replacer);

	  // Remove non-terminated if blocks
	  messageFormat = messageFormat.replace(/{if (.*?)}/g, '');
	  // Remove floating end blocks
	  messageFormat = messageFormat.replace(/{end}/g, '');

	  return messageFormat.replace(/\s+/g, ' ').trim()

	  function replacer (_, key, value) {
	    const propertyValue = getPropertyValue(log, key);
	    if (propertyValue && value.includes(key)) {
	      return value.replace(new RegExp('{' + key + '}', 'g'), propertyValue)
	    } else {
	      return ''
	    }
	  }
	}
	return interpretConditionals_1;
}

var isObject_1;
var hasRequiredIsObject;

function requireIsObject () {
	if (hasRequiredIsObject) return isObject_1;
	hasRequiredIsObject = 1;

	isObject_1 = isObject;

	function isObject (input) {
	  return Object.prototype.toString.apply(input) === '[object Object]'
	}
	return isObject_1;
}

var joinLinesWithIndentation_1;
var hasRequiredJoinLinesWithIndentation;

function requireJoinLinesWithIndentation () {
	if (hasRequiredJoinLinesWithIndentation) return joinLinesWithIndentation_1;
	hasRequiredJoinLinesWithIndentation = 1;

	joinLinesWithIndentation_1 = joinLinesWithIndentation;

	/**
	 * @typedef {object} JoinLinesWithIndentationParams
	 * @property {string} input The string to split and reformat.
	 * @property {string} [ident] The indentation string. Default: `    ` (4 spaces).
	 * @property {string} [eol] The end of line sequence to use when rejoining
	 * the lines. Default: `'\n'`.
	 */

	/**
	 * Given a string with line separators, either `\r\n` or `\n`, add indentation
	 * to all lines subsequent to the first line and rejoin the lines using an
	 * end of line sequence.
	 *
	 * @param {JoinLinesWithIndentationParams} input
	 *
	 * @returns {string} A string with lines subsequent to the first indented
	 * with the given indentation sequence.
	 */
	function joinLinesWithIndentation ({ input, ident = '    ', eol = '\n' }) {
	  const lines = input.split(/\r?\n/);
	  for (let i = 1; i < lines.length; i += 1) {
	    lines[i] = ident + lines[i];
	  }
	  return lines.join(eol)
	}
	return joinLinesWithIndentation_1;
}

var parseFactoryOptions_1;
var hasRequiredParseFactoryOptions;

function requireParseFactoryOptions () {
	if (hasRequiredParseFactoryOptions) return parseFactoryOptions_1;
	hasRequiredParseFactoryOptions = 1;

	parseFactoryOptions_1 = parseFactoryOptions;

	const {
	  LEVEL_NAMES
	} = requireConstants();
	const colors = requireColors();
	const handleCustomLevelsOpts = requireHandleCustomLevelsOpts();
	const handleCustomLevelsNamesOpts = requireHandleCustomLevelsNamesOpts();
	const handleLevelLabelData = requireGetLevelLabelData();

	/**
	 * A `PrettyContext` is an object to be used by the various functions that
	 * process log data. It is derived from the provided {@link PinoPrettyOptions}.
	 * It may be used as a `this` context.
	 *
	 * @typedef {object} PrettyContext
	 * @property {string} EOL The escape sequence chosen as the line terminator.
	 * @property {string} IDENT The string to use as the indentation sequence.
	 * @property {ColorizerFunc} colorizer A configured colorizer function.
	 * @property {Array[Array<number, string>]} customColors A set of custom color
	 * names associated with level numbers.
	 * @property {object} customLevelNames A hash of level numbers to level names,
	 * e.g. `{ 30: "info" }`.
	 * @property {object} customLevels A hash of level names to level numbers,
	 * e.g. `{ info: 30 }`.
	 * @property {CustomPrettifiers} customPrettifiers A hash of custom prettifier
	 * functions.
	 * @property {object} customProperties Comprised of `customLevels` and
	 * `customLevelNames` if such options are provided.
	 * @property {string[]} errorLikeObjectKeys The key names in the log data that
	 * should be considered as holding error objects.
	 * @property {string[]} errorProps A list of error object keys that should be
	 * included in the output.
	 * @property {function} getLevelLabelData Pass a numeric level to return [levelLabelString,levelNum]
	 * @property {boolean} hideObject Indicates the prettifier should omit objects
	 * in the output.
	 * @property {string[]} ignoreKeys Set of log data keys to omit.
	 * @property {string[]} includeKeys Opposite of `ignoreKeys`.
	 * @property {boolean} levelFirst Indicates the level should be printed first.
	 * @property {string} levelKey Name of the key in the log data that contains
	 * the message.
	 * @property {string} levelLabel Format token to represent the position of the
	 * level name in the output string.
	 * @property {MessageFormatString|MessageFormatFunction} messageFormat
	 * @property {string} messageKey Name of the key in the log data that contains
	 * the message.
	 * @property {string|number} minimumLevel The minimum log level to process
	 * and output.
	 * @property {ColorizerFunc} objectColorizer
	 * @property {boolean} singleLine Indicates objects should be printed on a
	 * single output line.
	 * @property {string} timestampKey The name of the key in the log data that
	 * contains the log timestamp.
	 * @property {boolean} translateTime Indicates if timestamps should be
	 * translated to a human-readable string.
	 * @property {boolean} useOnlyCustomProps
	 */

	/**
	 * @param {PinoPrettyOptions} options The user supplied object of options.
	 *
	 * @returns {PrettyContext}
	 */
	function parseFactoryOptions (options) {
	  const EOL = options.crlf ? '\r\n' : '\n';
	  const IDENT = '    ';
	  const {
	    customPrettifiers,
	    errorLikeObjectKeys,
	    hideObject,
	    levelFirst,
	    levelKey,
	    levelLabel,
	    messageFormat,
	    messageKey,
	    minimumLevel,
	    singleLine,
	    timestampKey,
	    translateTime
	  } = options;
	  const errorProps = options.errorProps.split(',');
	  const useOnlyCustomProps = typeof options.useOnlyCustomProps === 'boolean'
	    ? options.useOnlyCustomProps
	    : (options.useOnlyCustomProps === 'true');
	  const customLevels = handleCustomLevelsOpts(options.customLevels);
	  const customLevelNames = handleCustomLevelsNamesOpts(options.customLevels);
	  const getLevelLabelData = handleLevelLabelData(useOnlyCustomProps, customLevels, customLevelNames);

	  let customColors;
	  if (options.customColors) {
	    if (typeof options.customColors === 'string') {
	      customColors = options.customColors.split(',').reduce((agg, value) => {
	        const [level, color] = value.split(':');
	        const condition = useOnlyCustomProps
	          ? options.customLevels
	          : customLevelNames[level] !== undefined;
	        const levelNum = condition
	          ? customLevelNames[level]
	          : LEVEL_NAMES[level];
	        const colorIdx = levelNum !== undefined
	          ? levelNum
	          : level;
	        agg.push([colorIdx, color]);
	        return agg
	      }, []);
	    } else if (typeof options.customColors === 'object') {
	      customColors = Object.keys(options.customColors).reduce((agg, value) => {
	        const [level, color] = [value, options.customColors[value]];
	        const condition = useOnlyCustomProps
	          ? options.customLevels
	          : customLevelNames[level] !== undefined;
	        const levelNum = condition
	          ? customLevelNames[level]
	          : LEVEL_NAMES[level];
	        const colorIdx = levelNum !== undefined
	          ? levelNum
	          : level;
	        agg.push([colorIdx, color]);
	        return agg
	      }, []);
	    } else {
	      throw new Error('options.customColors must be of type string or object.')
	    }
	  }

	  const customProperties = { customLevels, customLevelNames };
	  if (useOnlyCustomProps === true && !options.customLevels) {
	    customProperties.customLevels = undefined;
	    customProperties.customLevelNames = undefined;
	  }

	  const includeKeys = options.include !== undefined
	    ? new Set(options.include.split(','))
	    : undefined;
	  const ignoreKeys = (!includeKeys && options.ignore)
	    ? new Set(options.ignore.split(','))
	    : undefined;

	  const colorizer = colors(options.colorize, customColors, useOnlyCustomProps);
	  const objectColorizer = options.colorizeObjects
	    ? colorizer
	    : colors(false, [], false);

	  return {
	    EOL,
	    IDENT,
	    colorizer,
	    customColors,
	    customLevelNames,
	    customLevels,
	    customPrettifiers,
	    customProperties,
	    errorLikeObjectKeys,
	    errorProps,
	    getLevelLabelData,
	    hideObject,
	    ignoreKeys,
	    includeKeys,
	    levelFirst,
	    levelKey,
	    levelLabel,
	    messageFormat,
	    messageKey,
	    minimumLevel,
	    objectColorizer,
	    singleLine,
	    timestampKey,
	    translateTime,
	    useOnlyCustomProps
	  }
	}
	return parseFactoryOptions_1;
}

var fastSafeStringify;
var hasRequiredFastSafeStringify;

function requireFastSafeStringify () {
	if (hasRequiredFastSafeStringify) return fastSafeStringify;
	hasRequiredFastSafeStringify = 1;
	fastSafeStringify = stringify;
	stringify.default = stringify;
	stringify.stable = deterministicStringify;
	stringify.stableStringify = deterministicStringify;

	var LIMIT_REPLACE_NODE = '[...]';
	var CIRCULAR_REPLACE_NODE = '[Circular]';

	var arr = [];
	var replacerStack = [];

	function defaultOptions () {
	  return {
	    depthLimit: Number.MAX_SAFE_INTEGER,
	    edgesLimit: Number.MAX_SAFE_INTEGER
	  }
	}

	// Regular stringify
	function stringify (obj, replacer, spacer, options) {
	  if (typeof options === 'undefined') {
	    options = defaultOptions();
	  }

	  decirc(obj, '', 0, [], undefined, 0, options);
	  var res;
	  try {
	    if (replacerStack.length === 0) {
	      res = JSON.stringify(obj, replacer, spacer);
	    } else {
	      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
	    }
	  } catch (_) {
	    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
	  } finally {
	    while (arr.length !== 0) {
	      var part = arr.pop();
	      if (part.length === 4) {
	        Object.defineProperty(part[0], part[1], part[3]);
	      } else {
	        part[0][part[1]] = part[2];
	      }
	    }
	  }
	  return res
	}

	function setReplace (replace, val, k, parent) {
	  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
	  if (propertyDescriptor.get !== undefined) {
	    if (propertyDescriptor.configurable) {
	      Object.defineProperty(parent, k, { value: replace });
	      arr.push([parent, k, val, propertyDescriptor]);
	    } else {
	      replacerStack.push([val, k, replace]);
	    }
	  } else {
	    parent[k] = replace;
	    arr.push([parent, k, val]);
	  }
	}

	function decirc (val, k, edgeIndex, stack, parent, depth, options) {
	  depth += 1;
	  var i;
	  if (typeof val === 'object' && val !== null) {
	    for (i = 0; i < stack.length; i++) {
	      if (stack[i] === val) {
	        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
	        return
	      }
	    }

	    if (
	      typeof options.depthLimit !== 'undefined' &&
	      depth > options.depthLimit
	    ) {
	      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
	      return
	    }

	    if (
	      typeof options.edgesLimit !== 'undefined' &&
	      edgeIndex + 1 > options.edgesLimit
	    ) {
	      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
	      return
	    }

	    stack.push(val);
	    // Optimize for Arrays. Big arrays could kill the performance otherwise!
	    if (Array.isArray(val)) {
	      for (i = 0; i < val.length; i++) {
	        decirc(val[i], i, i, stack, val, depth, options);
	      }
	    } else {
	      var keys = Object.keys(val);
	      for (i = 0; i < keys.length; i++) {
	        var key = keys[i];
	        decirc(val[key], key, i, stack, val, depth, options);
	      }
	    }
	    stack.pop();
	  }
	}

	// Stable-stringify
	function compareFunction (a, b) {
	  if (a < b) {
	    return -1
	  }
	  if (a > b) {
	    return 1
	  }
	  return 0
	}

	function deterministicStringify (obj, replacer, spacer, options) {
	  if (typeof options === 'undefined') {
	    options = defaultOptions();
	  }

	  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj;
	  var res;
	  try {
	    if (replacerStack.length === 0) {
	      res = JSON.stringify(tmp, replacer, spacer);
	    } else {
	      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
	    }
	  } catch (_) {
	    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
	  } finally {
	    // Ensure that we restore the object as it was.
	    while (arr.length !== 0) {
	      var part = arr.pop();
	      if (part.length === 4) {
	        Object.defineProperty(part[0], part[1], part[3]);
	      } else {
	        part[0][part[1]] = part[2];
	      }
	    }
	  }
	  return res
	}

	function deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {
	  depth += 1;
	  var i;
	  if (typeof val === 'object' && val !== null) {
	    for (i = 0; i < stack.length; i++) {
	      if (stack[i] === val) {
	        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
	        return
	      }
	    }
	    try {
	      if (typeof val.toJSON === 'function') {
	        return
	      }
	    } catch (_) {
	      return
	    }

	    if (
	      typeof options.depthLimit !== 'undefined' &&
	      depth > options.depthLimit
	    ) {
	      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
	      return
	    }

	    if (
	      typeof options.edgesLimit !== 'undefined' &&
	      edgeIndex + 1 > options.edgesLimit
	    ) {
	      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
	      return
	    }

	    stack.push(val);
	    // Optimize for Arrays. Big arrays could kill the performance otherwise!
	    if (Array.isArray(val)) {
	      for (i = 0; i < val.length; i++) {
	        deterministicDecirc(val[i], i, i, stack, val, depth, options);
	      }
	    } else {
	      // Create a temporary object in the required way
	      var tmp = {};
	      var keys = Object.keys(val).sort(compareFunction);
	      for (i = 0; i < keys.length; i++) {
	        var key = keys[i];
	        deterministicDecirc(val[key], key, i, stack, val, depth, options);
	        tmp[key] = val[key];
	      }
	      if (typeof parent !== 'undefined') {
	        arr.push([parent, k, val]);
	        parent[k] = tmp;
	      } else {
	        return tmp
	      }
	    }
	    stack.pop();
	  }
	}

	// wraps replacer function to handle values we couldn't replace
	// and mark them as replaced value
	function replaceGetterValues (replacer) {
	  replacer =
	    typeof replacer !== 'undefined'
	      ? replacer
	      : function (k, v) {
	        return v
	      };
	  return function (key, val) {
	    if (replacerStack.length > 0) {
	      for (var i = 0; i < replacerStack.length; i++) {
	        var part = replacerStack[i];
	        if (part[1] === key && part[0] === val) {
	          val = part[2];
	          replacerStack.splice(i, 1);
	          break
	        }
	      }
	    }
	    return replacer.call(this, key, val)
	  }
	}
	return fastSafeStringify;
}

var prettifyError_1;
var hasRequiredPrettifyError;

function requirePrettifyError () {
	if (hasRequiredPrettifyError) return prettifyError_1;
	hasRequiredPrettifyError = 1;

	prettifyError_1 = prettifyError;

	const joinLinesWithIndentation = requireJoinLinesWithIndentation();

	/**
	 * @typedef {object} PrettifyErrorParams
	 * @property {string} keyName The key assigned to this error in the log object.
	 * @property {string} lines The STRINGIFIED error. If the error field has a
	 *  custom prettifier, that should be pre-applied as well.
	 * @property {string} ident The indentation sequence to use.
	 * @property {string} eol The EOL sequence to use.
	 */

	/**
	 * Prettifies an error string into a multi-line format.
	 *
	 * @param {PrettifyErrorParams} input
	 *
	 * @returns {string}
	 */
	function prettifyError ({ keyName, lines, eol, ident }) {
	  let result = '';
	  const joinedLines = joinLinesWithIndentation({ input: lines, ident, eol });
	  const splitLines = `${ident}${keyName}: ${joinedLines}${eol}`.split(eol);

	  for (let j = 0; j < splitLines.length; j += 1) {
	    if (j !== 0) result += eol;

	    const line = splitLines[j];
	    if (/^\s*"stack"/.test(line)) {
	      const matches = /^(\s*"stack":)\s*(".*"),?$/.exec(line);
	      /* istanbul ignore else */
	      if (matches && matches.length === 3) {
	        const indentSize = /^\s*/.exec(line)[0].length + 4;
	        const indentation = ' '.repeat(indentSize);
	        const stackMessage = matches[2];
	        result += matches[1] + eol + indentation + JSON.parse(stackMessage).replace(/\n/g, eol + indentation);
	      } else {
	        result += line;
	      }
	    } else {
	      result += line;
	    }
	  }

	  return result
	}
	return prettifyError_1;
}

var prettifyObject_1;
var hasRequiredPrettifyObject;

function requirePrettifyObject () {
	if (hasRequiredPrettifyObject) return prettifyObject_1;
	hasRequiredPrettifyObject = 1;

	prettifyObject_1 = prettifyObject;

	const {
	  LOGGER_KEYS
	} = requireConstants();

	const stringifySafe = requireFastSafeStringify();
	const joinLinesWithIndentation = requireJoinLinesWithIndentation();
	const prettifyError = requirePrettifyError();

	/**
	 * @typedef {object} PrettifyObjectParams
	 * @property {object} log The object to prettify.
	 * @property {boolean} [excludeLoggerKeys] Indicates if known logger specific
	 * keys should be excluded from prettification. Default: `true`.
	 * @property {string[]} [skipKeys] A set of object keys to exclude from the
	 *  * prettified result. Default: `[]`.
	 * @property {PrettyContext} context The context object built from parsing
	 * the options.
	 */

	/**
	 * Prettifies a standard object. Special care is taken when processing the object
	 * to handle child objects that are attached to keys known to contain error
	 * objects.
	 *
	 * @param {PrettifyObjectParams} input
	 *
	 * @returns {string} The prettified string. This can be as little as `''` if
	 * there was nothing to prettify.
	 */
	function prettifyObject ({
	  log,
	  excludeLoggerKeys = true,
	  skipKeys = [],
	  context
	}) {
	  const {
	    EOL: eol,
	    IDENT: ident,
	    customPrettifiers,
	    errorLikeObjectKeys: errorLikeKeys,
	    objectColorizer,
	    singleLine,
	    colorizer
	  } = context;
	  const keysToIgnore = [].concat(skipKeys);

	  /* istanbul ignore else */
	  if (excludeLoggerKeys === true) Array.prototype.push.apply(keysToIgnore, LOGGER_KEYS);

	  let result = '';

	  // Split object keys into two categories: error and non-error
	  const { plain, errors } = Object.entries(log).reduce(({ plain, errors }, [k, v]) => {
	    if (keysToIgnore.includes(k) === false) {
	      // Pre-apply custom prettifiers, because all 3 cases below will need this
	      const pretty = typeof customPrettifiers[k] === 'function'
	        ? customPrettifiers[k](v, k, log, { colors: colorizer.colors })
	        : v;
	      if (errorLikeKeys.includes(k)) {
	        errors[k] = pretty;
	      } else {
	        plain[k] = pretty;
	      }
	    }
	    return { plain, errors }
	  }, { plain: {}, errors: {} });

	  if (singleLine) {
	    // Stringify the entire object as a single JSON line
	    /* istanbul ignore else */
	    if (Object.keys(plain).length > 0) {
	      result += objectColorizer.greyMessage(stringifySafe(plain));
	    }
	    result += eol;
	    // Avoid printing the escape character on escaped backslashes.
	    result = result.replace(/\\\\/gi, '\\');
	  } else {
	    // Put each object entry on its own line
	    Object.entries(plain).forEach(([keyName, keyValue]) => {
	      // custom prettifiers are already applied above, so we can skip it now
	      let lines = typeof customPrettifiers[keyName] === 'function'
	        ? keyValue
	        : stringifySafe(keyValue, null, 2);

	      if (lines === undefined) return

	      // Avoid printing the escape character on escaped backslashes.
	      lines = lines.replace(/\\\\/gi, '\\');

	      const joinedLines = joinLinesWithIndentation({ input: lines, ident, eol });
	      result += `${ident}${keyName}:${joinedLines.startsWith(eol) ? '' : ' '}${joinedLines}${eol}`;
	    });
	  }

	  // Errors
	  Object.entries(errors).forEach(([keyName, keyValue]) => {
	    // custom prettifiers are already applied above, so we can skip it now
	    const lines = typeof customPrettifiers[keyName] === 'function'
	      ? keyValue
	      : stringifySafe(keyValue, null, 2);

	    if (lines === undefined) return

	    result += prettifyError({ keyName, lines, eol, ident });
	  });

	  return result
	}
	return prettifyObject_1;
}

var prettifyErrorLog_1;
var hasRequiredPrettifyErrorLog;

function requirePrettifyErrorLog () {
	if (hasRequiredPrettifyErrorLog) return prettifyErrorLog_1;
	hasRequiredPrettifyErrorLog = 1;

	prettifyErrorLog_1 = prettifyErrorLog;

	const {
	  LOGGER_KEYS
	} = requireConstants();

	const isObject = requireIsObject();
	const joinLinesWithIndentation = requireJoinLinesWithIndentation();
	const prettifyObject = requirePrettifyObject();

	/**
	 * @typedef {object} PrettifyErrorLogParams
	 * @property {object} log The error log to prettify.
	 * @property {PrettyContext} context The context object built from parsing
	 * the options.
	 */

	/**
	 * Given a log object that has a `type: 'Error'` key, prettify the object and
	 * return the result. In other
	 *
	 * @param {PrettifyErrorLogParams} input
	 *
	 * @returns {string} A string that represents the prettified error log.
	 */
	function prettifyErrorLog ({ log, context }) {
	  const {
	    EOL: eol,
	    IDENT: ident,
	    errorProps: errorProperties,
	    messageKey
	  } = context;
	  const stack = log.stack;
	  const joinedLines = joinLinesWithIndentation({ input: stack, ident, eol });
	  let result = `${ident}${joinedLines}${eol}`;

	  if (errorProperties.length > 0) {
	    const excludeProperties = LOGGER_KEYS.concat(messageKey, 'type', 'stack');
	    let propertiesToPrint;
	    if (errorProperties[0] === '*') {
	      // Print all sibling properties except for the standard exclusions.
	      propertiesToPrint = Object.keys(log).filter(k => excludeProperties.includes(k) === false);
	    } else {
	      // Print only specified properties unless the property is a standard exclusion.
	      propertiesToPrint = errorProperties.filter(k => excludeProperties.includes(k) === false);
	    }

	    for (let i = 0; i < propertiesToPrint.length; i += 1) {
	      const key = propertiesToPrint[i];
	      if (key in log === false) continue
	      if (isObject(log[key])) {
	        // The nested object may have "logger" type keys but since they are not
	        // at the root level of the object being processed, we want to print them.
	        // Thus, we invoke with `excludeLoggerKeys: false`.
	        const prettifiedObject = prettifyObject({
	          log: log[key],
	          excludeLoggerKeys: false,
	          context: {
	            ...context,
	            IDENT: ident + ident
	          }
	        });
	        result = `${result}${ident}${key}: {${eol}${prettifiedObject}${ident}}${eol}`;
	        continue
	      }
	      result = `${result}${ident}${key}: ${log[key]}${eol}`;
	    }
	  }

	  return result
	}
	return prettifyErrorLog_1;
}

var prettifyLevel_1;
var hasRequiredPrettifyLevel;

function requirePrettifyLevel () {
	if (hasRequiredPrettifyLevel) return prettifyLevel_1;
	hasRequiredPrettifyLevel = 1;

	prettifyLevel_1 = prettifyLevel;

	const getPropertyValue = requireGetPropertyValue();

	/**
	 * @typedef {object} PrettifyLevelParams
	 * @property {object} log The log object.
	 * @property {PrettyContext} context The context object built from parsing
	 * the options.
	 */

	/**
	 * Checks if the passed in log has a `level` value and returns a prettified
	 * string for that level if so.
	 *
	 * @param {PrettifyLevelParams} input
	 *
	 * @returns {undefined|string} If `log` does not have a `level` property then
	 * `undefined` will be returned. Otherwise, a string from the specified
	 * `colorizer` is returned.
	 */
	function prettifyLevel ({ log, context }) {
	  const {
	    colorizer,
	    customLevels,
	    customLevelNames,
	    levelKey,
	    getLevelLabelData
	  } = context;
	  const prettifier = context.customPrettifiers?.level;
	  const output = getPropertyValue(log, levelKey);
	  if (output === undefined) return undefined
	  const labelColorized = colorizer(output, { customLevels, customLevelNames });
	  if (prettifier) {
	    const [label] = getLevelLabelData(output);
	    return prettifier(output, levelKey, log, { label, labelColorized, colors: colorizer.colors })
	  }
	  return labelColorized
	}
	return prettifyLevel_1;
}

var prettifyMessage_1;
var hasRequiredPrettifyMessage;

function requirePrettifyMessage () {
	if (hasRequiredPrettifyMessage) return prettifyMessage_1;
	hasRequiredPrettifyMessage = 1;

	prettifyMessage_1 = prettifyMessage;

	const {
	  LEVELS
	} = requireConstants();

	const getPropertyValue = requireGetPropertyValue();
	const interpretConditionals = requireInterpretConditionals();

	/**
	 * @typedef {object} PrettifyMessageParams
	 * @property {object} log The log object with the message to colorize.
	 * @property {PrettyContext} context The context object built from parsing
	 * the options.
	 */

	/**
	 * Prettifies a message string if the given `log` has a message property.
	 *
	 * @param {PrettifyMessageParams} input
	 *
	 * @returns {undefined|string} If the message key is not found, or the message
	 * key is not a string, then `undefined` will be returned. Otherwise, a string
	 * that is the prettified message.
	 */
	function prettifyMessage ({ log, context }) {
	  const {
	    colorizer,
	    customLevels,
	    levelKey,
	    levelLabel,
	    messageFormat,
	    messageKey,
	    useOnlyCustomProps
	  } = context;
	  if (messageFormat && typeof messageFormat === 'string') {
	    const parsedMessageFormat = interpretConditionals(messageFormat, log);

	    const message = String(parsedMessageFormat).replace(
	      /{([^{}]+)}/g,
	      function (match, p1) {
	        // return log level as string instead of int
	        let level;
	        if (p1 === levelLabel && (level = getPropertyValue(log, levelKey)) !== undefined) {
	          const condition = useOnlyCustomProps ? customLevels === undefined : customLevels[level] === undefined;
	          return condition ? LEVELS[level] : customLevels[level]
	        }

	        // Parse nested key access, e.g. `{keyA.subKeyB}`.
	        return getPropertyValue(log, p1) || ''
	      });
	    return colorizer.message(message)
	  }
	  if (messageFormat && typeof messageFormat === 'function') {
	    const msg = messageFormat(log, messageKey, levelLabel, { colors: colorizer.colors });
	    return colorizer.message(msg)
	  }
	  if (messageKey in log === false) return undefined
	  if (typeof log[messageKey] !== 'string' && typeof log[messageKey] !== 'number' && typeof log[messageKey] !== 'boolean') return undefined
	  return colorizer.message(log[messageKey])
	}
	return prettifyMessage_1;
}

var prettifyMetadata_1;
var hasRequiredPrettifyMetadata;

function requirePrettifyMetadata () {
	if (hasRequiredPrettifyMetadata) return prettifyMetadata_1;
	hasRequiredPrettifyMetadata = 1;

	prettifyMetadata_1 = prettifyMetadata;

	/**
	 * @typedef {object} PrettifyMetadataParams
	 * @property {object} log The log that may or may not contain metadata to
	 * be prettified.
	 * @property {PrettyContext} context The context object built from parsing
	 * the options.
	 */

	/**
	 * Prettifies metadata that is usually present in a Pino log line. It looks for
	 * fields `name`, `pid`, `hostname`, and `caller` and returns a formatted string using
	 * the fields it finds.
	 *
	 * @param {PrettifyMetadataParams} input
	 *
	 * @returns {undefined|string} If no metadata is found then `undefined` is
	 * returned. Otherwise, a string of prettified metadata is returned.
	 */
	function prettifyMetadata ({ log, context }) {
	  const { customPrettifiers: prettifiers, colorizer } = context;
	  let line = '';

	  if (log.name || log.pid || log.hostname) {
	    line += '(';

	    if (log.name) {
	      line += prettifiers.name
	        ? prettifiers.name(log.name, 'name', log, { colors: colorizer.colors })
	        : log.name;
	    }

	    if (log.pid) {
	      const prettyPid = prettifiers.pid
	        ? prettifiers.pid(log.pid, 'pid', log, { colors: colorizer.colors })
	        : log.pid;
	      if (log.name && log.pid) {
	        line += '/' + prettyPid;
	      } else {
	        line += prettyPid;
	      }
	    }

	    if (log.hostname) {
	      // If `pid` and `name` were in the ignore keys list then we don't need
	      // the leading space.
	      const prettyHostname = prettifiers.hostname
	        ? prettifiers.hostname(log.hostname, 'hostname', log, { colors: colorizer.colors })
	        : log.hostname;

	      line += `${line === '(' ? 'on' : ' on'} ${prettyHostname}`;
	    }

	    line += ')';
	  }

	  if (log.caller) {
	    const prettyCaller = prettifiers.caller
	      ? prettifiers.caller(log.caller, 'caller', log, { colors: colorizer.colors })
	      : log.caller;

	    line += `${line === '' ? '' : ' '}<${prettyCaller}>`;
	  }

	  if (line === '') {
	    return undefined
	  } else {
	    return line
	  }
	}
	return prettifyMetadata_1;
}

var prettifyTime_1;
var hasRequiredPrettifyTime;

function requirePrettifyTime () {
	if (hasRequiredPrettifyTime) return prettifyTime_1;
	hasRequiredPrettifyTime = 1;

	prettifyTime_1 = prettifyTime;

	const formatTime = requireFormatTime();

	/**
	 * @typedef {object} PrettifyTimeParams
	 * @property {object} log The log object with the timestamp to be prettified.
	 * @property {PrettyContext} context The context object built from parsing
	 * the options.
	 */

	/**
	 * Prettifies a timestamp if the given `log` has either `time`, `timestamp` or custom specified timestamp
	 * property.
	 *
	 * @param {PrettifyTimeParams} input
	 *
	 * @returns {undefined|string} If a timestamp property cannot be found then
	 * `undefined` is returned. Otherwise, the prettified time is returned as a
	 * string.
	 */
	function prettifyTime ({ log, context }) {
	  const {
	    timestampKey,
	    translateTime: translateFormat
	  } = context;
	  const prettifier = context.customPrettifiers?.time;
	  let time = null;

	  if (timestampKey in log) {
	    time = log[timestampKey];
	  } else if ('timestamp' in log) {
	    time = log.timestamp;
	  }

	  if (time === null) return undefined
	  const output = translateFormat ? formatTime(time, translateFormat) : time;

	  return prettifier ? prettifier(output) : `[${output}]`
	}
	return prettifyTime_1;
}

var utils;
var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;

	utils = {
	  buildSafeSonicBoom: requireBuildSafeSonicBoom(),
	  createDate: requireCreateDate(),
	  deleteLogProperty: requireDeleteLogProperty(),
	  filterLog: requireFilterLog(),
	  formatTime: requireFormatTime(),
	  getPropertyValue: requireGetPropertyValue(),
	  handleCustomLevelsNamesOpts: requireHandleCustomLevelsNamesOpts(),
	  handleCustomLevelsOpts: requireHandleCustomLevelsOpts(),
	  interpretConditionals: requireInterpretConditionals(),
	  isObject: requireIsObject(),
	  isValidDate: requireIsValidDate(),
	  joinLinesWithIndentation: requireJoinLinesWithIndentation(),
	  noop: requireNoop(),
	  parseFactoryOptions: requireParseFactoryOptions(),
	  prettifyErrorLog: requirePrettifyErrorLog(),
	  prettifyError: requirePrettifyError(),
	  prettifyLevel: requirePrettifyLevel(),
	  prettifyMessage: requirePrettifyMessage(),
	  prettifyMetadata: requirePrettifyMetadata(),
	  prettifyObject: requirePrettifyObject(),
	  prettifyTime: requirePrettifyTime(),
	  splitPropertyKey: requireSplitPropertyKey(),
	  getLevelLabelData: requireGetLevelLabelData()
	};

	// The remainder of this file consists of jsdoc blocks that are difficult to
	// determine a more appropriate "home" for. As an example, the blocks associated
	// with custom prettifiers could live in either the `prettify-level`,
	// `prettify-metadata`, or `prettify-time` files since they are the primary
	// files where such code is used. But we want a central place to define common
	// doc blocks, so we are picking this file as the answer.

	/**
	 * A hash of log property names mapped to prettifier functions. When the
	 * incoming log data is being processed for prettification, any key on the log
	 * that matches a key in a custom prettifiers hash will be prettified using
	 * that matching custom prettifier. The value passed to the custom prettifier
	 * will the value associated with the corresponding log key.
	 *
	 * The hash may contain any arbitrary keys for arbitrary log properties, but it
	 * may also contain a set of predefined key names that map to well-known log
	 * properties. These keys are:
	 *
	 * + `time` (for the timestamp field)
	 * + `level` (for the level label field; value may be a level number instead
	 * of a level label)
	 * + `hostname`
	 * + `pid`
	 * + `name`
	 * + `caller`
	 *
	 * @typedef {Object.<string, CustomPrettifierFunc>} CustomPrettifiers
	 */

	/**
	 * A synchronous function to be used for prettifying a log property. It must
	 * return a string.
	 *
	 * @typedef {function} CustomPrettifierFunc
	 * @param {any} value The value to be prettified for the key associated with
	 * the prettifier.
	 * @returns {string}
	 */

	/**
	 * A tokenized string that indicates how the prettified log line should be
	 * formatted. Tokens are either log properties enclosed in curly braces, e.g.
	 * `{levelLabel}`, `{pid}`, or `{req.url}`, or conditional directives in curly
	 * braces. The only conditional directives supported are `if` and `end`, e.g.
	 * `{if pid}{pid}{end}`; every `if` must have a matching `end`. Nested
	 * conditions are not supported.
	 *
	 * @typedef {string} MessageFormatString
	 *
	 * @example
	 * `{levelLabel} - {if pid}{pid} - {end}url:{req.url}`
	 */

	/**
	 * @typedef {object} PrettifyMessageExtras
	 * @property {object} colors Available color functions based on `useColor` (or `colorize`) context
	 * the options.
	 */

	/**
	 * A function that accepts a log object, name of the message key, and name of
	 * the level label key and returns a formatted log line.
	 *
	 * Note: this function must be synchronous.
	 *
	 * @typedef {function} MessageFormatFunction
	 * @param {object} log The log object to be processed.
	 * @param {string} messageKey The name of the key in the `log` object that
	 * contains the log message.
	 * @param {string} levelLabel The name of the key in the `log` object that
	 * contains the log level name.
	 * @param {PrettifyMessageExtras} extras Additional data available for message context
	 * @returns {string}
	 *
	 * @example
	 * function (log, messageKey, levelLabel) {
	 *   return `${log[levelLabel]} - ${log[messageKey]}`
	 * }
	 */
	return utils;
}

var secureJsonParse = {exports: {}};

var hasRequiredSecureJsonParse;

function requireSecureJsonParse () {
	if (hasRequiredSecureJsonParse) return secureJsonParse.exports;
	hasRequiredSecureJsonParse = 1;

	const hasBuffer = typeof Buffer !== 'undefined';
	const suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
	const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;

	function _parse (text, reviver, options) {
	  // Normalize arguments
	  if (options == null) {
	    if (reviver !== null && typeof reviver === 'object') {
	      options = reviver;
	      reviver = undefined;
	    }
	  }

	  if (hasBuffer && Buffer.isBuffer(text)) {
	    text = text.toString();
	  }

	  // BOM checker
	  if (text && text.charCodeAt(0) === 0xFEFF) {
	    text = text.slice(1);
	  }

	  // Parse normally, allowing exceptions
	  const obj = JSON.parse(text, reviver);

	  // Ignore null and non-objects
	  if (obj === null || typeof obj !== 'object') {
	    return obj
	  }

	  const protoAction = (options && options.protoAction) || 'error';
	  const constructorAction = (options && options.constructorAction) || 'error';

	  // options: 'error' (default) / 'remove' / 'ignore'
	  if (protoAction === 'ignore' && constructorAction === 'ignore') {
	    return obj
	  }

	  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {
	    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
	      return obj
	    }
	  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {
	    if (suspectProtoRx.test(text) === false) {
	      return obj
	    }
	  } else {
	    if (suspectConstructorRx.test(text) === false) {
	      return obj
	    }
	  }

	  // Scan result for proto keys
	  return filter(obj, { protoAction, constructorAction, safe: options && options.safe })
	}

	function filter (obj, { protoAction = 'error', constructorAction = 'error', safe } = {}) {
	  let next = [obj];

	  while (next.length) {
	    const nodes = next;
	    next = [];

	    for (const node of nodes) {
	      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly
	        if (safe === true) {
	          return null
	        } else if (protoAction === 'error') {
	          throw new SyntaxError('Object contains forbidden prototype property')
	        }

	        delete node.__proto__; // eslint-disable-line no-proto
	      }

	      if (constructorAction !== 'ignore' &&
	          Object.prototype.hasOwnProperty.call(node, 'constructor') &&
	          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) { // Avoid calling node.hasOwnProperty directly
	        if (safe === true) {
	          return null
	        } else if (constructorAction === 'error') {
	          throw new SyntaxError('Object contains forbidden prototype property')
	        }

	        delete node.constructor;
	      }

	      for (const key in node) {
	        const value = node[key];
	        if (value && typeof value === 'object') {
	          next.push(value);
	        }
	      }
	    }
	  }
	  return obj
	}

	function parse (text, reviver, options) {
	  const stackTraceLimit = Error.stackTraceLimit;
	  Error.stackTraceLimit = 0;
	  try {
	    return _parse(text, reviver, options)
	  } finally {
	    Error.stackTraceLimit = stackTraceLimit;
	  }
	}

	function safeParse (text, reviver) {
	  const stackTraceLimit = Error.stackTraceLimit;
	  Error.stackTraceLimit = 0;
	  try {
	    return _parse(text, reviver, { safe: true })
	  } catch (_e) {
	    return null
	  } finally {
	    Error.stackTraceLimit = stackTraceLimit;
	  }
	}

	secureJsonParse.exports = parse;
	secureJsonParse.exports.default = parse;
	secureJsonParse.exports.parse = parse;
	secureJsonParse.exports.safeParse = safeParse;
	secureJsonParse.exports.scan = filter;
	return secureJsonParse.exports;
}

var pretty_1;
var hasRequiredPretty;

function requirePretty () {
	if (hasRequiredPretty) return pretty_1;
	hasRequiredPretty = 1;

	pretty_1 = pretty;

	const sjs = requireSecureJsonParse();

	const isObject = requireIsObject();
	const prettifyErrorLog = requirePrettifyErrorLog();
	const prettifyLevel = requirePrettifyLevel();
	const prettifyMessage = requirePrettifyMessage();
	const prettifyMetadata = requirePrettifyMetadata();
	const prettifyObject = requirePrettifyObject();
	const prettifyTime = requirePrettifyTime();
	const filterLog = requireFilterLog();

	const {
	  LEVELS,
	  LEVEL_KEY,
	  LEVEL_NAMES
	} = requireConstants();

	const jsonParser = input => {
	  try {
	    return { value: sjs.parse(input, { protoAction: 'remove' }) }
	  } catch (err) {
	    return { err }
	  }
	};

	/**
	 * Orchestrates processing the received log data according to the provided
	 * configuration and returns a prettified log string.
	 *
	 * @typedef {function} LogPrettifierFunc
	 * @param {string|object} inputData A log string or a log-like object.
	 * @returns {string} A string that represents the prettified log data.
	 */
	function pretty (inputData) {
	  let log;
	  if (!isObject(inputData)) {
	    const parsed = jsonParser(inputData);
	    if (parsed.err || !isObject(parsed.value)) {
	      // pass through
	      return inputData + this.EOL
	    }
	    log = parsed.value;
	  } else {
	    log = inputData;
	  }

	  if (this.minimumLevel) {
	    // We need to figure out if the custom levels has the desired minimum
	    // level & use that one if found. If not, determine if the level exists
	    // in the standard levels. In both cases, make sure we have the level
	    // number instead of the level name.
	    let condition;
	    if (this.useOnlyCustomProps) {
	      condition = this.customLevels;
	    } else {
	      condition = this.customLevelNames[this.minimumLevel] !== undefined;
	    }
	    let minimum;
	    if (condition) {
	      minimum = this.customLevelNames[this.minimumLevel];
	    } else {
	      minimum = LEVEL_NAMES[this.minimumLevel];
	    }
	    if (!minimum) {
	      minimum = typeof this.minimumLevel === 'string'
	        ? LEVEL_NAMES[this.minimumLevel]
	        : LEVEL_NAMES[LEVELS[this.minimumLevel].toLowerCase()];
	    }

	    const level = log[this.levelKey === undefined ? LEVEL_KEY : this.levelKey];
	    if (level < minimum) return
	  }

	  const prettifiedMessage = prettifyMessage({ log, context: this.context });

	  if (this.ignoreKeys || this.includeKeys) {
	    log = filterLog({ log, context: this.context });
	  }

	  const prettifiedLevel = prettifyLevel({
	    log,
	    context: {
	      ...this.context,
	      // This is odd. The colorizer ends up relying on the value of
	      // `customProperties` instead of the original `customLevels` and
	      // `customLevelNames`.
	      ...this.context.customProperties
	    }
	  });
	  const prettifiedMetadata = prettifyMetadata({ log, context: this.context });
	  const prettifiedTime = prettifyTime({ log, context: this.context });

	  let line = '';
	  if (this.levelFirst && prettifiedLevel) {
	    line = `${prettifiedLevel}`;
	  }

	  if (prettifiedTime && line === '') {
	    line = `${prettifiedTime}`;
	  } else if (prettifiedTime) {
	    line = `${line} ${prettifiedTime}`;
	  }

	  if (!this.levelFirst && prettifiedLevel) {
	    if (line.length > 0) {
	      line = `${line} ${prettifiedLevel}`;
	    } else {
	      line = prettifiedLevel;
	    }
	  }

	  if (prettifiedMetadata) {
	    if (line.length > 0) {
	      line = `${line} ${prettifiedMetadata}:`;
	    } else {
	      line = prettifiedMetadata;
	    }
	  }

	  if (line.endsWith(':') === false && line !== '') {
	    line += ':';
	  }

	  if (prettifiedMessage !== undefined) {
	    if (line.length > 0) {
	      line = `${line} ${prettifiedMessage}`;
	    } else {
	      line = prettifiedMessage;
	    }
	  }

	  if (line.length > 0 && !this.singleLine) {
	    line += this.EOL;
	  }

	  // pino@7+ does not log this anymore
	  if (log.type === 'Error' && typeof log.stack === 'string') {
	    const prettifiedErrorLog = prettifyErrorLog({ log, context: this.context });
	    if (this.singleLine) line += this.EOL;
	    line += prettifiedErrorLog;
	  } else if (this.hideObject === false) {
	    const skipKeys = [
	      this.messageKey,
	      this.levelKey,
	      this.timestampKey
	    ]
	      .map((key) => key.replaceAll(/\\/g, ''))
	      .filter(key => {
	        return typeof log[key] === 'string' ||
	          typeof log[key] === 'number' ||
	          typeof log[key] === 'boolean'
	      });
	    const prettifiedObject = prettifyObject({
	      log,
	      skipKeys,
	      context: this.context
	    });

	    // In single line mode, include a space only if prettified version isn't empty
	    if (this.singleLine && !/^\s$/.test(prettifiedObject)) {
	      line += ' ';
	    }
	    line += prettifiedObject;
	  }

	  return line
	}
	return pretty_1;
}

var hasRequiredPinoPretty;

function requirePinoPretty () {
	if (hasRequiredPinoPretty) return pinoPretty.exports;
	hasRequiredPinoPretty = 1;

	const { isColorSupported } = requireColorette();
	const pump = requirePump();
	const { Transform } = requireStreamBrowserify();
	const abstractTransport = requirePinoAbstractTransport();
	const colors = requireColors();
	const {
	  ERROR_LIKE_KEYS,
	  LEVEL_KEY,
	  LEVEL_LABEL,
	  MESSAGE_KEY,
	  TIMESTAMP_KEY
	} = requireConstants();
	const {
	  buildSafeSonicBoom,
	  parseFactoryOptions
	} = requireUtils();
	const pretty = requirePretty();

	/**
	 * @typedef {object} PinoPrettyOptions
	 * @property {boolean} [colorize] Indicates if colors should be used when
	 * prettifying. The default will be determined by the terminal capabilities at
	 * run time.
	 * @property {boolean} [colorizeObjects=true] Apply coloring to rendered objects
	 * when coloring is enabled.
	 * @property {boolean} [crlf=false] End lines with `\r\n` instead of `\n`.
	 * @property {string|null} [customColors=null] A comma separated list of colors
	 * to use for specific level labels, e.g. `err:red,info:blue`.
	 * @property {string|null} [customLevels=null] A comma separated list of user
	 * defined level names and numbers, e.g. `err:99,info:1`.
	 * @property {CustomPrettifiers} [customPrettifiers={}] A set of prettifier
	 * functions to apply to keys defined in this object.
	 * @property {K_ERROR_LIKE_KEYS} [errorLikeObjectKeys] A list of string property
	 * names to consider as error objects.
	 * @property {string} [errorProps=''] A comma separated list of properties on
	 * error objects to include in the output.
	 * @property {boolean} [hideObject=false] When `true`, data objects will be
	 * omitted from the output (except for error objects).
	 * @property {string} [ignore='hostname'] A comma separated list of log keys
	 * to omit when outputting the prettified log information.
	 * @property {undefined|string} [include=undefined] A comma separated list of
	 * log keys to include in the prettified log information. Only the keys in this
	 * list will be included in the output.
	 * @property {boolean} [levelFirst=false] When true, the log level will be the
	 * first field in the prettified output.
	 * @property {string} [levelKey='level'] The key name in the log data that
	 * contains the level value for the log.
	 * @property {string} [levelLabel='levelLabel'] Token name to use in
	 * `messageFormat` to represent the name of the logged level.
	 * @property {null|MessageFormatString|MessageFormatFunction} [messageFormat=null]
	 * When a string, defines how the prettified line should be formatted according
	 * to defined tokens. When a function, a synchronous function that returns a
	 * formatted string.
	 * @property {string} [messageKey='msg'] Defines the key in incoming logs that
	 * contains the message of the log, if present.
	 * @property {undefined|string|number} [minimumLevel=undefined] The minimum
	 * level for logs that should be processed. Any logs below this level will
	 * be omitted.
	 * @property {object} [outputStream=process.stdout] The stream to write
	 * prettified log lines to.
	 * @property {boolean} [singleLine=false] When `true` any objects, except error
	 * objects, in the log data will be printed as a single line instead as multiple
	 * lines.
	 * @property {string} [timestampKey='time'] Defines the key in incoming logs
	 * that contains the timestamp of the log, if present.
	 * @property {boolean|string} [translateTime=true] When true, will translate a
	 * JavaScript date integer into a human-readable string. If set to a string,
	 * it must be a format string.
	 * @property {boolean} [useOnlyCustomProps=true] When true, only custom levels
	 * and colors will be used if they have been provided.
	 */

	/**
	 * The default options that will be used when prettifying log lines.
	 *
	 * @type {PinoPrettyOptions}
	 */
	const defaultOptions = {
	  colorize: isColorSupported,
	  colorizeObjects: true,
	  crlf: false,
	  customColors: null,
	  customLevels: null,
	  customPrettifiers: {},
	  errorLikeObjectKeys: ERROR_LIKE_KEYS,
	  errorProps: '',
	  hideObject: false,
	  ignore: 'hostname',
	  include: undefined,
	  levelFirst: false,
	  levelKey: LEVEL_KEY,
	  levelLabel: LEVEL_LABEL,
	  messageFormat: null,
	  messageKey: MESSAGE_KEY,
	  minimumLevel: undefined,
	  outputStream: process$1.stdout,
	  singleLine: false,
	  timestampKey: TIMESTAMP_KEY,
	  translateTime: true,
	  useOnlyCustomProps: true
	};

	/**
	 * Processes the supplied options and returns a function that accepts log data
	 * and produces a prettified log string.
	 *
	 * @param {PinoPrettyOptions} options Configuration for the prettifier.
	 * @returns {LogPrettifierFunc}
	 */
	function prettyFactory (options) {
	  const context = parseFactoryOptions(Object.assign({}, defaultOptions, options));
	  return pretty.bind({ ...context, context })
	}

	/**
	 * @typedef {PinoPrettyOptions} BuildStreamOpts
	 * @property {object|number|string} [destination] A destination stream, file
	 * descriptor, or target path to a file.
	 * @property {boolean} [append]
	 * @property {boolean} [mkdir]
	 * @property {boolean} [sync=false]
	 */

	/**
	 * Constructs a {@link LogPrettifierFunc} and a stream to which the produced
	 * prettified log data will be written.
	 *
	 * @param {BuildStreamOpts} opts
	 * @returns {Transform | (Transform & OnUnknown)}
	 */
	function build (opts = {}) {
	  let pretty = prettyFactory(opts);
	  let destination;
	  return abstractTransport(function (source) {
	    source.on('message', function pinoConfigListener (message) {
	      if (!message || message.code !== 'PINO_CONFIG') return
	      Object.assign(opts, {
	        messageKey: message.config.messageKey,
	        errorLikeObjectKeys: Array.from(new Set([...(opts.errorLikeObjectKeys || ERROR_LIKE_KEYS), message.config.errorKey])),
	        customLevels: message.config.levels.values
	      });
	      pretty = prettyFactory(opts);
	      source.off('message', pinoConfigListener);
	    });
	    const stream = new Transform({
	      objectMode: true,
	      autoDestroy: true,
	      transform (chunk, enc, cb) {
	        const line = pretty(chunk);
	        cb(null, line);
	      }
	    });

	    if (typeof opts.destination === 'object' && typeof opts.destination.write === 'function') {
	      destination = opts.destination;
	    } else {
	      destination = buildSafeSonicBoom({
	        dest: opts.destination || 1,
	        append: opts.append,
	        mkdir: opts.mkdir,
	        sync: opts.sync // by default sonic will be async
	      });
	    }

	    source.on('unknown', function (line) {
	      destination.write(line + '\n');
	    });

	    pump(source, stream, destination);
	    return stream
	  }, {
	    parse: 'lines',
	    close (err, cb) {
	      destination.on('close', () => {
	        cb(err);
	      });
	    }
	  })
	}

	pinoPretty.exports = build;
	pinoPretty.exports.build = build;
	pinoPretty.exports.PinoPretty = build;
	pinoPretty.exports.prettyFactory = prettyFactory;
	pinoPretty.exports.colorizerFactory = colors;
	pinoPretty.exports.isColorSupported = isColorSupported;
	pinoPretty.exports.default = build;
	return pinoPretty.exports;
}

var pinoPrettyExports = requirePinoPretty();
const index = /*@__PURE__*/getDefaultExportFromCjs(pinoPrettyExports);

const index$1 = /*#__PURE__*/_mergeNamespaces({
  __proto__: null,
  default: index
}, [pinoPrettyExports]);

export { index$1 as i };
//# sourceMappingURL=index-WVhZEObe.js.map
