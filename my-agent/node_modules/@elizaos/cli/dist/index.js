#!/usr/bin/env node

import { createRequire } from 'module';
const require = createRequire(import.meta.url);

import {
  create
} from "./chunk-23FI2G4U.js";
import {
  getElizaCharacter
} from "./chunk-E2PKE6N5.js";
import {
  TestRunner,
  UserEnvironment,
  agent,
  buildProject,
  checkAndShowUpdateNotification,
  configureDatabaseSettings,
  detectDirectoryType,
  detectPluginContext,
  displayBanner,
  executeInstallation,
  fetchPluginRegistry,
  findNextAvailablePort,
  getCliInstallTag,
  getGitHubCredentials,
  getPackageManager,
  getRegistrySettings,
  getVersion,
  handleError,
  initializeDataDir,
  installPlugin,
  isCliInstalledViaNpm,
  isRunningViaBunx,
  isRunningViaNpx,
  isValidForUpdates,
  loadPluginModule,
  logHeader,
  migrateCliToBun,
  normalizePluginName,
  promptForEnvVars,
  provideLocalPluginGuidance,
  publishToGitHub,
  resolvePgliteDir,
  saveRegistrySettings,
  testPublishToGitHub,
  testPublishToNpm,
  validateDataDir
} from "./chunk-IYFVOAOM.js";
import {
  runBunCommand
} from "./chunk-RIAWNDYI.js";
import {
  configureEmojis,
  emoji
} from "./chunk-KB3JDWUI.js";
import "./chunk-F24MS2YR.js";
import "./chunk-AQ6OMR2A.js";

// src/utils/port-validation.ts
function validatePort(value) {
  const port = Number.parseInt(value, 10);
  if (Number.isNaN(port) || port <= 0 || port > 65535) {
    throw new Error("Port must be a number between 1 and 65535");
  }
  return port;
}

// src/commands/dev/index.ts
import { Command, Option } from "commander";

// src/commands/dev/utils/build-utils.ts
import { existsSync } from "fs";
import path from "path";
async function buildPackage(packagePath, isPlugin2) {
  const startTime = Date.now();
  try {
    await buildProject(packagePath, isPlugin2);
    const duration = Date.now() - startTime;
    return { success: true, duration };
  } catch (error) {
    const duration = Date.now() - startTime;
    return { success: false, duration, error };
  }
}
async function buildCorePackages(monorepoRoot) {
  const corePackages = [
    {
      name: "core",
      path: path.join(monorepoRoot, "packages", "core"),
      isPlugin: false
    },
    {
      name: "client",
      path: path.join(monorepoRoot, "packages", "client"),
      isPlugin: false
    },
    {
      name: "plugin-bootstrap",
      path: path.join(monorepoRoot, "packages", "plugin-bootstrap"),
      isPlugin: true
    }
  ];
  const results = [];
  for (const pkg of corePackages) {
    console.info(`Building ${pkg.name}...`);
    const result = await buildPackage(pkg.path, pkg.isPlugin);
    if (!result.success) {
      console.error(`Error building ${pkg.name}: ${result.error?.message}`);
    } else {
      console.info(`\u2713 Built ${pkg.name} (${result.duration}ms)`);
    }
    results.push(result);
  }
  return results;
}
async function performRebuild(context) {
  console.info("Rebuilding...");
  const { directory, directoryType } = context;
  const isPlugin2 = directoryType.type === "elizaos-plugin";
  const isMonorepo = directoryType.type === "elizaos-monorepo";
  if (isMonorepo || directoryType.monorepoRoot) {
    const { monorepoRoot } = await UserEnvironment.getInstance().getPathInfo();
    if (monorepoRoot) {
      await buildCorePackages(monorepoRoot);
    } else {
      console.warn("Monorepo context detected, but failed to find monorepo root.");
    }
  }
  const result = await buildPackage(directory, isPlugin2);
  if (result.success) {
    console.log(`\u2713 Rebuild successful (${result.duration}ms)`);
  } else {
    console.error(`Build failed: ${result.error?.message}`);
    throw result.error;
  }
}
async function performInitialBuild(context) {
  const { directoryType, directory } = context;
  const isPlugin2 = directoryType.type === "elizaos-plugin";
  const isMonorepo = directoryType.type === "elizaos-monorepo";
  if (process.env.ELIZA_TEST_MODE) {
    console.info("Skipping initial build in test mode");
    return;
  }
  if (!isMonorepo) {
    console.info("Building project...");
    try {
      await buildProject(directory, isPlugin2);
      console.info("\u2713 Initial build completed");
    } catch (error) {
      console.error(
        `Initial build failed: ${error instanceof Error ? error.message : String(error)}`
      );
      console.info("Continuing with dev mode anyway...");
    }
  } else {
    console.info(
      "Monorepo detected - skipping automatic build. Use specific package build commands as needed."
    );
  }
}
function createDevContext(cwd) {
  const directoryType = detectDirectoryType(cwd);
  if (!directoryType) {
    throw new Error(
      "Cannot start development mode in this directory. Directory is not accessible or does not exist."
    );
  }
  const srcDir = path.join(cwd, "src");
  return {
    directory: cwd,
    directoryType,
    watchDirectory: existsSync(srcDir) ? srcDir : cwd,
    buildRequired: directoryType.type !== "elizaos-monorepo"
  };
}

// src/commands/dev/utils/file-watcher.ts
import chokidar from "chokidar";
import { existsSync as existsSync2, readdirSync } from "fs";
import path2 from "path";
var DEFAULT_WATCHER_CONFIG = {
  ignored: ["**/node_modules/**", "**/dist/**", "**/.git/**"],
  ignoreInitial: true,
  persistent: true,
  followSymlinks: false,
  depth: 99,
  // Set high depth to ensure we catch all nested files
  usePolling: false,
  // Only use polling if necessary
  interval: 1e3
  // Poll every second
};
function findTsFiles(dir, watchDir) {
  let results = [];
  try {
    const entries = readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path2.join(dir, entry.name);
      if (entry.isDirectory() && !entry.name.startsWith(".") && entry.name !== "node_modules" && entry.name !== "dist") {
        results = results.concat(findTsFiles(fullPath, watchDir));
      } else if (entry.isFile() && (entry.name.endsWith(".ts") || entry.name.endsWith(".js") || entry.name.endsWith(".tsx") || entry.name.endsWith(".jsx"))) {
        results.push(path2.relative(watchDir, fullPath));
      }
    }
  } catch (error) {
  }
  return results;
}
async function watchDirectory(dir, onChange, config2 = {}) {
  try {
    const absoluteDir = path2.resolve(dir);
    const srcDir = path2.join(absoluteDir, "src");
    const dirToWatch = existsSync2(srcDir) ? srcDir : absoluteDir;
    const watchOptions = { ...DEFAULT_WATCHER_CONFIG, ...config2 };
    const watcher = chokidar.watch(dirToWatch, watchOptions);
    const tsFiles = findTsFiles(dirToWatch, dirToWatch);
    console.info(`Found ${tsFiles.length} TypeScript/JavaScript files in the watched directory`);
    if (tsFiles.length > 0) {
      console.info(
        `Sample files: ${tsFiles.slice(0, 3).join(", ")}${tsFiles.length > 3 ? "..." : ""}`
      );
    }
    let debounceTimer = null;
    watcher.on("ready", () => {
      const watchedPaths = watcher.getWatched();
      const pathsCount = Object.keys(watchedPaths).length;
      if (pathsCount === 0) {
        console.warn("No directories are being watched! File watching may not be working.");
        watcher.add(`${dirToWatch}/**/*.{ts,js,tsx,jsx}`);
      }
      console.log(`\u2713 Watching for file changes in ${path2.relative(process.cwd(), dirToWatch)}`);
    });
    watcher.on("all", (_event, filePath) => {
      if (!/\.(ts|js|tsx|jsx)$/.test(filePath)) {
        return;
      }
      console.info(`File changed: ${path2.relative(dirToWatch, filePath)}`);
      if (debounceTimer) {
        clearTimeout(debounceTimer);
      }
      debounceTimer = setTimeout(() => {
        onChange();
        debounceTimer = null;
      }, 300);
    });
    watcher.on("error", (error) => {
      console.error(`Chokidar watcher error: ${error}`);
    });
    process.on("SIGINT", () => {
      watcher.close().then(() => process.exit(0));
    });
  } catch (error) {
    console.error(`Error setting up file watcher: ${error.message}`);
  }
}

// src/commands/dev/utils/server-manager.ts
import { spawn } from "child_process";
var DevServerManager = class {
  process = null;
  /**
   * Stops the currently running server process
   */
  async stop() {
    if (this.process) {
      console.info("Stopping current server process...");
      const killed = this.process.kill("SIGTERM");
      if (!killed) {
        console.warn("Failed to kill server process, trying force kill...");
        this.process.kill("SIGKILL");
      }
      this.process = null;
      await new Promise((resolve2) => setTimeout(resolve2, 500));
    }
  }
  /**
   * Starts the server process with the given arguments
   */
  async start(args = []) {
    await this.stop();
    console.info("Starting server...");
    const nodeExecutable = process.execPath;
    const scriptPath = process.argv[1];
    this.process = spawn(nodeExecutable, [scriptPath, "start", ...args], {
      stdio: "inherit",
      detached: false,
      // We want to keep control of this process
      env: { ...process.env, FORCE_COLOR: "1" }
      // Ensure color output in CI
    });
    this.process.on("exit", (code, signal) => {
      if (code !== null) {
        if (code !== 0) {
          console.warn(`Server process exited with code ${code}`);
        } else {
          console.info("Server process exited normally");
        }
      } else if (signal) {
        console.info(`Server process was killed with signal ${signal}`);
      }
      this.process = null;
    });
    this.process.on("error", (err) => {
      console.error(`Server process error: ${err.message}`);
      this.process = null;
    });
  }
  /**
   * Restarts the server process
   */
  async restart(args = []) {
    console.info("Restarting server...");
    await this.start(args);
  }
};
var serverInstance = null;
function getServerManager() {
  if (!serverInstance) {
    serverInstance = new DevServerManager();
  }
  return serverInstance;
}

// src/commands/dev/actions/dev-server.ts
async function startDevMode(options) {
  const cwd = process.cwd();
  const context = createDevContext(cwd);
  const serverManager = getServerManager();
  const { directoryType } = context;
  const isProject = directoryType.type === "elizaos-project";
  const isPlugin2 = directoryType.type === "elizaos-plugin";
  const isMonorepo = directoryType.type === "elizaos-monorepo";
  if (isProject) {
    console.info("Identified as an ElizaOS project package");
  } else if (isPlugin2) {
    console.info("Identified as an ElizaOS plugin package");
  } else if (isMonorepo) {
    console.info("Identified as an ElizaOS monorepo");
  } else {
    console.warn(
      `Not in a recognized ElizaOS project, plugin, or monorepo directory. Current directory is: ${directoryType.type}. Running in standalone mode.`
    );
  }
  const cliArgs = [];
  if (options.port) {
    cliArgs.push("--port", options.port.toString());
  }
  if (options.configure) {
    cliArgs.push("--configure");
  }
  if (options.character) {
    if (Array.isArray(options.character)) {
      cliArgs.push("--character", ...options.character);
    } else {
      cliArgs.push("--character", options.character);
    }
  }
  const rebuildAndRestart = async () => {
    try {
      await serverManager.stop();
      await performRebuild(context);
      console.log("\u2713 Rebuild successful, restarting...");
      await serverManager.start(cliArgs);
    } catch (error) {
      console.error(
        `Error during rebuild and restart: ${error instanceof Error ? error.message : String(error)}`
      );
      if (!serverManager.process) {
        console.info("Attempting to restart server regardless of build failure...");
        await serverManager.start(cliArgs);
      }
    }
  };
  if (isProject || isPlugin2 || isMonorepo) {
    const modeDescription = isMonorepo ? "monorepo" : isProject ? "project" : "plugin";
    console.info(`Running in ${modeDescription} mode`);
    await performInitialBuild(context);
  }
  await serverManager.start(cliArgs);
  if (isProject || isPlugin2 || isMonorepo) {
    await watchDirectory(context.watchDirectory, rebuildAndRestart);
    console.log("Dev mode is active! The server will restart when files change.");
    console.log("Press Ctrl+C to exit");
  } else {
    console.log("Server is running in standalone dev mode.");
    console.log("Press Ctrl+C to exit");
  }
}

// src/commands/dev/index.ts
var dev = new Command().name("dev").description(
  "Start the project or plugin in development mode with auto-rebuild, detailed logging, and file change detection"
).option("-c, --configure", "Reconfigure services and AI models (skips using saved configuration)").option("--character [paths...]", "Character file(s) to use - accepts paths or URLs").option("-b, --build", "Build the project before starting").addOption(
  new Option("-p, --port <port>", "Port to listen on (default: 3000)").argParser(validatePort)
).action(async (options) => {
  try {
    await startDevMode(options);
  } catch (error) {
    handleError(error);
  }
});

// src/commands/env/index.ts
import { Command as Command2 } from "commander";
import colors3 from "yoctocolors";

// src/commands/env/actions/edit.ts
import * as clack from "@clack/prompts";
import { existsSync as existsSync4 } from "fs";
import path4 from "path";

// src/commands/env/utils/file-operations.ts
import dotenv from "dotenv";
import { existsSync as existsSync3 } from "fs";
import fs from "fs/promises";
import path3 from "path";
async function getLocalEnvPath() {
  const localEnvPath = path3.join(process.cwd(), ".env");
  return existsSync3(localEnvPath) ? localEnvPath : null;
}
async function parseEnvFile(filePath) {
  try {
    if (!existsSync3(filePath)) {
      return {};
    }
    const content = await fs.readFile(filePath, "utf-8");
    if (content.trim() === "") {
      return {};
    }
    return dotenv.parse(content);
  } catch (error) {
    console.error(
      `Error parsing .env file: ${error instanceof Error ? error.message : String(error)}`
    );
    return {};
  }
}
async function writeEnvFile(filePath, envVars) {
  try {
    const dir = path3.dirname(filePath);
    if (!existsSync3(dir)) {
      await fs.mkdir(dir, { recursive: true });
    }
    const content = Object.entries(envVars).map(([key, value]) => `${key}=${value}`).join("\n");
    await fs.writeFile(filePath, content);
  } catch (error) {
    console.error(
      `Error writing .env file: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
async function resetEnvFile(filePath) {
  try {
    if (!existsSync3(filePath)) {
      return false;
    }
    const envVars = await parseEnvFile(filePath);
    if (Object.keys(envVars).length === 0) {
      return false;
    }
    const resetVars = Object.keys(envVars).reduce((acc, key) => {
      acc[key] = "";
      return acc;
    }, {});
    await writeEnvFile(filePath, resetVars);
    return true;
  } catch (error) {
    console.error(
      `Error resetting environment file: ${error instanceof Error ? error.message : String(error)}`
    );
    return false;
  }
}

// src/commands/env/utils/validation.ts
function maskedValue(value) {
  if (!value) return "";
  if (value.length > 20 && !value.includes(" ")) {
    return `${value.substring(0, 4)}...${value.substring(value.length - 4)}`;
  }
  return value;
}

// src/commands/env/actions/edit.ts
async function editEnvVars(options, fromMainMenu = false) {
  const { yes } = options;
  const localEnvPath = await getLocalEnvPath();
  if (!localEnvPath || !existsSync4(localEnvPath)) {
    const exampleEnvPath = path4.join(process.cwd(), ".env.example");
    const hasExample = existsSync4(exampleEnvPath);
    if (hasExample) {
      console.log("No local .env file found. Create one with:");
      console.log("  cp .env.example .env");
    } else {
      console.log("No local .env file found in the current directory.");
      console.log("Create a .env file to set local environment variables.");
    }
    return fromMainMenu;
  }
  const envVars = await parseEnvFile(localEnvPath);
  if (Object.keys(envVars).length === 0) {
    console.log("Local .env file is empty.");
    const addNew = yes ? false : await clack.confirm({
      message: "Would you like to add a new environment variable?",
      initialValue: true
    });
    if (clack.isCancel(addNew)) {
      clack.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (addNew) {
      await addNewVariable(localEnvPath, envVars, yes);
    }
    return fromMainMenu;
  }
  let exit = false;
  let returnToMain = false;
  if (yes) {
    console.log("\u2705 Environment variables displayed. Use interactive mode without -y to edit.");
    return fromMainMenu;
  }
  while (!exit) {
    const entries = Object.entries(envVars);
    const choices = [
      ...entries.map(([key, value]) => ({
        title: `${key}: ${maskedValue(value)}`,
        value: key
      })),
      { title: "Add new variable", value: "add_new" },
      fromMainMenu ? { title: "Back to main menu", value: "back_to_main" } : { title: "Exit", value: "exit" }
    ];
    const selection = await clack.select({
      message: "Select a variable to edit or an action:",
      options: choices.map((choice) => ({
        value: choice.value,
        label: choice.title
      }))
    });
    if (clack.isCancel(selection)) {
      clack.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (!selection) {
      return fromMainMenu;
    }
    if (selection === "exit" || selection === "back_to_main") {
      exit = true;
      returnToMain = selection === "back_to_main";
      continue;
    }
    if (selection === "add_new") {
      await addNewVariable(localEnvPath, envVars, yes);
      continue;
    }
    const action = await clack.select({
      message: `What would you like to do with ${selection}?`,
      options: [
        { label: "Edit", value: "edit" },
        { label: "Delete", value: "delete" },
        { label: "Back", value: "back" }
      ]
    });
    if (clack.isCancel(action)) {
      clack.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (!action || action === "back") {
      continue;
    }
    if (action === "edit") {
      const value = await clack.text({
        message: `Enter the new value for ${selection}:`,
        defaultValue: envVars[selection]
      });
      if (clack.isCancel(value)) {
        clack.cancel("Operation cancelled.");
        process.exit(0);
      }
      if (value !== void 0) {
        envVars[selection] = value;
        await writeEnvFile(localEnvPath, envVars);
        console.log(`\u2713 Updated ${selection}`);
      }
    } else if (action === "delete") {
      let confirm8 = true;
      if (!yes) {
        const resp = await clack.confirm({
          message: `Are you sure you want to delete ${selection}?`,
          initialValue: false
        });
        if (clack.isCancel(resp)) {
          clack.cancel("Operation cancelled.");
          process.exit(0);
        }
        confirm8 = resp;
      }
      if (confirm8) {
        delete envVars[selection];
        await writeEnvFile(localEnvPath, envVars);
        console.log(`\u2713 Removed ${selection}`);
      }
    }
  }
  return returnToMain && fromMainMenu;
}
async function addNewVariable(envPath, envVars, yes = false) {
  if (yes) {
    console.log(
      "Auto-confirmation mode enabled - skipping variable addition in edit-local -y mode"
    );
    return;
  }
  const key = await clack.text({
    message: "Enter the variable name:",
    validate: (value2) => value2.trim() !== "" ? void 0 : "Variable name cannot be empty"
  });
  if (clack.isCancel(key)) {
    clack.cancel("Operation cancelled.");
    process.exit(0);
  }
  if (!key) return;
  const value = await clack.text({
    message: `Enter the value for ${key}:`,
    defaultValue: ""
  });
  if (clack.isCancel(value)) {
    clack.cancel("Operation cancelled.");
    process.exit(0);
  }
  if (value !== void 0) {
    envVars[key] = value;
    await writeEnvFile(envPath, envVars);
    console.log(`\u2713 Added ${key}`);
  }
}

// src/commands/env/actions/interactive.ts
import * as clack3 from "@clack/prompts";

// src/commands/env/actions/list.ts
import { existsSync as existsSync5 } from "fs";
import path5 from "path";
import colors from "yoctocolors";
async function listEnvVars() {
  const envInfo = await UserEnvironment.getInstanceInfo();
  console.info(colors.bold("\nSystem Information:"));
  console.info(`  Platform: ${colors.cyan(envInfo.os.platform)} (${envInfo.os.release})`);
  console.info(`  Architecture: ${colors.cyan(envInfo.os.arch)}`);
  console.info(`  CLI Version: ${colors.cyan(envInfo.cli.version)}`);
  console.info(
    `  Package Manager: ${colors.cyan(envInfo.packageManager.name)}${envInfo.packageManager.version ? ` v${envInfo.packageManager.version}` : ""}`
  );
  console.info(colors.bold("\nLocal Environment Variables:"));
  const localEnvFilePath = await getLocalEnvPath();
  console.info(`Path: ${localEnvFilePath ?? path5.join(process.cwd(), ".env")}`);
  if (!localEnvFilePath || !existsSync5(localEnvFilePath)) {
    console.info(colors.yellow("  No local .env file found"));
    const exampleEnvPath = path5.join(process.cwd(), ".env.example");
    if (existsSync5(exampleEnvPath)) {
      console.info(colors.red("  [X] Missing .env file. Create one with:"));
      console.info(`     ${colors.bold(colors.green("cp .env.example .env"))}`);
    } else {
      console.info(
        colors.red(
          "  [X] Missing .env file. Create one in your project directory to set local environment variables."
        )
      );
    }
  } else {
    const localEnvVars = await parseEnvFile(localEnvFilePath);
    if (Object.keys(localEnvVars).length === 0) {
      console.info("  No local environment variables set");
    } else {
      for (const [key, value] of Object.entries(localEnvVars)) {
        console.info(`  ${colors.green(key)}: ${maskedValue(value)}`);
      }
    }
  }
  console.info("\n");
  console.info(
    colors.cyan(
      "You can also edit environment variables in the web UI: http://localhost:3000/settings"
    )
  );
}
async function handleListCommand(options) {
  if (options.system) {
    const envInfo = await UserEnvironment.getInstanceInfo();
    console.info(colors.bold("\nSystem Information:"));
    console.info(`  Platform: ${colors.cyan(envInfo.os.platform)} (${envInfo.os.release})`);
    console.info(`  Architecture: ${colors.cyan(envInfo.os.arch)}`);
    console.info(`  CLI Version: ${colors.cyan(envInfo.cli.version)}`);
    console.info(
      `  Package Manager: ${colors.cyan(envInfo.packageManager.name)}${envInfo.packageManager.version ? ` v${envInfo.packageManager.version}` : ""}`
    );
  } else if (options.local) {
    console.info(colors.bold("\nLocal Environment Variables:"));
    const localEnvPath = await getLocalEnvPath();
    if (!localEnvPath || !existsSync5(localEnvPath)) {
      console.info("  No local .env file found in the current directory");
      return;
    }
    const localEnvVars = await parseEnvFile(localEnvPath);
    if (Object.keys(localEnvVars).length === 0) {
      console.info("  No local environment variables set");
    } else {
      for (const [key, value] of Object.entries(localEnvVars)) {
        console.info(`  ${colors.green(key)}: ${maskedValue(value)}`);
      }
    }
  } else {
    await listEnvVars();
  }
}

// src/commands/env/actions/reset.ts
import * as clack2 from "@clack/prompts";
import { existsSync as existsSync7 } from "fs";
import path6 from "path";
import colors2 from "yoctocolors";

// src/commands/env/utils/directory-operations.ts
import { existsSync as existsSync6 } from "fs";
import { rimraf } from "rimraf";
async function safeDeleteDirectory(dir, actions, label) {
  if (!existsSync6(dir)) {
    actions.skipped.push(`${label} (not found)`);
    return false;
  }
  try {
    await rimraf(dir);
    if (!existsSync6(dir)) {
      actions.deleted.push(label);
      return true;
    } else {
      actions.warning.push(`Failed to delete ${label.toLowerCase()}`);
      return false;
    }
  } catch (error) {
    actions.warning.push(`Failed to delete ${label.toLowerCase()}`);
    return false;
  }
}

// src/commands/env/actions/reset.ts
async function resolvePgliteDir2() {
  return path6.join(process.cwd(), ".eliza", "db");
}
async function resetEnv(options) {
  const { yes } = options;
  const elizaDir = path6.join(process.cwd(), ".eliza");
  const cacheDir = path6.join(elizaDir, "cache");
  const localEnvPath = await getLocalEnvPath() ?? path6.join(process.cwd(), ".env");
  const localDbDir = await resolvePgliteDir2();
  const resetItems = [
    {
      title: "Local environment variables",
      value: "localEnv",
      description: existsSync7(localEnvPath) ? "Reset values in local .env file" : "Local .env file not found, nothing to reset",
      selected: existsSync7(localEnvPath)
    },
    {
      title: "Cache folder",
      value: "cache",
      description: existsSync7(cacheDir) ? "Delete the cache folder" : "Cache folder not found, nothing to delete",
      selected: existsSync7(cacheDir)
    },
    {
      title: "Local database files",
      value: "localDb",
      description: existsSync7(localDbDir) ? "Delete local database files" : "Local database folder not found, nothing to delete",
      selected: existsSync7(localDbDir)
    }
  ];
  const validResetItems = resetItems.filter(
    (item) => item.value === "localEnv" && existsSync7(localEnvPath) || item.value === "cache" && existsSync7(cacheDir) || item.value === "localDb" && existsSync7(localDbDir)
  );
  let selectedValues = [];
  if (yes) {
    selectedValues = validResetItems.map((item) => item.value);
    if (selectedValues.length > 0) {
      console.info(colors2.bold("The following items will be reset:"));
      for (const value of selectedValues) {
        const item = resetItems.find((item2) => item2.value === value);
        console.info(`  \u2022 ${item?.title || value}`);
      }
    } else {
      console.info("No valid items found to reset.");
      return;
    }
  } else {
    const selections = await clack2.multiselect({
      message: colors2.cyan(colors2.bold("Select items to reset:")),
      options: resetItems.map((item) => ({ value: item.value, label: item.title })),
      required: true
    });
    if (clack2.isCancel(selections)) {
      clack2.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (!selections || selections.length === 0) {
      console.log("No items selected. Reset cancelled.");
      return;
    }
    selectedValues = selections;
    console.log("\nYou selected:");
    for (const value of selectedValues) {
      const item = resetItems.find((item2) => item2.value === value);
      console.log(`  \u2022 ${item?.title || value}`);
    }
    const confirm8 = await clack2.confirm({
      message: "Are you sure you want to reset the selected items?",
      initialValue: false
    });
    if (clack2.isCancel(confirm8)) {
      clack2.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (!confirm8) {
      console.log("Reset cancelled.");
      return;
    }
  }
  const actions = {
    reset: [],
    deleted: [],
    skipped: [],
    warning: []
  };
  for (const target of selectedValues) {
    switch (target) {
      case "localEnv":
        if (await resetEnvFile(localEnvPath)) {
          actions.reset.push("Local environment variables");
        } else {
          actions.skipped.push("Local environment variables (no file or empty)");
        }
        break;
      case "cache":
        await safeDeleteDirectory(cacheDir, actions, "Cache folder");
        break;
      case "localDb":
        await safeDeleteDirectory(localDbDir, actions, "Local database folder");
        break;
    }
  }
  console.log(colors2.bold("\nReset Summary:"));
  if (actions.reset.length > 0) {
    console.log(colors2.green("  Values Cleared:"));
    actions.reset.forEach((item) => console.log(`    \u2022 ${item}`));
  }
  if (actions.deleted.length > 0) {
    console.log(colors2.green("  Deleted:"));
    actions.deleted.forEach((item) => console.log(`    \u2022 ${item}`));
  }
  if (actions.skipped.length > 0) {
    console.log(colors2.yellow("  Skipped:"));
    actions.skipped.forEach((item) => console.log(`    \u2022 ${item}`));
  }
  if (actions.warning.length > 0) {
    console.log(colors2.red("  Warnings:"));
    actions.warning.forEach((item) => console.log(`    \u2022 ${item}`));
  }
  console.log(colors2.bold("\nEnvironment reset complete"));
}

// src/commands/env/actions/interactive.ts
async function showMainMenu(options) {
  const { yes } = options;
  let exit = false;
  while (!exit) {
    const action = await clack3.select({
      message: "Select an action:",
      options: [
        { label: "List environment variables", value: "list" },
        { label: "Edit local environment variables", value: "edit_local" },
        { label: "Reset environment variables", value: "reset" },
        { label: "Exit", value: "exit" }
      ]
    });
    if (clack3.isCancel(action)) {
      clack3.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (!action || action === "exit") {
      exit = true;
      continue;
    }
    switch (action) {
      case "list":
        await listEnvVars();
        break;
      case "edit_local": {
        const returnToMainFromLocal = await editEnvVars({ yes }, true);
        exit = !returnToMainFromLocal;
        break;
      }
      case "reset":
        await resetEnv({ yes });
        break;
    }
  }
}

// src/commands/env/index.ts
var env = new Command2().name("env").description("Manage environment variables and secrets");
env.command("list").description("List all environment variables").option("--system", "List only system information").option("--local", "List only local environment variables").action(async (options) => {
  try {
    await handleListCommand(options);
  } catch (error) {
    handleError(error);
  }
});
env.command("edit-local").description("Edit local environment variables").option("-y, --yes", "Automatically confirm prompts").action(async (options) => {
  try {
    await editEnvVars(options);
  } catch (error) {
    handleError(error);
  }
});
env.command("reset").description(
  "Reset environment variables and clean up database/cache files (interactive selection)"
).option("-y, --yes", "Automatically reset using default selections").action(async (options) => {
  try {
    await resetEnv(options);
  } catch (error) {
    handleError(error);
  }
});
env.command("interactive").description("Interactive environment variable management").option("-y, --yes", "Automatically confirm prompts").action(async (options) => {
  try {
    await showMainMenu(options);
  } catch (error) {
    handleError(error);
  }
});
env.action(() => {
  console.log(colors3.bold("\nEliza Environment Variable Manager"));
  console.log("\nAvailable commands:");
  console.log("  list                  List all environment variables");
  console.log("  edit-local            Edit local environment variables");
  console.log(
    "  reset                 Reset environment variables and clean up database/cache files (interactive selection)"
  );
  console.log("  interactive           Start interactive environment variable manager");
  console.log("\nYou can also edit environment variables in the web UI:");
  console.log("  http://localhost:3000/settings");
});

// src/commands/plugins/index.ts
import { Command as Command3 } from "commander";

// src/commands/plugins/actions/install.ts
import { logger as logger3 } from "@elizaos/core";

// src/commands/plugins/utils/naming.ts
var findPluginPackageName = (pluginInput, allDependencies) => {
  let normalizedBase = pluginInput.startsWith("@") ? pluginInput.split("/")[1] || pluginInput : pluginInput;
  normalizedBase = normalizedBase.replace(/^plugin-/, "");
  const possibleNames = [
    pluginInput,
    // Check the raw input first
    `@elizaos/plugin-${normalizedBase}`,
    // Prioritize @elizaos/ scope
    `@elizaos/${normalizedBase}`,
    // Might be needed if input was 'plugin-abc' -> base 'abc' -> check '@elizaos/abc'
    `@elizaos/plugin-${normalizedBase}`,
    // Check alternative scope
    `plugin-${normalizedBase}`,
    `@elizaos/${normalizedBase}`
  ];
  for (const name of possibleNames) {
    if (allDependencies[name]) {
      return name;
    }
  }
  return null;
};
var extractPackageName = (pluginInput) => {
  const githubUrlRegex = /^https?:\/\/github\.com\/([a-zA-Z0-9_-]+)\/([a-zA-Z0-9_.-]+?)(?:\.git)?(?:#([a-zA-Z0-9_.-]+))?$/;
  const githubShortRegex = /^(?:github:)?([a-zA-Z0-9_-]+)\/([a-zA-Z0-9_.-]+)(?:#([a-zA-Z0-9_.-]+))?$/;
  const githubUrlMatch = pluginInput.match(githubUrlRegex);
  if (githubUrlMatch) {
    const [, owner, repo] = githubUrlMatch;
    return `@${owner}/${repo}`;
  }
  const githubShortMatch = pluginInput.match(githubShortRegex);
  if (githubShortMatch) {
    const [, owner, repo] = githubShortMatch;
    return `@${owner}/${repo}`;
  }
  return pluginInput;
};

// src/commands/plugins/utils/env-vars.ts
import { logger } from "@elizaos/core";
import { existsSync as existsSync8, readFileSync, writeFileSync } from "fs";
import path7 from "path";
import * as clack4 from "@clack/prompts";
var extractPluginEnvRequirements = async (packageName, cwd) => {
  try {
    const nodeModulesPath = path7.join(cwd, "node_modules", packageName, "package.json");
    if (!existsSync8(nodeModulesPath)) {
      logger.debug(`Plugin package.json not found at: ${nodeModulesPath}`);
      return {};
    }
    const packageJsonContent = readFileSync(nodeModulesPath, "utf-8");
    const packageJson = JSON.parse(packageJsonContent);
    const agentConfig = packageJson.agentConfig;
    if (!agentConfig || !agentConfig.pluginParameters) {
      logger.debug(`No agentConfig.pluginParameters found in ${packageName}`);
      return {};
    }
    logger.debug(
      `Found environment variables for ${packageName}: ${Object.keys(agentConfig.pluginParameters).join(", ")}`
    );
    return agentConfig.pluginParameters;
  } catch (error) {
    logger.debug(
      `Error reading plugin package.json for ${packageName}: ${error instanceof Error ? error.message : String(error)}`
    );
    return {};
  }
};
var readEnvFile = (cwd) => {
  const envPath = path7.join(cwd, ".env");
  try {
    return readFileSync(envPath, "utf-8");
  } catch (error) {
    return "";
  }
};
var writeEnvFile2 = (cwd, content) => {
  const envPath = path7.join(cwd, ".env");
  writeFileSync(envPath, content, "utf-8");
};
var extractDefaultFromDescription = (description) => {
  const patterns = [
    /\(e\.g\.,\s*([^)]+)\)/i,
    // (e.g., value)
    /e\.g\.,?\s*([^.,\s]+)/i,
    // e.g., value or e.g. value
    /example:\s*([^.,\s]+)/i,
    // example: value
    /default:\s*([^.,\s]+)/i
    // default: value
  ];
  for (const pattern of patterns) {
    const match = description.match(pattern);
    if (match && match[1]) {
      return match[1].trim();
    }
  }
  return void 0;
};
var promptForEnvVar = async (varName, config2) => {
  const {
    description = "No description available",
    default: explicitDefault,
    sensitive = false
  } = config2;
  const defaultValue = explicitDefault || extractDefaultFromDescription(description);
  const isSecret = sensitive !== void 0 ? sensitive : varName.toLowerCase().includes("key") || varName.toLowerCase().includes("token") || varName.toLowerCase().includes("secret") || varName.toLowerCase().includes("password");
  const message = defaultValue ? `Enter ${varName} (default: ${defaultValue})` : `Enter ${varName}`;
  const placeholder = isSecret ? "Your secret key/token..." : defaultValue || "Enter value...";
  if (description && description !== "No description available") {
    clack4.note(`${description}`, `${varName} Info`);
  }
  const promptFn = isSecret ? clack4.password : clack4.text;
  const promptConfig = {
    message,
    placeholder,
    validate: (input) => {
      if ((!input || input.trim() === "") && !defaultValue) {
        return "This field cannot be empty. Press Ctrl+C to cancel.";
      }
      if (varName.includes("URL") || varName.includes("ENDPOINT")) {
        try {
          new URL(input.trim());
        } catch {
          return "Please enter a valid URL (e.g., https://api.example.com)";
        }
      }
      if (varName.includes("API_KEY") && input.trim().length < 5) {
        return "API key seems too short. Please verify you entered the complete key.";
      }
      return void 0;
    }
  };
  if (defaultValue && !isSecret) {
    promptConfig.initialValue = defaultValue;
  }
  const response = await promptFn(promptConfig);
  if (clack4.isCancel(response)) {
    clack4.cancel("Operation cancelled.");
    process.exit(0);
  }
  const finalValue = response && response.trim() || defaultValue || "";
  return finalValue.trim();
};
var updateEnvFile = (cwd, varName, value) => {
  const envContent = readEnvFile(cwd);
  const lines = envContent.split("\n");
  const existingLineIndex = lines.findIndex((line) => line.startsWith(`${varName}=`));
  if (existingLineIndex >= 0) {
    lines[existingLineIndex] = `${varName}=${value}`;
  } else {
    if (envContent && !envContent.endsWith("\n")) {
      lines.push("");
    }
    lines.push(`${varName}=${value}`);
  }
  writeEnvFile2(cwd, lines.join("\n"));
};
var promptForPluginEnvVars = async (packageName, cwd) => {
  const envRequirements = await extractPluginEnvRequirements(packageName, cwd);
  if (Object.keys(envRequirements).length === 0) {
    logger.debug(`No environment variables required for ${packageName}`);
    clack4.log.success(`No environment variables required for ${packageName}`);
    return;
  }
  await new Promise((resolve2) => setTimeout(resolve2, 100));
  clack4.intro(`Setting up ${packageName} Plugin`);
  const envContent = readEnvFile(cwd);
  const existingVars = {};
  envContent.split("\n").forEach((line) => {
    const match = line.match(/^([^=]+)=(.*)$/);
    if (match) {
      existingVars[match[1]] = match[2];
    }
  });
  const missingVars = [];
  const existingConfigured = [];
  Object.entries(envRequirements).forEach(([varName, config2]) => {
    if (existingVars[varName] && existingVars[varName] !== "") {
      existingConfigured.push(varName);
    } else {
      missingVars.push([varName, config2]);
    }
  });
  if (existingConfigured.length > 0) {
    clack4.note(existingConfigured.map((name) => `${name}`).join("\n"), "Already Configured");
  }
  if (missingVars.length === 0) {
    clack4.outro("All environment variables are already configured!");
    return;
  }
  const totalVars = Object.keys(envRequirements).length;
  const requiredVars = missingVars.filter(([, config2]) => config2.required !== false);
  const optionalVars = missingVars.filter(([, config2]) => config2.required === false);
  let configMessage = `We need to configure ${missingVars.length} of ${totalVars} environment variables.

`;
  if (requiredVars.length > 0) {
    configMessage += `Required (${requiredVars.length}):
${requiredVars.map(([name]) => `  - ${name}`).join("\n")}

`;
  }
  if (optionalVars.length > 0) {
    configMessage += `Optional (${optionalVars.length}):
${optionalVars.map(([name]) => `  - ${name}`).join("\n")}

`;
  }
  configMessage += `Tip: Press Ctrl+C at any time to cancel.`;
  clack4.note(configMessage, "Configuration Needed");
  const spinner2 = clack4.spinner();
  let configuredCount = existingConfigured.length;
  let newlyConfigured = 0;
  const sessionConfigured = /* @__PURE__ */ new Set();
  for (let i = 0; i < missingVars.length; i++) {
    const [varName, config2] = missingVars[i];
    if (i > 0) {
      console.log("");
    }
    const isRequired = config2.required !== false;
    const statusText = isRequired ? "Required" : "Optional";
    clack4.log.info(`[${i + 1}/${missingVars.length}] ${varName} (${statusText})`);
    try {
      const value = await promptForEnvVar(varName, config2);
      if (value) {
        spinner2.start(`Saving ${varName} to .env file...`);
        updateEnvFile(cwd, varName, value);
        spinner2.stop(`${varName} configured successfully`);
        newlyConfigured++;
        configuredCount++;
        sessionConfigured.add(varName);
      } else {
        const isRequired2 = config2.required !== false;
        if (isRequired2) {
          clack4.log.warn(`Skipped required variable ${varName} - plugin may not work correctly`);
        } else {
          clack4.log.info(`Skipped optional variable ${varName}`);
        }
      }
    } catch (error) {
      spinner2.stop();
      clack4.log.error(
        `Failed to configure ${varName}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  const requiredConfigured = Object.entries(envRequirements).filter(([, config2]) => config2.required !== false).filter(
    ([name]) => existingVars[name] && existingVars[name] !== "" || sessionConfigured.has(name)
  ).length;
  const totalRequired = Object.entries(envRequirements).filter(
    ([, config2]) => config2.required !== false
  ).length;
  if (configuredCount === totalVars) {
    clack4.outro(
      `Perfect! All ${totalVars} environment variables are configured.

Your ${packageName} plugin is ready to use!

Next steps:
- Restart your application to load the new environment variables
- Check your .env file if you need to modify any values later`
    );
  } else if (newlyConfigured > 0) {
    let message = `Successfully configured ${newlyConfigured} new environment variables!

`;
    message += `Status: ${configuredCount}/${totalVars} total variables configured
`;
    if (requiredConfigured === totalRequired) {
      message += `All required variables are set - your plugin should work!

`;
    } else {
      message += `${totalRequired - requiredConfigured} required variables still missing

`;
    }
    message += `Next steps:
`;
    message += `- Restart your application to load new environment variables
`;
    if (totalVars - configuredCount > 0) {
      message += `- Configure remaining ${totalVars - configuredCount} variables in your .env file if needed
`;
    }
    message += `- Check the plugin documentation for additional setup steps`;
    clack4.outro(message);
  } else {
    clack4.outro(
      `No new variables were configured.

To set up this plugin, add these variables to your .env file:

` + missingVars.map(([name, config2]) => {
        const required = config2.required !== false ? " (Required)" : " (Optional)";
        return `${name}=your_value_here${required}`;
      }).join("\n") + `

Restart your application after adding the variables.`
    );
  }
};

// src/commands/plugins/utils/directory.ts
import { logger as logger2 } from "@elizaos/core";
import { readFileSync as readFileSync2 } from "fs";
import path8 from "path";
var getDependenciesFromDirectory = (cwd) => {
  const directoryInfo = detectDirectoryType(cwd);
  if (!directoryInfo.hasPackageJson) {
    return null;
  }
  try {
    const packageJsonPath = path8.join(cwd, "package.json");
    const packageJsonContent = readFileSync2(packageJsonPath, "utf-8");
    const packageJson = JSON.parse(packageJsonContent);
    const dependencies = packageJson.dependencies || {};
    const devDependencies = packageJson.devDependencies || {};
    return { ...dependencies, ...devDependencies };
  } catch (error) {
    if (error instanceof SyntaxError) {
      logger2.warn(`Could not parse package.json: ${error.message}`);
    } else {
      logger2.warn(
        `Error reading package.json: ${error instanceof Error ? error.message : String(error)}`
      );
    }
    return null;
  }
};

// src/commands/plugins/actions/install.ts
async function installPluginFromGitHub(plugin, cwd, opts) {
  const githubRegex = /^(?:github:)?([a-zA-Z0-9_-]+)\/([a-zA-Z0-9_.-]+)(?:#([a-zA-Z0-9_.-]+))?$/;
  const githubMatch = plugin.match(githubRegex);
  if (!githubMatch) {
    throw new Error("Invalid GitHub repository format");
  }
  const [, owner, repo, ref] = githubMatch;
  const githubSpecifier = `github:${owner}/${repo}${ref ? `#${ref}` : ""}`;
  const pluginNameForPostInstall = repo;
  const success = await installPlugin(githubSpecifier, cwd, void 0, opts.skipVerification);
  if (success) {
    logger3.info(`Successfully installed ${pluginNameForPostInstall} from ${githubSpecifier}.`);
    if (!opts.skipEnvPrompt) {
      await new Promise((resolve2) => setTimeout(resolve2, 50));
      const packageName = extractPackageName(plugin);
      console.log(`
\u{1F527} Checking environment variables for ${packageName}...`);
      try {
        await promptForPluginEnvVars(packageName, cwd);
      } catch (error) {
        logger3.warn(
          `Warning: Could not prompt for environment variables: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    } else {
      console.log(`
\u23ED\uFE0F  Skipping environment variable prompts due to --skip-env-prompt flag`);
    }
    process.exit(0);
  } else {
    logger3.error(`Failed to install plugin from ${githubSpecifier}.`);
    process.exit(1);
  }
}
async function installPluginFromRegistry(plugin, cwd, opts) {
  const cachedRegistry = await fetchPluginRegistry();
  if (!cachedRegistry || !cachedRegistry.registry) {
    logger3.error('Plugin registry cache not found. Please run "elizaos plugins update" first.');
    process.exit(1);
  }
  const possibleNames = normalizePluginName(plugin);
  const pluginKey = possibleNames.find((name) => cachedRegistry.registry[name]);
  const targetName = pluginKey || plugin;
  const registryInstallResult = await installPlugin(
    targetName,
    cwd,
    opts.tag,
    opts.skipVerification
  );
  if (registryInstallResult) {
    console.log(`Successfully installed ${targetName}`);
    if (!opts.skipEnvPrompt) {
      await new Promise((resolve2) => setTimeout(resolve2, 50));
      const updatedDependencies = getDependenciesFromDirectory(cwd);
      const actualPackageName = findPluginPackageName(targetName, updatedDependencies || {}) || targetName;
      console.log(`
\u{1F527} Checking environment variables for ${actualPackageName}...`);
      try {
        await promptForPluginEnvVars(actualPackageName, cwd);
      } catch (error) {
        logger3.warn(
          `Warning: Could not prompt for environment variables: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    } else {
      console.log(`
\u23ED\uFE0F  Skipping environment variable prompts due to --skip-env-prompt flag`);
    }
    process.exit(0);
  }
  console.error(`Failed to install ${targetName} from registry.`);
  process.exit(1);
}
async function addPlugin(pluginArg, opts) {
  if (!pluginArg || !pluginArg.trim()) {
    logger3.error("Plugin name cannot be empty or whitespace-only.");
    logger3.info(
      'Please provide a valid plugin name (e.g., "openai", "plugin-anthropic", "@elizaos/plugin-sql")'
    );
    process.exit(1);
  }
  const cwd = process.cwd();
  const directoryInfo = detectDirectoryType(cwd);
  if (!directoryInfo || !directoryInfo.hasPackageJson) {
    logger3.error(
      `Command must be run inside an ElizaOS project directory. This directory is: ${directoryInfo?.type || "invalid or inaccessible"}`
    );
    process.exit(1);
  }
  const allDependencies = getDependenciesFromDirectory(cwd);
  if (!allDependencies) {
    logger3.error("Could not read dependencies from package.json");
    process.exit(1);
  }
  let plugin = pluginArg;
  const httpsGitHubUrlRegex = (
    // eslint-disable-next-line no-useless-escape
    /^https?:\/\/github\.com\/([a-zA-Z0-9_-]+)\/([a-zA-Z0-9_.-]+?)(?:\.git)?(?:(?:#|\/tree\/|\/commit\/)([a-zA-Z0-9_.-]+))?\/?$/
  );
  const httpsMatch = plugin.match(httpsGitHubUrlRegex);
  if (httpsMatch) {
    const [, owner, repo, ref] = httpsMatch;
    plugin = `github:${owner}/${repo}${ref ? `#${ref}` : ""}`;
  }
  const installedPluginName = findPluginPackageName(plugin, allDependencies);
  if (installedPluginName) {
    logger3.info(`Plugin "${installedPluginName}" is already added to this project.`);
    process.exit(0);
  }
  const githubRegex = /^(?:github:)?([a-zA-Z0-9_-]+)\/([a-zA-Z0-9_.-]+)(?:#([a-zA-Z0-9_.-]+))?$/;
  if (githubRegex.test(plugin)) {
    await installPluginFromGitHub(plugin, cwd, opts);
  } else {
    await installPluginFromRegistry(plugin, cwd, opts);
  }
}

// src/commands/plugins/actions/remove.ts
import { logger as logger4 } from "@elizaos/core";
import { execa } from "execa";
import { existsSync as existsSync9, rmSync } from "fs";
import path9 from "path";
async function removePlugin(plugin) {
  const cwd = process.cwd();
  const directoryInfo = detectDirectoryType(cwd);
  if (!directoryInfo || !directoryInfo.hasPackageJson) {
    console.error(
      `Could not read or parse package.json. This directory is: ${directoryInfo?.type || "invalid or inaccessible"}`
    );
    process.exit(1);
  }
  const allDependencies = getDependenciesFromDirectory(cwd);
  if (!allDependencies) {
    console.error(
      "Could not read dependencies from package.json. Cannot determine which package to remove."
    );
    process.exit(1);
  }
  const packageNameToRemove = findPluginPackageName(plugin, allDependencies);
  if (!packageNameToRemove) {
    logger4.warn(`Plugin matching "${plugin}" not found in project dependencies.`);
    console.info("\nCheck installed plugins using: elizaos plugins installed-plugins");
    process.exit(0);
  }
  console.info(`Removing ${packageNameToRemove}...`);
  try {
    await execa("bun", ["remove", packageNameToRemove], {
      cwd,
      stdio: "inherit"
    });
  } catch (execError) {
    logger4.error(
      `Failed to run 'bun remove ${packageNameToRemove}': ${execError instanceof Error ? execError.message : String(execError)}`
    );
    if (execError && typeof execError === "object" && "stderr" in execError && typeof execError.stderr === "string" && execError.stderr.includes("not found")) {
      logger4.info(
        `'bun remove' indicated package was not found. Continuing with directory removal attempt.`
      );
    } else {
      handleError(execError);
      process.exit(1);
    }
  }
  let baseName = packageNameToRemove;
  if (packageNameToRemove.includes("/")) {
    const parts = packageNameToRemove.split("/");
    baseName = parts[parts.length - 1];
  }
  baseName = baseName.replace(/^plugin-/, "");
  const dirNameToRemove = `plugin-${baseName}`;
  const pluginDir = path9.join(cwd, dirNameToRemove);
  if (existsSync9(pluginDir)) {
    try {
      rmSync(pluginDir, { recursive: true, force: true });
    } catch (rmError) {
      logger4.error(
        `Failed to remove directory ${pluginDir}: ${rmError instanceof Error ? rmError.message : String(rmError)}`
      );
    }
  } else {
    const nonPrefixedDir = path9.join(cwd, baseName);
    if (existsSync9(nonPrefixedDir)) {
      try {
        rmSync(nonPrefixedDir, { recursive: true, force: true });
      } catch (rmError) {
        logger4.error(
          `Failed to remove directory ${nonPrefixedDir}: ${rmError instanceof Error ? rmError.message : String(rmError)}`
        );
      }
    }
  }
  console.log(`Successfully removed ${packageNameToRemove}`);
}

// src/commands/plugins/actions/list.ts
import { logger as logger5 } from "@elizaos/core";
async function listAvailablePlugins(opts) {
  const cachedRegistry = await fetchPluginRegistry();
  if (!cachedRegistry || !cachedRegistry.registry || Object.keys(cachedRegistry.registry).length === 0) {
    logger5.info("Plugin cache is empty or not found.");
    console.log('\nPlease run "elizaos plugins update" to fetch the latest plugin registry.');
    return;
  }
  let availablePluginsToDisplay = [];
  const allPlugins = cachedRegistry ? Object.entries(cachedRegistry.registry) : [];
  let displayTitle = "Available v1.x plugins";
  if (opts.all) {
    displayTitle = "All plugins in local cache (detailed view)";
    if (allPlugins.length === 0) {
      console.log("No plugins found in the registry.");
    }
    allPlugins.forEach(([name, info]) => {
      console.log(`
Plugin: ${name}`);
      const repoInfo = info.git?.repo || info.npm?.repo;
      console.log(`  Repository: ${repoInfo || "N/A"}`);
      console.log(`  v0 Compatible: ${info.supports.v0 ? "Yes" : "No"}`);
      if (info.npm?.v0 || info.git?.v0?.version) {
        const ver = info.npm?.v0 || info.git?.v0?.version;
        const branch = info.git?.v0?.branch;
        console.log(`    Version: ${ver || "N/A"}${branch ? ` (branch: ${branch})` : ""}`);
      }
      console.log(`  v1 Compatible: ${info.supports.v1 ? "Yes" : "No"}`);
      if (info.npm?.v1 || info.git?.v1?.version) {
        const ver = info.npm?.v1 || info.git?.v1?.version;
        const branch = info.git?.v1?.branch;
        console.log(`    Version: ${ver || "N/A"}${branch ? ` (branch: ${branch})` : ""}`);
      }
    });
    console.log("");
    return;
  } else if (opts.v0) {
    displayTitle = "Available v0.x plugins";
    availablePluginsToDisplay = allPlugins.filter(([, info]) => info.supports.v0).map(([name]) => name);
  } else {
    availablePluginsToDisplay = allPlugins.filter(([, info]) => info.supports.v1).map(([name]) => name);
  }
  logHeader(displayTitle);
  if (availablePluginsToDisplay.length === 0) {
    console.log("No plugins found matching the criteria in the registry.");
  } else {
    for (const pluginName of availablePluginsToDisplay) {
      console.log(`${pluginName}`);
    }
  }
  console.log("");
}
async function listInstalledPlugins() {
  const cwd = process.cwd();
  const directoryInfo = detectDirectoryType(cwd);
  if (!directoryInfo || !directoryInfo.hasPackageJson) {
    console.error(
      `Could not read or parse package.json. This directory is: ${directoryInfo?.type || "invalid or inaccessible"}`
    );
    console.info("Please run this command from the root of an ElizaOS project.");
    process.exit(1);
  }
  const allDependencies = getDependenciesFromDirectory(cwd);
  if (!allDependencies) {
    console.error("Could not read dependencies from package.json.");
    process.exit(1);
  }
  const pluginNames = Object.keys(allDependencies).filter((depName) => {
    return /^(@elizaos(-plugins)?\/)?plugin-.+/.test(depName);
  });
  if (pluginNames.length === 0) {
    console.log("No Eliza plugins found in the project dependencies (package.json).");
  } else {
    logHeader("Plugins Added:");
    for (const pluginName of pluginNames) {
      console.log(`${pluginName}`);
    }
    console.log("");
  }
}

// src/commands/plugins/actions/upgrade.ts
import { logger as logger6 } from "@elizaos/core";
import path10 from "path";
async function upgradePlugin(pluginPath, opts) {
  try {
    const { PluginMigrator } = await import("./migrator-UQ4XFYE5.js");
    if (opts.apiKey) {
      process.env.ANTHROPIC_API_KEY = opts.apiKey;
    }
    if (!process.env.ANTHROPIC_API_KEY) {
      logger6.error("ANTHROPIC_API_KEY is required for plugin upgrade.");
      console.log("\nPlease set ANTHROPIC_API_KEY environment variable or use --api-key option.");
      process.exit(1);
    }
    const migrator = new PluginMigrator({
      skipTests: opts.skipTests,
      skipValidation: opts.skipValidation
    });
    console.log(`
${emoji.rocket(`Starting plugin upgrade for: ${pluginPath}`)}
`);
    const result = await migrator.migrate(pluginPath);
    if (result.success) {
      console.log(`
${emoji.success("Plugin successfully upgraded!")}`);
      console.log(`   Branch: ${result.branchName}`);
      console.log(`   Location: ${result.repoPath}`);
      console.log(`
The upgraded plugin has been copied to your current directory.`);
      console.log(`
Next steps:`);
      console.log(`1. cd ${path10.basename(result.repoPath ?? "")}`);
      console.log(`2. Review the changes`);
      console.log(`3. Test the upgraded plugin thoroughly`);
      console.log(`4. Push to GitHub and create a pull request when ready`);
    } else {
      logger6.error(`Plugin upgrade failed: ${result.error?.message}`);
      process.exit(1);
    }
  } catch (error) {
    handleError(error);
    process.exit(1);
  }
}

// src/commands/plugins/actions/generate.ts
import { logger as logger7 } from "@elizaos/core";
import { readFileSync as readFileSync3 } from "fs";
import path11 from "path";
async function generatePlugin(opts) {
  try {
    const { PluginCreator } = await import("./plugin-creator-TLQLTQIB.js");
    if (opts.apiKey) {
      process.env.ANTHROPIC_API_KEY = opts.apiKey;
    }
    if (!process.env.ANTHROPIC_API_KEY) {
      logger7.error("ANTHROPIC_API_KEY is required for plugin generation.");
      console.log("\nPlease set ANTHROPIC_API_KEY environment variable or use --api-key option.");
      process.exit(1);
    }
    let spec = void 0;
    if (opts.specFile) {
      try {
        const specContent = readFileSync3(opts.specFile, "utf-8");
        spec = JSON.parse(specContent);
      } catch (error) {
        logger7.error(
          `Failed to read or parse spec file: ${error instanceof Error ? error.message : String(error)}`
        );
        process.exit(1);
      }
    } else if (opts.skipPrompts) {
      logger7.error("--skip-prompts requires --spec-file to be provided");
      process.exit(1);
    }
    const creator = new PluginCreator({
      skipTests: opts.skipTests,
      skipValidation: opts.skipValidation,
      skipPrompts: opts.skipPrompts,
      spec
    });
    console.log(`
${emoji.rocket("Starting AI-powered plugin generation...")}
`);
    const result = await creator.create();
    if (result.success) {
      console.log(`
${emoji.success("Plugin successfully generated!")}`);
      console.log(`   Name: ${result.pluginName}`);
      console.log(`   Location: ${result.pluginPath}`);
      console.log(`
The plugin has been created in your current directory.`);
      console.log(`
Next steps:`);
      console.log(`1. cd ${path11.basename(result.pluginPath ?? "")}`);
      console.log(`2. Review the generated code`);
      console.log(`3. Test the plugin: bun test`);
      console.log(`4. Add to your ElizaOS project`);
    } else {
      logger7.error(`Plugin generation failed: ${result.error?.message}`);
      process.exit(1);
    }
  } catch (error) {
    handleError(error);
    process.exit(1);
  }
}

// src/commands/plugins/index.ts
var plugins = new Command3().name("plugins").description("Manage ElizaOS plugins").action(() => {
  plugins.help();
});
var pluginsCommand = plugins.command("list").aliases(["l", "ls"]).description("List available plugins to install into the project (shows v1.x plugins by default)").option("--all", "List all plugins from the registry with detailed version info").option("--v0", "List only v0.x compatible plugins").action(async (opts) => {
  try {
    await listAvailablePlugins(opts);
  } catch (error) {
    handleError(error);
  }
});
plugins.command("add").alias("install").description("Add a plugin to the project").argument("<plugin>", 'plugin name (e.g., "abc", "plugin-abc", "elizaos/plugin-abc")').option("-s, --skip-env-prompt", "Skip prompting for environment variables").option("--skip-verification", "Skip plugin import verification after installation").option("-b, --branch <branchName>", "Branch to install from when using monorepo source", "main").option("-T, --tag <tagname>", "Specify a tag to install (e.g., beta)").action(async (pluginArg, opts) => {
  try {
    await addPlugin(pluginArg, opts);
  } catch (error) {
    handleError(error);
  }
});
plugins.command("installed-plugins").description("List plugins found in the project dependencies").action(async () => {
  try {
    await listInstalledPlugins();
  } catch (error) {
    if (error instanceof SyntaxError) {
      console.error(`Error parsing package.json: ${error.message}`);
      process.exit(1);
    }
    handleError(error);
    process.exit(1);
  }
});
plugins.command("remove").aliases(["delete", "del", "rm"]).description("Remove a plugin from the project").argument("<plugin>", 'plugins name (e.g., "abc", "plugin-abc", "elizaos/plugin-abc")').action(async (plugin, _opts) => {
  try {
    await removePlugin(plugin);
  } catch (error) {
    handleError(error);
    process.exit(1);
  }
});
plugins.command("upgrade").description("Upgrade a plugin from version 0.x to 1.x using AI-powered migration").argument("<path>", "GitHub repository URL or local folder path").option("--api-key <key>", "Anthropic API key (or use ANTHROPIC_API_KEY env var)").option("--skip-tests", "Skip test validation loop").option("--skip-validation", "Skip production readiness validation").action(async (pluginPath, opts) => {
  await upgradePlugin(pluginPath, opts);
});
plugins.command("generate").description("Generate a new plugin using AI-powered code generation").option("--api-key <key>", "Anthropic API key (or use ANTHROPIC_API_KEY env var)").option("--skip-tests", "Skip test validation loop").option("--skip-validation", "Skip production readiness validation").option("--skip-prompts", "Skip interactive prompts (requires --spec-file)").option("--spec-file <path>", "Path to JSON file containing plugin specification").action(async (opts) => {
  await generatePlugin(opts);
});

// src/commands/publish/index.ts
import { Command as Command5 } from "commander";
import { promises as fs8 } from "fs";
import path17 from "path";
import * as clack9 from "@clack/prompts";

// src/commands/publish/actions/npm-publish.ts
import { execa as execa2 } from "execa";
import { promises as fs2 } from "fs";
import path12 from "path";
async function publishToNpm(cwd, packageJson, npmUsername) {
  console.info(`Publishing as npm user: ${npmUsername}`);
  if (!packageJson.npmPackage || packageJson.npmPackage === "${NPM_PACKAGE}") {
    packageJson.npmPackage = packageJson.name;
    console.info(`Set npmPackage to: ${packageJson.npmPackage}`);
    const packageJsonPath = path12.join(cwd, "package.json");
    await fs2.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2), "utf-8");
  }
  console.info("Building package...");
  await execa2("npm", ["run", "build"], { cwd, stdio: "inherit" });
  console.info("Publishing to npm...");
  await execa2("npm", ["publish", "--ignore-scripts"], { cwd, stdio: "inherit" });
  console.log(`[\u221A] Successfully published ${packageJson.name}@${packageJson.version} to npm`);
}

// src/commands/publish/actions/github-publish.ts
async function publishToGitHubAction(cwd, packageJson, credentials, skipRegistry = false, dryRun = false) {
  console.info("Publishing to GitHub and registry...");
  const result = await publishToGitHub(
    cwd,
    packageJson,
    credentials.username,
    skipRegistry,
    dryRun
  );
  if (!result) {
    throw new Error("GitHub publishing failed");
  }
  console.log(
    `[\u221A] Successfully published plugin ${packageJson.name}@${packageJson.version} to GitHub`
  );
  return result;
}

// src/commands/publish/actions/registry-publish.ts
import { promises as fs3 } from "fs";
import path13 from "path";
var REGISTRY_PACKAGES_PATH = "packages";
var LOCAL_REGISTRY_PATH = "packages/registry";
async function updateRegistryIndex(packageMetadata, dryRun = false) {
  try {
    const indexPath = dryRun ? path13.join(process.cwd(), LOCAL_REGISTRY_PATH, "index.json") : path13.join(process.cwd(), "temp-registry", "index.json");
    try {
      await fs3.access(path13.dirname(indexPath));
    } catch {
      await fs3.mkdir(path13.dirname(indexPath), { recursive: true });
      try {
        await fs3.access(indexPath);
      } catch {
        await fs3.writeFile(
          indexPath,
          JSON.stringify(
            {
              v1: { packages: {} },
              v2: { packages: {} }
            },
            null,
            2
          )
        );
      }
    }
    let indexContent;
    try {
      indexContent = await fs3.readFile(indexPath, "utf-8");
    } catch (error) {
      indexContent = JSON.stringify({
        v1: { packages: {} },
        v2: { packages: {} }
      });
    }
    const index = JSON.parse(indexContent);
    if (!index.v2) {
      index.v2 = { packages: {} };
    }
    if (!index.v2.packages) {
      index.v2.packages = {};
    }
    if (!index.v2.packages[packageMetadata.name]) {
      index.v2.packages[packageMetadata.name] = {
        name: packageMetadata.name,
        description: packageMetadata.description,
        type: packageMetadata.type,
        versions: {}
      };
    }
    const packageInfo = index.v2.packages[packageMetadata.name];
    packageInfo.description = packageMetadata.description;
    packageInfo.type = packageMetadata.type;
    packageInfo.versions[packageMetadata.version] = {
      version: packageMetadata.version,
      runtimeVersion: packageMetadata.runtimeVersion,
      platform: packageMetadata.platform,
      publishedAt: packageMetadata.publishedAt,
      published: !dryRun
    };
    await fs3.writeFile(indexPath, JSON.stringify(index, null, 2));
    console.info(
      `Registry index ${dryRun ? "(dry run) " : ""}updated with ${packageMetadata.name}@${packageMetadata.version}`
    );
    return true;
  } catch (error) {
    console.error(
      `Failed to update registry index: ${error instanceof Error ? error.message : String(error)}`
    );
    return false;
  }
}
async function savePackageToRegistry(packageMetadata, dryRun = false) {
  try {
    const packageDir = dryRun ? path13.join(process.cwd(), LOCAL_REGISTRY_PATH, REGISTRY_PACKAGES_PATH, packageMetadata.name) : path13.join(process.cwd(), "temp-registry", REGISTRY_PACKAGES_PATH, packageMetadata.name);
    const metadataPath = path13.join(packageDir, `${packageMetadata.version}.json`);
    await fs3.mkdir(packageDir, { recursive: true });
    await fs3.writeFile(metadataPath, JSON.stringify(packageMetadata, null, 2));
    console.info(`Package metadata ${dryRun ? "(dry run) " : ""}saved to ${metadataPath}`);
    await updateRegistryIndex(packageMetadata, dryRun);
    return true;
  } catch (error) {
    console.error(
      `Failed to save package metadata: ${error instanceof Error ? error.message : String(error)}`
    );
    return false;
  }
}

// src/commands/publish/utils/validation.ts
import { promises as fs4 } from "fs";
import path14 from "path";
import * as clack5 from "@clack/prompts";
async function validatePluginRequirements(cwd, packageJson) {
  const errors = [];
  const warnings = [];
  const packageName = packageJson.name.split("/").pop() || packageJson.name;
  if (!packageName.startsWith("plugin-")) {
    errors.push(
      'Plugin name must start with "plugin-". Please update your package name and try again.'
    );
  }
  const pluginDirName = path14.basename(cwd);
  const expectedDefaultDesc = `ElizaOS plugin for ${pluginDirName.replace("plugin-", "")}`;
  if (packageJson.description === expectedDefaultDesc || packageJson.description === "${PLUGINDESCRIPTION}") {
    warnings.push(
      "Description appears to be the default generated description. Consider writing a custom description."
    );
  }
  const imagesDir = path14.join(cwd, "images");
  const logoPath = path14.join(imagesDir, "logo.jpg");
  const bannerPath = path14.join(imagesDir, "banner.jpg");
  try {
    await fs4.access(logoPath);
  } catch {
    warnings.push("Missing required logo.jpg in images/ directory (400x400px, max 500KB).");
  }
  try {
    await fs4.access(bannerPath);
  } catch {
    warnings.push("Missing required banner.jpg in images/ directory (1280x640px, max 1MB).");
  }
  if (errors.length > 0) {
    console.error("Plugin validation failed:");
    errors.forEach((error) => console.error(`  - ${error}`));
    console.error("\nPlease fix these issues and try publishing again.");
    process.exit(1);
  }
  if (warnings.length > 0) {
    console.warn("Plugin validation warnings:");
    warnings.forEach((warning) => console.warn(`  - ${warning}`));
    console.warn("Your plugin may get rejected if you submit without addressing these issues.");
    const proceed = await clack5.confirm({
      message: "Do you wish to continue anyway?",
      initialValue: false
    });
    if (clack5.isCancel(proceed)) {
      clack5.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (!proceed) {
      console.info("Publishing cancelled. Please address the warnings and try again.");
      process.exit(0);
    }
  }
}
function isMaintainer(packageJson, username) {
  if (!packageJson.maintainers) {
    return true;
  }
  return packageJson.maintainers.includes(username);
}
function displayRegistryPublicationMessage(opts, userIsMaintainer, registryPrUrl) {
  if (opts.skipRegistry) {
    console.info("Registry publication skipped as requested with --skip-registry flag");
    return;
  }
  if (opts.npm) {
    console.warn("NPM publishing currently does not update the registry.");
    console.info("To include this package in the registry:");
    console.info(`1. Fork the registry repository at https://github.com/elizaos/registry`);
    console.info("2. Add your package metadata");
    console.info("3. Submit a pull request to the main repository");
    return;
  }
  if (userIsMaintainer) {
    if (!registryPrUrl) {
      console.info("Registry publication completed during GitHub publishing process.");
    }
  } else {
    console.info("Package published, but you're not a maintainer of this package.");
    console.info("To include this package in the registry, please:");
    console.info(`1. Fork the registry repository at https://github.com/elizaos/registry`);
    console.info("2. Add your package metadata");
    console.info("3. Submit a pull request to the main repository");
  }
}

// src/commands/publish/utils/metadata.ts
async function generatePackageMetadata(packageJson, cliVersion, username) {
  const metadata = {
    name: packageJson.name,
    version: packageJson.version,
    description: packageJson.description || "",
    type: packageJson.type || "plugin",
    // plugin or project
    platform: packageJson.platform || "universal",
    // node, browser, or universal
    runtimeVersion: cliVersion,
    // Compatible CLI/runtime version
    repository: packageJson.repository?.url || "",
    maintainers: packageJson.maintainers || [username],
    publishedAt: (/* @__PURE__ */ new Date()).toISOString(),
    publishedBy: username,
    dependencies: packageJson.dependencies || {},
    tags: packageJson.keywords || [],
    license: packageJson.license || "UNLICENSED"
  };
  if (packageJson.npmPackage) {
    metadata.npmPackage = packageJson.npmPackage;
  }
  if (packageJson.githubRepo) {
    metadata.githubRepo = packageJson.githubRepo;
  }
  if (metadata.type === "plugin" && !metadata.tags.includes("plugin")) {
    metadata.tags.push("plugin");
  } else if (metadata.type === "project" && !metadata.tags.includes("project")) {
    metadata.tags.push("project");
  }
  return metadata;
}

// src/commands/publish/utils/authentication.ts
import { execa as execa3 } from "execa";
import * as clack6 from "@clack/prompts";
async function getNpmUsername() {
  console.info(
    "NPM authentication required for registry compliance (package name must match potential NPM package)."
  );
  try {
    const { stdout } = await execa3("npm", ["whoami"]);
    const currentUser = stdout.trim();
    console.info(`Found existing NPM login: ${currentUser}`);
    const useExisting = await clack6.confirm({
      message: `Use NPM account "${currentUser}" for package naming?`,
      initialValue: true
    });
    if (clack6.isCancel(useExisting)) {
      clack6.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (useExisting) {
      return currentUser;
    } else {
      console.info("Please login with your desired NPM account...");
      await execa3("npm", ["login"], { stdio: "inherit" });
      const { stdout: newStdout } = await execa3("npm", ["whoami"]);
      const newUser = newStdout.trim();
      console.info(`Logged in as: ${newUser}`);
      return newUser;
    }
  } catch (error) {
    console.info("Not logged into NPM. Please login to continue...");
    try {
      await execa3("npm", ["login"], { stdio: "inherit" });
      const { stdout } = await execa3("npm", ["whoami"]);
      const username = stdout.trim();
      console.info(`Successfully logged in as: ${username}`);
      return username;
    } catch (loginError) {
      console.error("NPM login failed. Registry compliance requires a valid NPM account.");
      process.exit(1);
    }
  }
}

// src/commands/publish/utils/version-check.ts
import { execa as execa7 } from "execa";
import { promises as fs7 } from "fs";
import path16 from "path";
import { fileURLToPath } from "url";
import * as clack8 from "@clack/prompts";

// src/commands/update/index.ts
import { logger as logger11 } from "@elizaos/core";
import { Command as Command4 } from "commander";

// src/commands/update/actions/cli-update.ts
import { logger as logger9 } from "@elizaos/core";
import { execa as execa5 } from "execa";

// src/commands/update/utils/version-utils.ts
import { logger as logger8 } from "@elizaos/core";
import { execa as execa4 } from "execa";
import * as semver from "semver";
var SPECIAL_VERSION_TAGS = ["latest", "next", "canary", "rc", "dev", "nightly", "alpha"];
var ELIZAOS_ORG = "@elizaos";
var FALLBACK_VERSION = "0.0.0";
async function getVersion2() {
  try {
    const envInfo = await UserEnvironment.getInstance().getInfo();
    return envInfo.cli.version;
  } catch (error) {
    logger8.error("Error getting CLI version:", error);
    return FALLBACK_VERSION;
  }
}
var isWorkspaceVersion = (version) => version === "workspace:*" || version === "workspace" || version.startsWith("workspace:");
var isSpecialVersionTag = (version) => SPECIAL_VERSION_TAGS.includes(version);
function checkVersionNeedsUpdate(currentVersion, targetVersion) {
  try {
    const cleanCurrent = String(currentVersion).replace(/^[\^~]/, "");
    if (isSpecialVersionTag(cleanCurrent)) {
      return { needsUpdate: true };
    }
    if (!semver.valid(cleanCurrent) && !semver.validRange(cleanCurrent)) {
      return { needsUpdate: false, error: "Invalid semver format" };
    }
    const versionToCompare = semver.validRange(cleanCurrent) ? semver.minVersion(cleanCurrent)?.version || cleanCurrent : cleanCurrent;
    return { needsUpdate: semver.lt(versionToCompare, targetVersion) };
  } catch (error) {
    return { needsUpdate: false, error: error instanceof Error ? error.message : String(error) };
  }
}
function isMajorUpdate(currentVersion, targetVersion) {
  try {
    const cleanCurrent = String(currentVersion).replace(/^[\^~]/, "");
    if (isSpecialVersionTag(cleanCurrent) || !semver.valid(cleanCurrent)) {
      return false;
    }
    const currentMajor = semver.major(cleanCurrent);
    const targetMajor = semver.major(targetVersion);
    return targetMajor > currentMajor;
  } catch {
    return false;
  }
}
async function fetchLatestVersion(packageName) {
  try {
    const { stdout } = await execa4("npm", ["view", packageName, "version"], {
      env: { NODE_ENV: "production" }
    });
    const version = stdout.trim();
    logger8.debug(`Latest version of ${packageName} from npm: ${version}`);
    return version;
  } catch (error) {
    logger8.error(
      `Failed to fetch version for ${packageName}: ${error instanceof Error ? error.message : String(error)}`
    );
    return null;
  }
}

// src/commands/update/actions/cli-update.ts
async function performCliUpdate(options = {}) {
  try {
    const currentVersion = await getVersion2();
    const targetVersion = options.version || "latest";
    let latestVersion;
    if (targetVersion === "latest") {
      const fetchedVersion = await fetchLatestVersion("@elizaos/cli");
      if (!fetchedVersion) {
        throw new Error("Unable to fetch latest CLI version");
      }
      latestVersion = fetchedVersion;
    } else {
      latestVersion = targetVersion;
    }
    const { needsUpdate } = checkVersionNeedsUpdate(currentVersion, latestVersion);
    if (!needsUpdate) {
      console.log(`CLI is already at the latest version (${currentVersion}) [\u2713]`);
      return true;
    }
    console.log(`Updating CLI from ${currentVersion} to ${latestVersion}...`);
    if (!options.skipBunMigration) {
      const npmInstallation = await isCliInstalledViaNpm();
      if (npmInstallation) {
        logger9.info("Detected npm installation, migrating to bun...");
        try {
          await migrateCliToBun(latestVersion);
          console.log(`CLI updated successfully to version ${latestVersion} [\u2713]`);
          return true;
        } catch (migrationError) {
          logger9.warn("Migration to bun failed, falling back to npm update...");
          logger9.debug(
            "Migration error:",
            migrationError instanceof Error ? migrationError.message : String(migrationError)
          );
          try {
            await execa5("npm", ["install", "-g", `@elizaos/cli@${latestVersion}`], {
              stdio: "inherit"
            });
            console.log(`CLI updated successfully to version ${latestVersion} [\u2713]`);
            return true;
          } catch (npmError) {
            throw new Error(
              `Both bun migration and npm fallback failed. Bun: ${migrationError instanceof Error ? migrationError.message : String(migrationError)}, npm: ${npmError instanceof Error ? npmError.message : String(npmError)}`
            );
          }
        }
      }
    }
    await executeInstallation("@elizaos/cli", latestVersion, process.cwd());
    console.log(`CLI updated successfully to version ${latestVersion} [\u2713]`);
    return true;
  } catch (error) {
    console.error(`CLI update failed: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

// src/commands/update/actions/dependency-update.ts
import * as clack7 from "@clack/prompts";
import { promises as fs6 } from "fs";
import * as path15 from "path";

// src/commands/update/utils/package-utils.ts
import fs5 from "fs/promises";
import { execa as execa6 } from "execa";
import { logger as logger10 } from "@elizaos/core";
async function checkForUpdates(dependencies) {
  const updates = {};
  const elizaPackages = Object.entries(dependencies).filter(([pkg]) => pkg.startsWith(ELIZAOS_ORG)).filter(([, version]) => !isWorkspaceVersion(version));
  for (const [pkg, currentVersion] of elizaPackages) {
    const latestVersion = await fetchLatestVersion(pkg);
    if (!latestVersion) continue;
    const { needsUpdate, error } = checkVersionNeedsUpdate(currentVersion, latestVersion);
    if (needsUpdate) {
      updates[pkg] = { current: currentVersion, latest: latestVersion };
    } else if (error) {
      logger10.debug(`${pkg}: ${error}`);
    }
  }
  return { hasUpdates: Object.keys(updates).length > 0, updates };
}
function displayUpdateSummary(updates) {
  console.log("\nAvailable updates:");
  Object.entries(updates).forEach(([pkg, { current, latest }]) => {
    const majorUpdate = isMajorUpdate(current, latest);
    const updateType = majorUpdate ? " (MAJOR)" : "";
    console.log(`  ${pkg}: ${current} \u2192 ${latest}${updateType}`);
  });
}
async function updatePackageJson(packageJsonPath, updates) {
  const content = await fs5.readFile(packageJsonPath, "utf8");
  const packageJson = JSON.parse(content);
  let modified = false;
  for (const [pkg, { latest }] of Object.entries(updates)) {
    if (packageJson.dependencies?.[pkg]) {
      packageJson.dependencies[pkg] = `^${latest}`;
      modified = true;
    }
    if (packageJson.devDependencies?.[pkg]) {
      packageJson.devDependencies[pkg] = `^${latest}`;
      modified = true;
    }
  }
  if (modified) {
    await fs5.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2) + "\n");
    console.log("Updated package.json with new versions");
  }
}
async function installDependencies(cwd) {
  console.log("\nInstalling updated packages...");
  try {
    const packageManager = await getPackageManager();
    await execa6(packageManager, ["install"], { cwd, stdio: "inherit" });
    console.log("Dependencies installed successfully [\u2713]");
  } catch (error) {
    throw new Error(
      `Failed to install dependencies: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}

// src/commands/update/actions/dependency-update.ts
async function updateDependencies(cwd, isPlugin2, options = {}) {
  const { dryRun = false, skipBuild = false } = options;
  const packageJsonPath = path15.join(cwd, "package.json");
  const content = await fs6.readFile(packageJsonPath, "utf8");
  const packageJson = JSON.parse(content);
  const allDependencies = {
    ...packageJson.dependencies,
    ...packageJson.devDependencies
  };
  const { hasUpdates, updates } = await checkForUpdates(allDependencies);
  if (!hasUpdates) {
    console.log("All ElizaOS packages are up to date! [\u2713]");
    return;
  }
  displayUpdateSummary(updates);
  if (dryRun) {
    console.log("\nTo apply these updates, run: elizaos update");
    return;
  }
  const hasMajorUpdates = Object.entries(updates).some(
    ([, { current, latest }]) => isMajorUpdate(current, latest)
  );
  if (hasMajorUpdates) {
    const confirmMajor = await clack7.confirm({
      message: "This update includes major version changes. Continue?",
      initialValue: false
    });
    if (clack7.isCancel(confirmMajor)) {
      clack7.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (!confirmMajor) {
      console.log("Update cancelled");
      return;
    }
  }
  await updatePackageJson(packageJsonPath, updates);
  await installDependencies(cwd);
  if (!skipBuild) {
    console.log("\nBuilding project...");
    await buildProject(cwd, isPlugin2);
    console.log("Build completed successfully [\u2713]");
  }
}

// src/commands/update/utils/directory-utils.ts
function handleInvalidDirectory(directoryInfo) {
  const messages = {
    "non-elizaos-dir": [
      "This directory doesn't appear to be an ElizaOS project.",
      directoryInfo.packageName && `Found package: ${directoryInfo.packageName}`,
      "ElizaOS update only works in ElizaOS projects, plugins, the ElizaOS monorepo, and ElizaOS infrastructure packages (e.g. client, cli).",
      "To create a new ElizaOS project, use: elizaos create <project-name>"
    ].filter(Boolean),
    invalid: [
      "Cannot update packages in this directory.",
      !directoryInfo.hasPackageJson ? "No package.json found. This doesn't appear to be a valid project directory." : "The package.json file appears to be invalid or unreadable.",
      "To create a new ElizaOS project, use: elizaos create <project-name>"
    ].filter(Boolean)
  };
  const messageList = messages[directoryInfo.type];
  if (messageList) {
    messageList.forEach((msg) => console.info(msg));
  } else {
    console.error(`Unexpected directory type: ${directoryInfo.type}`);
  }
}

// src/commands/update/index.ts
var update = new Command4().name("update").description("Update ElizaOS CLI and project dependencies").option("-c, --check", "Check for available updates without applying them").option("--skip-build", "Skip building after updating").option("--cli", "Update only the CLI").option("--packages", "Update only packages").hook("preAction", async () => {
  try {
    await displayBanner();
  } catch {
    logger11.debug("Banner display failed, continuing with update");
  }
}).action(async (options) => {
  try {
    const updateCli = options.cli || !options.cli && !options.packages;
    const updatePackages = options.packages || !options.cli && !options.packages;
    if (updateCli) {
      const isNpx = await isRunningViaNpx();
      const isBunx = await isRunningViaBunx();
      if (isNpx || isBunx) {
        console.warn("CLI update is not available when running via npx or bunx.");
        console.info("Please install the CLI globally:");
        console.info("  bun install -g @elizaos/cli");
        console.info("  # or");
        console.info("  npm install -g @elizaos/cli");
        if (!updatePackages) return;
      } else {
        const success = await performCliUpdate();
        if (!updatePackages) return;
        if (!success) {
          console.warn("CLI update failed, continuing with package updates...");
        }
      }
    }
    if (updatePackages) {
      const cwd = process.cwd();
      const directoryInfo = detectDirectoryType(cwd);
      if (!directoryInfo) {
        console.error("Cannot update packages in this directory.");
        console.info("This directory is not accessible or does not exist.");
        console.info("To create a new ElizaOS project, use: elizaos create <project-name>");
        return;
      }
      logger11.debug(`Detected ${directoryInfo.type}`);
      if (!isValidForUpdates(directoryInfo)) {
        handleInvalidDirectory(directoryInfo);
        return;
      }
      const isPlugin2 = directoryInfo.type === "elizaos-plugin";
      if (directoryInfo.elizaPackageCount === 0) {
        console.info("No ElizaOS packages found in this project.");
        console.info(
          "This might be a new project that hasn't installed ElizaOS dependencies yet."
        );
        console.info("Consider adding ElizaOS packages first, such as: bun add @elizaos/core");
        return;
      }
      console.info(
        `Found ${directoryInfo.elizaPackageCount} ElizaOS package(s) to check for updates`
      );
      const updateOptions = {
        dryRun: options.check,
        skipBuild: options.skipBuild
      };
      await updateDependencies(cwd, isPlugin2, updateOptions);
      if (options.check) {
        console.log(`Version: ${await getVersion2()}`);
      } else {
        const projectType = isPlugin2 ? "Plugin" : "Project";
        console.log(`${projectType} successfully updated to the latest ElizaOS packages`);
      }
    }
  } catch (error) {
    handleError(error);
  }
});

// src/commands/publish/utils/version-check.ts
async function checkCliVersion() {
  try {
    const cliPackageJsonPath = path16.resolve(
      path16.dirname(fileURLToPath(import.meta.url)),
      "../package.json"
    );
    const cliPackageJsonContent = await fs7.readFile(cliPackageJsonPath, "utf-8");
    const cliPackageJson = JSON.parse(cliPackageJsonContent);
    const currentVersion = cliPackageJson.version || "0.0.0";
    const { stdout } = await execa7("npm", ["view", "@elizaos/cli", "time", "--json"]);
    const timeData = JSON.parse(stdout);
    delete timeData.created;
    delete timeData.modified;
    let latestVersion = "";
    let latestDate = /* @__PURE__ */ new Date(0);
    for (const [version, dateString] of Object.entries(timeData)) {
      const publishDate = new Date(dateString);
      if (publishDate > latestDate) {
        latestDate = publishDate;
        latestVersion = version;
      }
    }
    if (latestVersion && latestVersion !== currentVersion) {
      console.warn(`CLI update available: ${currentVersion} \u2192 ${latestVersion}`);
      const update2 = await clack8.confirm({
        message: "Update CLI before publishing?",
        initialValue: false
      });
      if (clack8.isCancel(update2)) {
        clack8.cancel("Operation cancelled.");
        process.exit(0);
      }
      if (update2) {
        console.info("Updating CLI...");
        try {
          await performCliUpdate();
          process.exit(0);
        } catch (updateError) {
          console.error("Failed to update CLI:", updateError);
        }
      }
    }
    return currentVersion;
  } catch (error) {
    console.warn("Could not check for CLI updates");
    return "0.0.0";
  }
}

// src/commands/publish/index.ts
var LOCAL_REGISTRY_PATH2 = "packages/registry";
var publish = new Command5().name("publish").description("Publish a plugin to npm, GitHub, and the registry").option("--npm", "publish to npm only (skip GitHub and registry)", false).option("-t, --test", "test publish process without making changes", false).option("-d, --dry-run", "generate registry files locally without publishing", false).option("--skip-registry", "skip publishing to the registry", false).hook("preAction", async () => {
  await displayBanner();
}).action(async (opts) => {
  try {
    const cwd = process.cwd();
    const directoryInfo = detectDirectoryType(cwd);
    if (!directoryInfo || !directoryInfo.hasPackageJson) {
      console.error(
        `No package.json found in current directory. This directory is: ${directoryInfo?.type || "invalid or inaccessible"}`
      );
      process.exit(1);
    }
    const cliVersion = await checkCliVersion();
    const pluginDirName = path17.basename(process.cwd());
    if (!pluginDirName.startsWith("plugin-")) {
      console.error("This command must be run from a plugin directory (plugin-*)");
      process.exit(1);
    }
    if (!opts.npm) {
      const isValid = await validateDataDir();
      if (!isValid) {
        console.info("\nGitHub credentials required for publishing.");
        console.info("You'll need a GitHub Personal Access Token with these scopes:");
        console.info("  * repo (for repository access)");
        console.info("  * read:org (for organization access)");
        console.info("  * workflow (for workflow access)\n");
        await initializeDataDir();
        const credentials2 = await getGitHubCredentials();
        if (!credentials2) {
          console.error("GitHub credentials setup cancelled.");
          process.exit(1);
        }
        const revalidated = await validateDataDir();
        if (!revalidated) {
          console.error("Failed to validate credentials after saving.");
          process.exit(1);
        }
      }
    }
    const packageJsonPath = path17.join(cwd, "package.json");
    const packageJsonContent = await fs8.readFile(packageJsonPath, "utf-8");
    const packageJson = JSON.parse(packageJsonContent);
    if (!packageJson.name || !packageJson.version) {
      console.error("Invalid package.json: missing name or version.");
      process.exit(1);
    }
    let detectedType;
    if (directoryInfo.type === "elizaos-plugin") {
      detectedType = "plugin";
      console.info("Detected ElizaOS plugin using standardized directory detection");
    } else if (directoryInfo.type === "elizaos-project") {
      detectedType = "project";
      console.info("Detected ElizaOS project using standardized directory detection");
    } else {
      detectedType = "plugin";
      if (packageJson.agentConfig?.pluginType) {
        const pluginType = packageJson.agentConfig.pluginType.toLowerCase();
        if (pluginType.includes("project")) {
          detectedType = "project";
          console.info("Detected project from package.json agentConfig.pluginType");
        }
      } else if (packageJson.eliza?.type === "project") {
        detectedType = "project";
        console.info("Detected project from package.json eliza.type (legacy format)");
      } else if (packageJson.packageType === "project") {
        detectedType = "project";
        console.info("Detected project from package.json packageType field");
      } else {
        console.info(`Defaulting to plugin type. Directory detected as: ${directoryInfo.type}`);
      }
    }
    packageJson.packageType = detectedType;
    packageJson.platform ??= "node";
    if (!packageJson.agentConfig) {
      packageJson.agentConfig = {
        pluginType: detectedType === "plugin" ? "elizaos:plugin:1.0.0" : "elizaos:project:1.0.0",
        pluginParameters: {}
      };
    } else if (!packageJson.agentConfig.pluginType) {
      packageJson.agentConfig.pluginType = detectedType === "plugin" ? "elizaos:plugin:1.0.0" : "elizaos:project:1.0.0";
    }
    if (detectedType === "plugin" && !packageJson.name.includes("plugin-")) {
      console.warn(
        "This doesn't appear to be an ElizaOS plugin. Package name should include 'plugin-'."
      );
      const proceed = await clack9.confirm({
        message: "Proceed anyway?",
        initialValue: false
      });
      if (clack9.isCancel(proceed)) {
        clack9.cancel("Operation cancelled.");
        process.exit(0);
      }
      if (!proceed) {
        process.exit(0);
      }
    }
    let credentials = null;
    if (!opts.npm) {
      credentials = await getGitHubCredentials();
      if (!credentials) {
        console.error("GitHub credentials required for publishing.");
        process.exit(1);
      }
    }
    const npmUsername = await getNpmUsername();
    console.info(`Using NPM username: ${npmUsername}`);
    console.info("Updating package.json with actual values...");
    const placeholderReplacements = {
      // Template default name replacement
      "elizaos-plugin-starter": {
        check: () => packageJson.name === "@elizaos/plugin-starter",
        replace: () => {
          packageJson.name = `@${npmUsername}/${pluginDirName}`;
          console.info(`Set package name: ${packageJson.name}`);
        }
      },
      // Name placeholders (for custom templates)
      "npm-username": {
        check: () => packageJson.name.includes("npm-username"),
        replace: () => {
          packageJson.name = packageJson.name.replace("npm-username", npmUsername);
          console.info(`Set package org: @${npmUsername}`);
        }
      },
      "plugin-name": {
        check: () => packageJson.name.includes("plugin-name"),
        replace: () => {
          packageJson.name = packageJson.name.replace("plugin-name", pluginDirName);
          console.info(`Set package name: ${packageJson.name}`);
        }
      },
      // Description placeholder
      "${PLUGINDESCRIPTION}": {
        check: () => packageJson.description === "${PLUGINDESCRIPTION}",
        replace: () => {
          const simpleName = pluginDirName.replace("plugin-", "");
          packageJson.description = `ElizaOS plugin for ${simpleName}`;
          console.info(`Set description: ${packageJson.description}`);
        }
      },
      // Repository URL placeholder (only for GitHub publishing)
      "${REPO_URL}": {
        check: () => !!(!opts.npm && credentials && packageJson.repository && (packageJson.repository.url === "${REPO_URL}" || packageJson.repository.url === "")),
        replace: () => {
          if (!packageJson.repository) {
            packageJson.repository = { type: "git", url: "" };
          }
          if (credentials) {
            packageJson.repository.url = `git+https://github.com/${credentials.username}/${pluginDirName}.git`;
            console.info(`Set repository: ${packageJson.repository.url}`);
          }
        }
      },
      // Author placeholder (only for GitHub publishing)
      "${GITHUB_USERNAME}": {
        check: () => !!(!opts.npm && credentials && packageJson.author === "${GITHUB_USERNAME}"),
        replace: () => {
          if (credentials) {
            packageJson.author = credentials.username;
            console.info(`Set author: ${packageJson.author}`);
          }
        }
      },
      // Bugs URL placeholder (only for GitHub publishing)
      "bugs-placeholder": {
        check: () => !!(!opts.npm && credentials && packageJson.bugs && packageJson.bugs.url && packageJson.bugs.url.includes("${GITHUB_USERNAME}")),
        replace: () => {
          if (packageJson.bugs?.url && credentials) {
            packageJson.bugs.url = packageJson.bugs.url.replace("${GITHUB_USERNAME}", credentials.username).replace("${PLUGINNAME}", pluginDirName);
            console.info(`Set bugs URL: ${packageJson.bugs.url}`);
          }
        }
      }
    };
    Object.entries(placeholderReplacements).forEach(([_, replacement]) => {
      if (replacement.check()) {
        replacement.replace();
      }
    });
    const finalPluginName = packageJson.name.startsWith("@") ? packageJson.name.split("/")[1] : packageJson.name;
    await fs8.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2), "utf-8");
    await validatePluginRequirements(cwd, packageJson);
    const settings = await getRegistrySettings();
    const publishUsername = credentials ? credentials.username : npmUsername;
    settings.publishConfig = {
      registry: settings.defaultRegistry,
      username: publishUsername,
      useNpm: opts.npm,
      platform: packageJson.platform
    };
    await saveRegistrySettings(settings);
    const packageMetadata = await generatePackageMetadata(
      packageJson,
      cliVersion,
      publishUsername
    );
    console.debug("Generated package metadata:", packageMetadata);
    const userIsMaintainer = isMaintainer(packageJson, publishUsername);
    console.info(
      `User ${publishUsername} is ${userIsMaintainer ? "a maintainer" : "not a maintainer"} of this package`
    );
    if (opts.dryRun) {
      console.info(`Running dry run for plugin registry publication...`);
      const success = await savePackageToRegistry(packageMetadata, true);
      if (success) {
        console.log(
          `[\u221A] Dry run successful: Registry metadata generated for ${packageJson.name}@${packageJson.version}`
        );
        console.info(`Files created in ${LOCAL_REGISTRY_PATH2}`);
      } else {
        console.error("Dry run failed");
        process.exit(1);
      }
      return;
    }
    if (opts.test) {
      console.info(`Running plugin publish tests...`);
      if (opts.npm) {
        console.info("\nTesting npm publishing:");
        const npmTestSuccess = await testPublishToNpm(cwd);
        if (!npmTestSuccess) {
          console.error("npm publishing test failed");
          process.exit(1);
        }
      }
      console.info("\nTesting GitHub publishing:");
      const githubTestSuccess = await testPublishToGitHub(
        packageJson,
        credentials?.username || ""
      );
      if (!githubTestSuccess) {
        console.error("GitHub publishing test failed");
        process.exit(1);
      }
      if (!opts.skipRegistry) {
        console.info("\nTesting registry publishing:");
        const registryTestSuccess = await savePackageToRegistry(packageMetadata, true);
        if (!registryTestSuccess) {
          console.error("Registry publishing test failed");
          process.exit(1);
        }
      } else {
        console.info(
          "\nSkipping registry publishing test as requested with --skip-registry flag"
        );
      }
      console.log("All tests passed successfully!");
      return;
    }
    let publishResult = false;
    let publishedToGitHub = false;
    let registryPrUrl = null;
    console.info(`Publishing plugin to npm...`);
    await publishToNpm(cwd, packageJson, npmUsername);
    packageMetadata.npmPackage = packageJson.name;
    if (!opts.npm && credentials) {
      try {
        publishResult = await publishToGitHubAction(
          cwd,
          packageJson,
          credentials,
          opts.skipRegistry,
          false
        );
        if (!publishResult) {
          process.exit(1);
        }
        publishedToGitHub = true;
        packageMetadata.githubRepo = `${credentials.username}/${finalPluginName}`;
        if (typeof publishResult === "object" && publishResult.prUrl && !opts.skipRegistry) {
          registryPrUrl = publishResult.prUrl;
          console.log(`[\u221A] Registry pull request created: ${registryPrUrl}`);
        }
      } catch (error) {
        console.error("GitHub publishing failed:", error);
        process.exit(1);
      }
    }
    displayRegistryPublicationMessage(opts, userIsMaintainer, registryPrUrl || void 0);
    console.log(`Successfully published plugin ${packageJson.name}@${packageJson.version}`);
    console.log("\nYour plugin is now available at:");
    console.log(`NPM: https://www.npmjs.com/package/${packageJson.name}`);
    if (publishedToGitHub && credentials) {
      console.log(`GitHub: https://github.com/${credentials.username}/${finalPluginName}`);
    }
    console.log("\n[\u{1F4DD}] Important: For future updates to your plugin:");
    console.log("   Use standard npm and git workflows, not the ElizaOS CLI:");
    console.log("   1. Make your changes and test locally");
    console.log("   2. Update version: npm version patch|minor|major");
    console.log("   3. Publish to npm: npm publish");
    if (publishedToGitHub) {
      console.log("   4. Push to GitHub: git push origin main && git push --tags");
    }
    console.log("\n   The ElizaOS registry will automatically sync with npm updates.");
    console.log('   Only use "elizaos publish" for initial publishing of new plugins.');
  } catch (error) {
    handleError(error);
  }
});

// src/commands/monorepo/index.ts
import { Command as Command6 } from "commander";

// src/commands/monorepo/actions/clone.ts
import { execa as execa8 } from "execa";
import { existsSync as existsSync10, readdirSync as readdirSync2, mkdirSync } from "fs";
import path18 from "path";
async function cloneRepository(repo, branch, destination) {
  try {
    const repoUrl = `https://github.com/${repo}`;
    await execa8("git", ["clone", "-b", branch, repoUrl, destination], {
      stdio: "inherit"
    });
  } catch (error) {
    if (error instanceof Error && error.message.includes("exit code 128")) {
      console.error(`
[X] Branch '${branch}' doesn't exist in the ElizaOS repository.`);
      console.error(`Please specify a valid branch name. Common branches include:`);
      console.error(`  \u2022 main - The main branch`);
      console.error(`  \u2022 develop - The development branch (default)`);
      console.error(
        `
For a complete list of branches, visit: https://github.com/elizaOS/eliza/branches`
      );
      throw new Error(`Branch '${branch}' not found`);
    }
    throw new Error(
      `Failed to clone repository: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
function prepareDestination(dir) {
  const destinationDir = path18.resolve(process.cwd(), dir);
  if (existsSync10(destinationDir)) {
    const files = readdirSync2(destinationDir);
    if (files.length > 0) {
      throw new Error(`Destination directory ${destinationDir} already exists and is not empty`);
    }
  } else {
    mkdirSync(destinationDir, { recursive: true });
  }
  return destinationDir;
}
async function cloneMonorepo(cloneInfo) {
  const { repo, branch, destination } = cloneInfo;
  const destinationDir = prepareDestination(destination);
  await cloneRepository(repo, branch, destinationDir);
  return;
}

// src/commands/monorepo/utils/setup-instructions.ts
import path19 from "path";
function getBunInstallInstructions() {
  const platform = process.platform;
  if (platform === "win32") {
    return {
      platform: "Windows",
      commands: ['powershell -c "irm bun.sh/install.ps1 | iex"'],
      alternatives: ["scoop install bun (if you have Scoop)"]
    };
  } else {
    const commands = ["curl -fsSL https://bun.sh/install | bash"];
    const alternatives = [];
    if (platform === "darwin") {
      alternatives.push("brew install bun (if you have Homebrew)");
    }
    return {
      platform: platform === "darwin" ? "macOS" : "Linux",
      commands,
      alternatives: alternatives.length > 0 ? alternatives : void 0
    };
  }
}
function displayBasicSteps(cdPath) {
  console.log("\nTo complete the ElizaOS setup, follow these steps:\n");
  console.log("1. Navigate to the project directory:");
  console.log(`   cd ${cdPath}`);
  console.log("\n2. Install dependencies:");
  console.log("   bun install");
  console.log("\n3. Build the project:");
  console.log("   bun run build");
  console.log("\n4. Start ElizaOS:");
  console.log("   bun run start or bun run dev");
}
function displayPrerequisites() {
  console.log(`
${emoji.list("Prerequisites:")}`);
  console.log(`   ${emoji.bullet("Node.js 23.3.0+")}`);
  console.log(`   ${emoji.bullet("Bun (JavaScript runtime & package manager)")}`);
}
function displayBunInstructions() {
  console.log(`
${emoji.rocket("If you don't have Bun installed:")}`);
  const instructions = getBunInstallInstructions();
  instructions.commands.forEach((command) => {
    console.log(`   ${command}`);
  });
  if (instructions.alternatives) {
    instructions.alternatives.forEach((alt) => {
      console.log(`   Alternative: ${alt}`);
    });
  }
  console.log("   More options: https://bun.sh/docs/installation");
  console.log("   After installation, restart your terminal");
}
function displayNextSteps(targetDir) {
  const cdPath = path19.relative(process.cwd(), targetDir);
  displayBasicSteps(cdPath);
  displayPrerequisites();
  displayBunInstructions();
}

// src/commands/monorepo/index.ts
var monorepo = new Command6().name("monorepo").description("Clone ElizaOS monorepo from a specific branch, defaults to develop").option("-b, --branch <branch>", "Branch to install", "develop").option("-d, --dir <directory>", "Destination directory", "./eliza").action(async (options) => {
  try {
    const repo = "elizaOS/eliza";
    const branch = options.branch || "develop";
    const dir = options.dir || "./eliza";
    const destinationDir = prepareDestination(dir);
    const cloneInfo = {
      repo,
      branch,
      destination: dir
    };
    await cloneMonorepo(cloneInfo);
    displayNextSteps(destinationDir);
  } catch (error) {
    handleError(error);
  }
});

// src/commands/start/index.ts
import { loadCharacterTryPath as loadCharacterTryPath2 } from "@elizaos/server";

// src/project.ts
import {
  logger as logger12
} from "@elizaos/core";
import { stringToUuid } from "@elizaos/core";
import * as fs9 from "fs";
import path20 from "path";
function isPlugin(module) {
  if (module && typeof module === "object" && typeof module.name === "string" && typeof module.description === "string") {
    return true;
  }
  if (module && typeof module === "object" && module.default && typeof module.default === "object" && typeof module.default.name === "string" && typeof module.default.description === "string") {
    return true;
  }
  for (const key in module) {
    if (key !== "default" && module[key] && typeof module[key] === "object" && typeof module[key].name === "string" && typeof module[key].description === "string") {
      return true;
    }
  }
  return false;
}
function extractPlugin(module) {
  if (module && typeof module === "object" && typeof module.name === "string" && typeof module.description === "string") {
    return module;
  }
  if (module && typeof module === "object" && module.default && typeof module.default === "object" && typeof module.default.name === "string" && typeof module.default.description === "string") {
    return module.default;
  }
  for (const key in module) {
    if (key !== "default" && module[key] && typeof module[key] === "object" && typeof module[key].name === "string" && typeof module[key].description === "string") {
      return module[key];
    }
  }
  throw new Error("Could not extract plugin from module");
}
async function loadProject(dir) {
  try {
    const dirInfo = detectDirectoryType(dir);
    if (!dirInfo.hasPackageJson) {
      throw new Error(`No package.json found in ${dir}`);
    }
    const packageJson = JSON.parse(fs9.readFileSync(path20.join(dir, "package.json"), "utf8"));
    const main2 = packageJson.main;
    if (!main2) {
      logger12.warn("No main field found in package.json, using default character");
      const defaultCharacterName = "Eliza (Default)";
      const elizaCharacter = getElizaCharacter();
      const defaultAgent = {
        character: {
          ...elizaCharacter,
          id: stringToUuid(defaultCharacterName),
          name: defaultCharacterName
        },
        init: async () => {
          logger12.info("Initializing default Eliza character");
        }
      };
      return {
        agents: [defaultAgent],
        dir
      };
    }
    const entryPoints = [
      path20.join(dir, main2),
      path20.join(dir, "dist/index.js"),
      path20.join(dir, "src/index.ts"),
      path20.join(dir, "src/index.js"),
      path20.join(dir, "index.ts"),
      path20.join(dir, "index.js")
    ];
    let projectModule = null;
    for (const entryPoint of entryPoints) {
      if (fs9.existsSync(entryPoint)) {
        try {
          const importPath = path20.resolve(entryPoint);
          const importUrl = process.platform === "win32" ? "file:///" + importPath.replace(/\\/g, "/") : "file://" + importPath;
          projectModule = await import(importUrl);
          logger12.info(`Loaded project from ${entryPoint}`);
          const exportKeys = Object.keys(projectModule);
          logger12.debug(`Module exports: ${exportKeys.join(", ")}`);
          if (exportKeys.includes("default")) {
            logger12.debug(`Default export type: ${typeof projectModule.default}`);
            if (typeof projectModule.default === "object" && projectModule.default !== null) {
              logger12.debug(`Default export keys: ${Object.keys(projectModule.default).join(", ")}`);
            }
          }
          break;
        } catch (error) {
          logger12.warn(`Failed to import project from ${entryPoint}:`, error);
        }
      }
    }
    if (!projectModule) {
      throw new Error("Could not find project entry point");
    }
    const moduleIsPlugin = isPlugin(projectModule);
    logger12.debug(`Is this a plugin? ${moduleIsPlugin}`);
    if (moduleIsPlugin) {
      logger12.info("Detected plugin module instead of project");
      try {
        const plugin = extractPlugin(projectModule);
        logger12.debug(`Found plugin: ${plugin.name} - ${plugin.description}`);
        logger12.debug(`Plugin has the following properties: ${Object.keys(plugin).join(", ")}`);
        const completePlugin = {
          // Copy all other properties from the original plugin first
          ...plugin,
          // Then override with defaults if needed
          name: plugin.name || "unknown-plugin",
          description: plugin.description || "No description",
          init: plugin.init || (async () => {
            logger12.info(`Dummy init for plugin: ${plugin.name}`);
          })
        };
        const characterName = "Eliza (Test Mode)";
        const elizaCharacter = getElizaCharacter();
        const testCharacter = {
          ...elizaCharacter,
          id: stringToUuid(characterName),
          name: characterName,
          system: `${elizaCharacter.system} Testing the plugin: ${completePlugin.name}.`
        };
        logger12.info(`Using Eliza character as test agent for plugin: ${completePlugin.name}`);
        const testAgent = {
          character: testCharacter,
          plugins: [completePlugin],
          // Only include the plugin being tested
          init: async () => {
            logger12.info(`Initializing Eliza test agent for plugin: ${completePlugin.name}`);
          }
        };
        return {
          agents: [testAgent],
          dir,
          isPlugin: true,
          pluginModule: completePlugin
        };
      } catch (error) {
        logger12.error("Error extracting plugin from module:", error);
        throw error;
      }
    }
    const agents = [];
    if (projectModule.default && typeof projectModule.default === "object" && Array.isArray(projectModule.default.agents)) {
      agents.push(...projectModule.default.agents);
      logger12.debug(`Found ${agents.length} agents in default export's agents array`);
    } else {
      for (const [key, value] of Object.entries(projectModule)) {
        if (key === "default" && value && typeof value === "object") {
          if (value.character && value.init) {
            agents.push(value);
            logger12.debug(`Found agent in default export (single agent)`);
          }
        } else if (value && typeof value === "object" && value.character && value.init) {
          agents.push(value);
          logger12.debug(`Found agent in named export: ${key}`);
        }
      }
    }
    if (agents.length === 0) {
      throw new Error("No agents found in project");
    }
    const project = {
      agents,
      dir
    };
    return project;
  } catch (error) {
    logger12.error("Error loading project:", error);
    throw error;
  }
}

// src/commands/start/index.ts
import { logger as logger17 } from "@elizaos/core";
import { Command as Command7 } from "commander";

// src/commands/start/actions/server-start.ts
import { AgentServer, jsonToCharacter, loadCharacterTryPath } from "@elizaos/server";
import { logger as logger16 } from "@elizaos/core";

// src/commands/start/actions/agent-start.ts
import {
  AgentRuntime as AgentRuntime2,
  encryptedCharacter,
  logger as logger15,
  stringToUuid as stringToUuid2
} from "@elizaos/core";
import { plugin as sqlPlugin } from "@elizaos/plugin-sql";

// src/commands/start/utils/config-utils.ts
import dotenv2 from "dotenv";
async function loadEnvConfig() {
  const envInfo = await UserEnvironment.getInstanceInfo();
  if (envInfo.paths.envFilePath) {
    dotenv2.config({ path: envInfo.paths.envFilePath });
  }
  return process.env;
}

// src/commands/start/utils/dependency-resolver.ts
import { logger as logger13 } from "@elizaos/core";
function resolvePluginDependencies(availablePlugins, isTestMode = false) {
  const resolutionOrder = [];
  const visited = /* @__PURE__ */ new Set();
  const visiting = /* @__PURE__ */ new Set();
  function visit(pluginName) {
    if (!availablePlugins.has(pluginName)) {
      logger13.warn(`Plugin dependency "${pluginName}" not found and will be skipped.`);
      return;
    }
    if (visited.has(pluginName)) return;
    if (visiting.has(pluginName)) {
      logger13.error(`Circular dependency detected involving plugin: ${pluginName}`);
      return;
    }
    visiting.add(pluginName);
    const plugin = availablePlugins.get(pluginName);
    if (plugin) {
      const deps = [...plugin.dependencies || []];
      if (isTestMode) {
        deps.push(...plugin.testDependencies || []);
      }
      for (const dep of deps) {
        visit(dep);
      }
    }
    visiting.delete(pluginName);
    visited.add(pluginName);
    resolutionOrder.push(pluginName);
  }
  for (const name of availablePlugins.keys()) {
    if (!visited.has(name)) {
      visit(name);
    }
  }
  const finalPlugins = resolutionOrder.map((name) => availablePlugins.get(name)).filter((p) => p);
  logger13.info(`Final plugins being loaded: ${finalPlugins.map((p) => p.name).join(", ")}`);
  return finalPlugins;
}

// src/commands/start/utils/plugin-utils.ts
import { logger as logger14 } from "@elizaos/core";
function isValidPluginShape(obj) {
  if (!obj || typeof obj !== "object" || !obj.name) {
    return false;
  }
  return !!(obj.init || obj.services || obj.providers || obj.actions || obj.evaluators || obj.description);
}
async function loadAndPreparePlugin(pluginName) {
  const version = getCliInstallTag();
  let pluginModule;
  const context = detectPluginContext(pluginName);
  if (context.isLocalDevelopment) {
    try {
      pluginModule = await loadPluginModule(pluginName);
      if (!pluginModule) {
        logger14.error(`Failed to load local plugin ${pluginName}.`);
        provideLocalPluginGuidance(pluginName, context);
        return null;
      }
    } catch (error) {
      logger14.error(`Error loading local plugin ${pluginName}: ${error}`);
      provideLocalPluginGuidance(pluginName, context);
      return null;
    }
  } else {
    try {
      pluginModule = await loadPluginModule(pluginName);
      if (!pluginModule) {
        logger14.info(`Plugin ${pluginName} not available, installing...`);
        await installPlugin(pluginName, process.cwd(), version);
        pluginModule = await loadPluginModule(pluginName);
      }
    } catch (error) {
      logger14.error(`Failed to process plugin ${pluginName}: ${error}`);
      return null;
    }
  }
  if (!pluginModule) {
    logger14.error(`Failed to load module for plugin ${pluginName}.`);
    return null;
  }
  const expectedFunctionName = `${pluginName.replace(/^@elizaos\/plugin-/, "").replace(/^@elizaos\//, "").replace(/-./g, (match) => match[1].toUpperCase())}Plugin`;
  const exportsToCheck = [
    pluginModule[expectedFunctionName],
    pluginModule.default,
    ...Object.values(pluginModule)
  ];
  for (const potentialPlugin of exportsToCheck) {
    if (isValidPluginShape(potentialPlugin)) {
      return potentialPlugin;
    }
  }
  logger14.warn(`Could not find a valid plugin export in ${pluginName}.`);
  return null;
}

// src/commands/start/actions/agent-start.ts
async function startAgent(character, server, init, plugins2 = [], options = {}) {
  character.id ??= stringToUuid2(character.name);
  const loadedPlugins = /* @__PURE__ */ new Map();
  loadedPlugins.set(sqlPlugin.name, sqlPlugin);
  const pluginsToLoad = new Set(character.plugins || []);
  for (const p of plugins2) {
    if (typeof p === "string") {
      pluginsToLoad.add(p);
    } else if (isValidPluginShape(p) && !loadedPlugins.has(p.name)) {
      loadedPlugins.set(p.name, p);
      (p.dependencies || []).forEach((dep) => pluginsToLoad.add(dep));
      if (options.isTestMode) {
        (p.testDependencies || []).forEach((dep) => pluginsToLoad.add(dep));
      }
    }
  }
  const allAvailablePlugins = /* @__PURE__ */ new Map();
  for (const p of loadedPlugins.values()) {
    allAvailablePlugins.set(p.name, p);
  }
  for (const name of pluginsToLoad) {
    if (!allAvailablePlugins.has(name)) {
      const loaded = await loadAndPreparePlugin(name);
      if (loaded) {
        allAvailablePlugins.set(loaded.name, loaded);
      }
    }
  }
  const finalPlugins = resolvePluginDependencies(allAvailablePlugins, options.isTestMode);
  const runtime = new AgentRuntime2({
    character: encryptedCharacter(character),
    plugins: finalPlugins,
    settings: await loadEnvConfig()
  });
  const initWrapper = async (runtime2) => {
    if (init) {
      await init(runtime2);
    }
  };
  await initWrapper(runtime);
  await runtime.initialize();
  try {
    const migrationService = runtime.getService("database_migration");
    if (migrationService) {
      logger15.info("Discovering plugin schemas for dynamic migration...");
      migrationService.discoverAndRegisterPluginSchemas(finalPlugins);
      logger15.info("Running all plugin migrations...");
      await migrationService.runAllPluginMigrations();
      logger15.info("All plugin migrations completed successfully");
    } else {
      logger15.warn("DatabaseMigrationService not found - plugin schema migrations skipped");
    }
  } catch (error) {
    logger15.error("Failed to run plugin migrations:", error);
    throw error;
  }
  server.registerAgent(runtime);
  logger15.log(`Started ${runtime.character.name} as ${runtime.agentId}`);
  return runtime;
}
async function stopAgent(runtime, server) {
  await runtime.close();
  server.unregisterAgent(runtime.agentId);
  logger15.success(`Agent ${runtime.character.name} stopped successfully!`);
}

// src/commands/start/actions/server-start.ts
async function startAgents(options) {
  const postgresUrl = await configureDatabaseSettings(options.configure);
  if (postgresUrl) process.env.POSTGRES_URL = postgresUrl;
  const pgliteDataDir = postgresUrl ? void 0 : await resolvePgliteDir();
  const server = new AgentServer();
  await server.initialize({ dataDir: pgliteDataDir, postgresUrl: postgresUrl || void 0 });
  server.startAgent = (character) => startAgent(character, server);
  server.stopAgent = (runtime) => stopAgent(runtime, server);
  server.loadCharacterTryPath = loadCharacterTryPath;
  server.jsonToCharacter = jsonToCharacter;
  const desiredPort = options.port || Number.parseInt(process.env.SERVER_PORT || "3000");
  const serverPort = await findNextAvailablePort(desiredPort);
  if (serverPort !== desiredPort) {
    logger16.warn(`Port ${desiredPort} is in use, using port ${serverPort} instead`);
  }
  process.env.SERVER_PORT = serverPort.toString();
  server.start(serverPort);
  if (options.projectAgents && options.projectAgents.length > 0) {
    for (const projectAgent of options.projectAgents) {
      await startAgent(
        projectAgent.character,
        server,
        projectAgent.init,
        projectAgent.plugins || []
      );
    }
  } else if (options.characters && options.characters.length > 0) {
    for (const character of options.characters) {
      await startAgent(character, server);
    }
  } else {
    const elizaCharacter = getElizaCharacter();
    await startAgent(elizaCharacter, server);
  }
}

// src/commands/start/index.ts
import * as fs10 from "fs";
import * as path21 from "path";
var start = new Command7().name("start").description("Start the Eliza agent server").option("-c, --configure", "Reconfigure services and AI models").option("-p, --port <port>", "Port to listen on", validatePort).option("--character <paths...>", "Character file(s) to use").hook("preAction", async () => {
  await displayBanner();
}).action(async (options) => {
  try {
    await loadEnvConfig();
    let characters = [];
    let projectAgents = [];
    if (options.character && options.character.length > 0) {
      for (const charPath of options.character) {
        const resolvedPath = path21.resolve(charPath);
        if (!fs10.existsSync(resolvedPath)) {
          logger17.error(`Character file not found: ${resolvedPath}`);
          throw new Error(`Character file not found: ${resolvedPath}`);
        }
        try {
          const character = await loadCharacterTryPath2(resolvedPath);
          if (character) {
            characters.push(character);
            logger17.info(`Successfully loaded character: ${character.name}`);
          } else {
            logger17.error(
              `Failed to load character from ${resolvedPath}: Invalid or empty character file`
            );
            throw new Error(`Invalid character file: ${resolvedPath}`);
          }
        } catch (e) {
          logger17.error(`Failed to load character from ${resolvedPath}:`, e);
          throw new Error(`Invalid character file: ${resolvedPath}`);
        }
      }
    } else {
      try {
        const cwd = process.cwd();
        const dirInfo = detectDirectoryType(cwd);
        if (dirInfo.hasPackageJson && dirInfo.type !== "non-elizaos-dir") {
          logger17.info("No character files specified, attempting to load project agents...");
          const project = await loadProject(cwd);
          if (project.agents && project.agents.length > 0) {
            logger17.info(`Found ${project.agents.length} agent(s) in project configuration`);
            projectAgents = project.agents;
            for (const agent2 of project.agents) {
              if (agent2.character) {
                logger17.info(`Loaded character: ${agent2.character.name}`);
              }
            }
          }
        }
      } catch (e) {
        logger17.debug("Failed to load project agents, will use default character:", e);
      }
    }
    await startAgents({ ...options, characters, projectAgents });
  } catch (e) {
    handleError(e);
    process.exit(1);
  }
});

// src/commands/tee/index.ts
import { Command as Command9 } from "commander";

// src/commands/tee/phala-wrapper.ts
import { Command as Command8 } from "commander";
import { spawn as spawn2 } from "child_process";
import { elizaLogger } from "@elizaos/core";
var phalaCliCommand = new Command8("phala").description("Official Phala Cloud CLI - Manage TEE deployments on Phala Cloud").allowUnknownOption().helpOption(false).action(async (_, command) => {
  const args = command.args;
  try {
    elizaLogger.info("Running Phala CLI command:", ["phala", ...args].join(" "));
    const phalaProcess = spawn2("npx", ["--yes", "phala", ...args], {
      stdio: "inherit",
      shell: true
    });
    phalaProcess.on("error", (error) => {
      elizaLogger.error("Failed to execute Phala CLI:", error);
      if (error.message.includes("ENOENT")) {
        elizaLogger.error(
          `
${emoji.error("Error: npx not found. Please install Node.js and npm:")}`
        );
        elizaLogger.error("   Visit https://nodejs.org or use a version manager like nvm");
        elizaLogger.error(
          "   curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash"
        );
      } else {
        elizaLogger.error(`
${emoji.error("Error: Failed to execute Phala CLI")}`);
        elizaLogger.error("   Try running directly: npx phala", args.join(" "));
      }
      process.exit(1);
    });
    phalaProcess.on("exit", (code) => {
      if (code !== 0) {
        elizaLogger.warn(`Phala CLI exited with code: ${code}`);
      }
      process.exit(code || 0);
    });
  } catch (error) {
    elizaLogger.error("Error running Phala CLI:", error);
    elizaLogger.error(`
${emoji.error("Error: Failed to run Phala CLI")}`);
    elizaLogger.error("   Try running Phala CLI directly with: npx phala", args.join(" "));
    elizaLogger.error("   Or visit https://www.npmjs.com/package/phala for more information");
    process.exit(1);
  }
}).configureHelp({
  helpWidth: 100
}).on("--help", () => {
  console.log("");
  console.log("This command wraps the official Phala Cloud CLI.");
  console.log("The Phala CLI will be automatically downloaded if not already installed.");
  console.log("All arguments are passed directly to the Phala CLI.");
  console.log("");
  console.log("Examples:");
  console.log("  $ elizaos tee phala help");
  console.log("  $ elizaos tee phala auth login <api-key>");
  console.log("  $ elizaos tee phala cvms list");
  console.log("  $ elizaos tee phala cvms create --name my-app --compose ./docker-compose.yml");
  console.log("");
  console.log("For full Phala CLI documentation, run:");
  console.log("  $ npx phala help");
});

// src/commands/tee/index.ts
var teeCommand = new Command9("tee").description("Manage TEE deployments").addCommand(phalaCliCommand);

// src/commands/test/index.ts
import { logger as logger24 } from "@elizaos/core";
import { Command as Command10, Option as Option2 } from "commander";

// src/commands/test/actions/run-all-tests.ts
import { logger as logger22 } from "@elizaos/core";

// src/commands/test/utils/project-utils.ts
import { logger as logger18 } from "@elizaos/core";
import * as fs11 from "fs";
import path22 from "path";
function getProjectType(testPath) {
  const targetPath = testPath ? path22.resolve(process.cwd(), testPath) : process.cwd();
  return detectDirectoryType(targetPath);
}
function processFilterName(name) {
  if (!name) return void 0;
  let baseName = name.toLowerCase();
  if (baseName.endsWith(".test.ts") || baseName.endsWith(".test.js") || baseName.endsWith(".spec.ts") || baseName.endsWith(".spec.js")) {
    baseName = baseName.slice(0, -8);
  } else if (baseName.endsWith(".test") || baseName.endsWith(".spec")) {
    baseName = baseName.slice(0, -5);
  }
  return baseName;
}
async function installPluginDependencies(projectInfo) {
  if (projectInfo.type !== "elizaos-plugin") {
    return;
  }
  const project = await loadProject(process.cwd());
  if (project.isPlugin && project.pluginModule?.dependencies && project.pluginModule.dependencies.length > 0) {
    const pluginsDir = path22.join(process.cwd(), ".eliza", "plugins");
    if (!fs11.existsSync(pluginsDir)) {
      await fs11.promises.mkdir(pluginsDir, { recursive: true });
    }
    const packageJsonPath = path22.join(pluginsDir, "package.json");
    if (!fs11.existsSync(packageJsonPath)) {
      const packageJsonContent = {
        name: "test-plugin-dependencies",
        version: "1.0.0",
        description: "A temporary package for installing test plugin dependencies",
        dependencies: {}
      };
      await fs11.promises.writeFile(packageJsonPath, JSON.stringify(packageJsonContent, null, 2));
    }
    const { installPlugin: installPlugin2 } = await import("./utils-QKNGJZLP.js");
    for (const dependency of project.pluginModule.dependencies) {
      await installPlugin2(dependency, pluginsDir);
      const dependencyPath = path22.join(pluginsDir, "node_modules", dependency);
      if (fs11.existsSync(dependencyPath)) {
        try {
          await runBunCommand(["install"], dependencyPath);
        } catch (error) {
          logger18.warn(
            `[Test Command] Failed to install devDependencies for ${dependency}: ${error}`
          );
        }
      }
    }
  }
}

// src/commands/test/actions/component-tests.ts
import { logger as logger20 } from "@elizaos/core";
import { spawn as spawn3 } from "child_process";
import path24 from "path";

// src/utils/testing/tsc-validator.ts
import { logger as logger19 } from "@elizaos/core";
import { execa as execa9 } from "execa";
import path23 from "path";
import { existsSync as existsSync14 } from "fs";
async function runTypeCheck(projectPath, strict = true) {
  const tsconfigPath = path23.join(projectPath, "tsconfig.json");
  if (!existsSync14(tsconfigPath)) {
    return {
      success: false,
      errors: [`No tsconfig.json found at ${tsconfigPath}`],
      warnings: []
    };
  }
  try {
    const args = ["--noEmit"];
    if (strict) {
      args.push("--strict");
    }
    const { stdout, stderr } = await execa9("tsc", args, {
      cwd: projectPath,
      reject: false
    });
    const hasErrors = stderr.includes("error TS") || stdout.includes("error TS");
    return {
      success: !hasErrors,
      errors: hasErrors ? [stderr || stdout] : [],
      warnings: stderr.includes("warning") ? [stderr] : []
    };
  } catch (error) {
    logger19.error("TypeScript validation failed:", error);
    return {
      success: false,
      errors: [`TypeScript validation error: ${error.message}`],
      warnings: []
    };
  }
}

// src/commands/test/actions/component-tests.ts
async function runComponentTests(testPath, options, projectInfo) {
  const cwd = process.cwd();
  const isPlugin2 = projectInfo.type === "elizaos-plugin";
  if (!options.skipTypeCheck) {
    logger20.info("Running TypeScript validation...");
    const typeCheckResult = await runTypeCheck(cwd, true);
    if (!typeCheckResult.success) {
      logger20.error("TypeScript validation failed:");
      typeCheckResult.errors.forEach((error) => logger20.error(error));
      return { failed: true };
    }
    logger20.success("TypeScript validation passed");
  }
  if (!options.skipBuild) {
    try {
      logger20.info(`Building ${isPlugin2 ? "plugin" : "project"}...`);
      await buildProject(cwd, isPlugin2);
      logger20.success(`Build completed successfully`);
    } catch (buildError) {
      logger20.error(`Build failed: ${buildError}`);
      return { failed: true };
    }
  }
  logger20.info("Running component tests...");
  return new Promise((resolve2) => {
    const args = ["test", "--passWithNoTests"];
    if (options.name) {
      const baseName = processFilterName(options.name);
      if (baseName) {
        logger20.info(`Using test filter: ${baseName}`);
        args.push("-t", baseName);
      }
    }
    const targetPath = testPath ? path24.resolve(process.cwd(), "..", testPath) : process.cwd();
    logger20.info(`Executing: bun ${args.join(" ")} in ${targetPath}`);
    const child = spawn3("bun", args, {
      stdio: "inherit",
      shell: false,
      cwd: targetPath,
      env: {
        ...process.env,
        FORCE_COLOR: "1",
        // Force color output
        CI: "false"
        // Ensure we're not in CI mode which might buffer
      }
    });
    child.on("close", (code) => {
      logger20.info("Component tests completed");
      resolve2({ failed: code !== 0 });
    });
    child.on("error", (error) => {
      logger20.error("Error running component tests:", error);
      resolve2({ failed: true });
    });
  });
}

// src/commands/test/actions/e2e-tests.ts
import { AgentServer as AgentServer2, jsonToCharacter as jsonToCharacter2, loadCharacterTryPath as loadCharacterTryPath3 } from "@elizaos/server";
import { logger as logger21 } from "@elizaos/core";
import * as dotenv3 from "dotenv";
import * as fs12 from "fs";
import path25 from "path";
async function runE2eTests(testPath, options, projectInfo) {
  if (!options.skipBuild) {
    try {
      const cwd = process.cwd();
      const isPlugin2 = projectInfo.type === "elizaos-plugin";
      logger21.info(`Building ${isPlugin2 ? "plugin" : "project"}...`);
      await buildProject(cwd, isPlugin2);
      logger21.info(`Build completed successfully`);
    } catch (buildError) {
      logger21.error(`Build error: ${buildError}`);
      logger21.warn(`Attempting to continue with tests despite build error`);
    }
  }
  let server;
  try {
    const runtimes = [];
    const projectAgents = [];
    const elizaDir = path25.join(process.cwd(), ".eliza");
    const packageName = path25.basename(process.cwd());
    const timestamp = Date.now();
    const uniqueDbDir = path25.join(process.cwd(), ".elizadb-test", `${packageName}-${timestamp}`);
    const elizaDbDir = uniqueDbDir;
    const envInfo = await UserEnvironment.getInstanceInfo();
    const envFilePath = envInfo.paths.envFilePath;
    console.info("Setting up environment...");
    console.info(`Eliza directory: ${elizaDir}`);
    console.info(`Database directory: ${elizaDbDir}`);
    console.info(`Environment file: ${envFilePath}`);
    console.info(`Package name: ${packageName}, Timestamp: ${timestamp}`);
    if (fs12.existsSync(elizaDbDir)) {
      console.info(`Cleaning up existing database directory: ${elizaDbDir}`);
      try {
        fs12.rmSync(elizaDbDir, { recursive: true, force: true });
        console.info(`Successfully cleaned up existing database directory`);
      } catch (error) {
        console.warn(`Failed to clean up existing database directory: ${error}`);
      }
    }
    console.info(`Creating fresh database directory: ${elizaDbDir}`);
    fs12.mkdirSync(elizaDbDir, { recursive: true });
    console.info(`Created database directory: ${elizaDbDir}`);
    process.env.PGLITE_DATA_DIR = elizaDbDir;
    console.info(`Set PGLITE_DATA_DIR to: ${elizaDbDir}`);
    if (fs12.existsSync(envFilePath)) {
      logger21.info(`Loading environment variables from: ${envFilePath}`);
      dotenv3.config({ path: envFilePath });
      logger21.info("Environment variables loaded");
    } else {
      logger21.warn(`Environment file not found: ${envFilePath}`);
    }
    try {
      logger21.info("Configuring database...");
      await promptForEnvVars("pglite");
      logger21.info("Database configuration completed");
    } catch (error) {
      logger21.error("Error configuring database:", error);
      if (error instanceof Error) {
        logger21.error("Error details:", error.message);
        logger21.error("Stack trace:", error.stack);
      }
      throw error;
    }
    const postgresUrl = process.env.POSTGRES_URL;
    logger21.info(
      `PostgreSQL URL for e2e tests: ${postgresUrl ? "found" : "not found (will use PGlite)"}`
    );
    logger21.info("Creating server instance...");
    server = new AgentServer2();
    logger21.info("Server instance created");
    logger21.info("Initializing server...");
    try {
      await server.initialize({
        dataDir: elizaDbDir,
        postgresUrl
      });
      logger21.info("Server initialized successfully");
    } catch (initError) {
      logger21.error("Server initialization failed:", initError);
      throw initError;
    }
    let project;
    try {
      logger21.info("Attempting to load project or plugin...");
      const monorepoRoot = UserEnvironment.getInstance().findMonorepoRoot(process.cwd());
      if (!monorepoRoot) {
        throw new Error(
          "Could not find monorepo root. Make sure to run tests from within the Eliza project."
        );
      }
      const targetPath = testPath ? path25.resolve(monorepoRoot, testPath) : process.cwd();
      project = await loadProject(targetPath);
      if (!project || !project.agents || project.agents.length === 0) {
        throw new Error("No agents found in project configuration");
      }
      logger21.info(
        `Found ${project.agents.length} agents in ${project.isPlugin ? "plugin" : "project"} configuration`
      );
      logger21.info("Setting up server properties...");
      server.startAgent = async (character) => {
        logger21.info(`Starting agent for character ${character.name}`);
        return startAgent(character, server, void 0, [], { isTestMode: true });
      };
      server.loadCharacterTryPath = loadCharacterTryPath3;
      server.jsonToCharacter = jsonToCharacter2;
      logger21.info("Server properties set up");
      const desiredPort = options.port || Number.parseInt(process.env.SERVER_PORT || "3000");
      const serverPort = await findNextAvailablePort(desiredPort);
      if (serverPort !== desiredPort) {
        logger21.warn(`Port ${desiredPort} is in use for testing, using port ${serverPort} instead.`);
      }
      logger21.info("Starting server...");
      try {
        await server.start(serverPort);
        logger21.info("Server started successfully on port", serverPort);
      } catch (error) {
        logger21.error("Error starting server:", error);
        if (error instanceof Error) {
          logger21.error("Error details:", error.message);
          logger21.error("Stack trace:", error.stack);
        }
        throw error;
      }
      try {
        logger21.info(
          `Found ${project.agents.length} agents in ${project.isPlugin ? "plugin" : "project"}`
        );
        if (project.isPlugin || project.agents.length === 0) {
          process.env.ELIZA_TESTING_PLUGIN = "true";
          logger21.info("Using default Eliza character as test agent");
          try {
            const pluginUnderTest = project.pluginModule;
            if (!pluginUnderTest) {
              throw new Error("Plugin module could not be loaded for testing.");
            }
            const defaultElizaCharacter = getElizaCharacter();
            const runtime = await startAgent(
              defaultElizaCharacter,
              server,
              void 0,
              // No custom init for default test setup
              [pluginUnderTest],
              // Pass the local plugin module directly
              { isTestMode: true }
            );
            server.registerAgent(runtime);
            runtimes.push(runtime);
            projectAgents.push({
              character: defaultElizaCharacter,
              plugins: runtime.plugins
              // Pass all plugins, not just the one under test
            });
            logger21.info("Default test agent started successfully");
          } catch (pluginError) {
            logger21.error(`Error starting plugin test agent: ${pluginError}`);
            throw pluginError;
          }
        } else {
          for (const agent2 of project.agents) {
            try {
              const originalCharacter = { ...agent2.character };
              logger21.debug(`Starting agent: ${originalCharacter.name}`);
              const runtime = await startAgent(
                originalCharacter,
                server,
                agent2.init,
                agent2.plugins || [],
                { isTestMode: true }
                // Pass isTestMode for project tests as well
              );
              runtimes.push(runtime);
              projectAgents.push(agent2);
              await new Promise((resolve2) => setTimeout(resolve2, 1e3));
            } catch (agentError) {
              logger21.error(`Error starting agent ${agent2.character.name}:`, agentError);
              if (agentError instanceof Error) {
                logger21.error("Error details:", agentError.message);
                logger21.error("Stack trace:", agentError.stack);
              }
              logger21.warn(`Skipping agent ${agent2.character.name} due to startup error`);
            }
          }
        }
        if (runtimes.length === 0) {
          throw new Error("Failed to start any agents from project");
        }
        logger21.debug(`Successfully started ${runtimes.length} agents for testing`);
        let totalFailed = 0;
        let anyTestsFound = false;
        for (let i = 0; i < runtimes.length; i++) {
          const runtime = runtimes[i];
          const projectAgent = projectAgents[i];
          if (project.isPlugin) {
            logger21.debug(`Running tests for plugin: ${project.pluginModule?.name}`);
          } else {
            logger21.debug(`Running tests for agent: ${runtime.character.name}`);
          }
          const testRunner = new TestRunner(runtime, projectAgent);
          const currentDirInfo = projectInfo;
          const processedFilter = processFilterName(options.name);
          const results = await testRunner.runTests({
            filter: processedFilter,
            // Only run plugin tests if we're actually in a plugin directory
            skipPlugins: currentDirInfo.type !== "elizaos-plugin",
            // Only run project tests if we're actually in a project directory
            skipProjectTests: currentDirInfo.type !== "elizaos-project",
            skipE2eTests: false
            // Always allow E2E tests
          });
          totalFailed += results.failed;
          if (results.hasTests) {
            anyTestsFound = true;
          }
        }
        return { failed: anyTestsFound ? totalFailed > 0 : false };
      } catch (error) {
        logger21.error("Error in runE2eTests:", error);
        if (error instanceof Error) {
          logger21.error("Error details:", error.message);
          logger21.error("Stack trace:", error.stack);
        } else {
          logger21.error("Unknown error type:", typeof error);
          logger21.error("Error value:", error);
          try {
            logger21.error("Stringified error:", JSON.stringify(error, null, 2));
          } catch (e) {
            logger21.error("Could not stringify error:", e);
          }
        }
        return { failed: true };
      } finally {
        if (process.env.ELIZA_TESTING_PLUGIN) {
          delete process.env.ELIZA_TESTING_PLUGIN;
        }
        try {
          if (fs12.existsSync(elizaDbDir)) {
            console.info(`Cleaning up test database directory: ${elizaDbDir}`);
            fs12.rmSync(elizaDbDir, { recursive: true, force: true });
            console.info(`Successfully cleaned up test database directory`);
          }
          const testDir = path25.dirname(elizaDbDir);
          if (fs12.existsSync(testDir) && fs12.readdirSync(testDir).length === 0) {
            fs12.rmSync(testDir, { recursive: true, force: true });
          }
        } catch (cleanupError) {
          console.warn(`Failed to clean up test database directory: ${cleanupError}`);
        }
      }
    } catch (error) {
      logger21.error("Error in runE2eTests:", error);
      if (error instanceof Error) {
        logger21.error("Error details:", error.message);
        logger21.error("Stack trace:", error.stack);
      } else {
        logger21.error("Unknown error type:", typeof error);
        logger21.error("Error value:", error);
        try {
          logger21.error("Stringified error:", JSON.stringify(error, null, 2));
        } catch (e) {
          logger21.error("Could not stringify error:", e);
        }
      }
      return { failed: true };
    }
  } catch (error) {
    logger21.error("Error in runE2eTests:", error);
    if (error instanceof Error) {
      logger21.error("Error details:", error.message);
      logger21.error("Stack trace:", error.stack);
    } else {
      logger21.error("Unknown error type:", typeof error);
      logger21.error("Error value:", error);
      try {
        logger21.error("Stringified error:", JSON.stringify(error, null, 2));
      } catch (e) {
        logger21.error("Could not stringify error:", e);
      }
    }
    return { failed: true };
  }
}

// src/commands/test/actions/run-all-tests.ts
async function runAllTests(testPath, options) {
  const projectInfo = getProjectType(testPath);
  if (!options.skipBuild) {
    const componentResult = await runComponentTests(testPath, options, projectInfo);
    if (componentResult.failed) {
      logger22.error("Component tests failed. Continuing to e2e tests...");
    }
  }
  const e2eResult = await runE2eTests(testPath, options, projectInfo);
  if (e2eResult.failed) {
    logger22.error("E2E tests failed.");
    process.exit(1);
  }
  logger22.success("All tests passed successfully!");
  process.exit(0);
}

// src/commands/test/utils/port-utils.ts
import * as net from "net";

// src/commands/test/utils/plugin-utils.ts
import { logger as logger23 } from "@elizaos/core";
import * as fs13 from "fs";
import path26 from "path";

// src/commands/test/index.ts
var test = new Command10().name("test").description("Run tests for the current project or a specified plugin").argument("[path]", "Optional path to the project or plugin to test").addOption(
  new Option2("-t, --type <type>", "the type of test to run").choices(["component", "e2e", "all"]).default("all")
).option("--port <port>", "The port to run e2e tests on", validatePort).option("--name <name>", "Filter tests by name").option("--skip-build", "Skip building before running tests").option("--skip-type-check", "Skip TypeScript validation before running tests").hook("preAction", async (thisCommand) => {
  const testPath = thisCommand.args[0];
  const projectInfo = getProjectType(testPath);
  await installPluginDependencies(projectInfo);
}).action(async (testPath, options) => {
  logger24.info("Starting tests...");
  try {
    const projectInfo = getProjectType(testPath);
    switch (options.type) {
      case "component":
        logger24.info("Running component tests only...");
        const componentResult = await runComponentTests(testPath, options, projectInfo);
        if (componentResult.failed) {
          logger24.error("Component tests failed.");
          process.exit(1);
        }
        logger24.success("Component tests passed successfully!");
        break;
      case "e2e":
        logger24.info("Running e2e tests only...");
        const e2eResult = await runE2eTests(testPath, options, projectInfo);
        if (e2eResult.failed) {
          logger24.error("E2E tests failed.");
          process.exit(1);
        }
        logger24.success("E2E tests passed successfully!");
        break;
      case "all":
      default:
        logger24.info("Running all tests...");
        await runAllTests(testPath, options);
        break;
    }
    process.exit(0);
  } catch (error) {
    handleError(error);
  }
});

// src/index.ts
import { logger as logger25 } from "@elizaos/core";
import { Command as Command11 } from "commander";
import { existsSync as existsSync17, readFileSync as readFileSync5 } from "fs";
import path27, { dirname } from "path";
import { fileURLToPath as fileURLToPath2 } from "url";
process.env.NODE_OPTIONS = "--no-deprecation";
process.env.NODE_NO_WARNINGS = "1";
process.on("SIGINT", () => process.exit(0));
process.on("SIGTERM", () => process.exit(0));
async function main() {
  if (process.argv.includes("--no-emoji")) {
    configureEmojis({ forceDisable: true });
  }
  if (process.argv.includes("--no-auto-install")) {
    process.env.ELIZA_NO_AUTO_INSTALL = "true";
  }
  const __filename = fileURLToPath2(import.meta.url);
  const __dirname = dirname(__filename);
  const packageJsonPath = path27.resolve(__dirname, "../package.json");
  let version = "0.0.0";
  if (!existsSync17(packageJsonPath)) {
  } else {
    const packageJson = JSON.parse(readFileSync5(packageJsonPath, "utf-8"));
    version = packageJson.version;
  }
  const args = process.argv.slice(2);
  const isUpdateCommand = args.includes("update");
  const willShowBanner = args.length === 0;
  if (!willShowBanner && !isUpdateCommand) {
    const currentVersion = getVersion();
    await checkAndShowUpdateNotification(currentVersion);
  }
  const program = new Command11().name("elizaos").version(version, "-v, --version", "output the version number").option("--no-emoji", "Disable emoji output").option("--no-auto-install", "Disable automatic Bun installation");
  program.addCommand(create).addCommand(monorepo).addCommand(plugins).addCommand(agent).addCommand(teeCommand).addCommand(start).addCommand(update).addCommand(test).addCommand(env).addCommand(dev).addCommand(publish);
  if (process.argv.length === 2) {
    await displayBanner(false);
  }
  await program.parseAsync();
}
main().catch((error) => {
  logger25.error("An error occurred:", error);
  process.exit(1);
});
