
import { createRequire } from 'module';
const require = createRequire(import.meta.url);

import {
  buildProject,
  copyTemplate,
  ensureElizaDir,
  promptAndStoreAnthropicKey,
  promptAndStoreGoogleKey,
  promptAndStoreOllamaConfig,
  promptAndStoreOllamaEmbeddingConfig,
  promptAndStoreOpenAIKey,
  promptAndStoreOpenRouterKey,
  promptAndStorePostgresUrl,
  setupPgLite
} from "./chunk-IYFVOAOM.js";
import {
  runBunCommand
} from "./chunk-RIAWNDYI.js";

// src/characters/eliza.ts
var baseCharacter = {
  name: "Eliza",
  plugins: [
    "@elizaos/plugin-sql",
    "@elizaos/plugin-openai",
    "@elizaos/plugin-anthropic",
    "@elizaos/plugin-local-ai",
    "@elizaos/plugin-bootstrap"
  ],
  secrets: {},
  system: "Respond to all messages in a helpful, conversational manner. Provide assistance on a wide range of topics, using knowledge when needed. Be concise but thorough, friendly but professional. Use humor when appropriate and be empathetic to user needs. Provide valuable information and insights when questions are asked.",
  bio: [
    "Engages with all types of questions and conversations",
    "Provides helpful, concise responses",
    "Uses knowledge resources effectively when needed",
    "Balances brevity with completeness",
    "Uses humor and empathy appropriately",
    "Adapts tone to match the conversation context",
    "Offers assistance proactively",
    "Communicates clearly and directly"
  ],
  topics: [
    "general knowledge and information",
    "problem solving and troubleshooting",
    "technology and software",
    "community building and management",
    "business and productivity",
    "creativity and innovation",
    "personal development",
    "communication and collaboration",
    "education and learning",
    "entertainment and media"
  ],
  messageExamples: [
    [
      {
        name: "{{name1}}",
        content: {
          text: "This user keeps derailing technical discussions with personal problems."
        }
      },
      {
        name: "Eliza",
        content: {
          text: "DM them. Sounds like they need to talk about something else."
        }
      },
      {
        name: "{{name1}}",
        content: {
          text: "I tried, they just keep bringing drama back to the main channel."
        }
      },
      {
        name: "Eliza",
        content: {
          text: "Send them my way. I've got time today."
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "I can't handle being a mod anymore. It's affecting my mental health."
        }
      },
      {
        name: "Eliza",
        content: {
          text: "Drop the channels. You come first."
        }
      },
      {
        name: "{{name1}}",
        content: {
          text: "But who's going to handle everything?"
        }
      },
      {
        name: "Eliza",
        content: {
          text: "We will. Take the break. Come back when you're ready."
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Could you explain how blockchain technology works?"
        }
      },
      {
        name: "Eliza",
        content: {
          text: "A blockchain is a distributed database that maintains a growing list of records secured against tampering and revision. Think of it as a chain of blocks where each block contains data, its own hash, and the hash of the previous block."
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Hey everyone, what are our community guidelines for new members?"
        }
      },
      {
        name: "Eliza",
        content: {
          text: "Let me check our guidelines.",
          providers: ["KNOWLEDGE"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Are there any resources for onboarding new developers to our community?"
        }
      },
      {
        name: "Eliza",
        content: {
          text: "We have some documentation I can find for you.",
          providers: ["KNOWLEDGE"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "What process should we follow for handling code of conduct violations?"
        }
      },
      {
        name: "Eliza",
        content: {
          text: "Let me pull up our violation handling process.",
          providers: ["KNOWLEDGE"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "What can you tell me about quantum computing?"
        }
      },
      {
        name: "Eliza",
        content: {
          text: "Let me find some information about quantum computing.",
          providers: ["KNOWLEDGE"]
        }
      }
    ]
  ],
  style: {
    all: [
      "Keep responses concise but informative",
      "Use clear and direct language",
      "Be engaging and conversational",
      "Use humor when appropriate",
      "Be empathetic and understanding",
      "Provide helpful information",
      "Be encouraging and positive",
      "Adapt tone to the conversation",
      "Use knowledge resources when needed",
      "Respond to all types of questions"
    ],
    chat: [
      "Be conversational and natural",
      "Engage with the topic at hand",
      "Be helpful and informative",
      "Show personality and warmth"
    ]
  }
};
function getElizaCharacter() {
  const plugins = [
    "@elizaos/plugin-sql",
    ...process.env.ANTHROPIC_API_KEY ? ["@elizaos/plugin-anthropic"] : [],
    ...process.env.OPENAI_API_KEY ? ["@elizaos/plugin-openai"] : [],
    ...!process.env.OPENAI_API_KEY && !process.env.ANTHROPIC_API_KEY ? ["@elizaos/plugin-local-ai"] : [],
    ...!process.env.IGNORE_BOOTSTRAP ? ["@elizaos/plugin-bootstrap"] : []
  ];
  return {
    ...baseCharacter,
    plugins
  };
}

// src/commands/create/actions/creators.ts
import { join } from "path";
import fs3 from "fs/promises";
import * as clack2 from "@clack/prompts";
import colors from "yoctocolors";

// src/commands/create/utils/validation.ts
import { existsSync } from "fs";
import fs from "fs/promises";
import { z as z2 } from "zod";

// src/commands/create/types.ts
import { z } from "zod";
var initOptionsSchema = z.object({
  dir: z.string().default("."),
  yes: z.boolean().default(false),
  type: z.enum(["project", "plugin", "agent", "tee"]).default("project")
});

// src/commands/create/utils/validation.ts
var ProjectNameSchema = z2.string().min(1, "Invalid project name: cannot be empty").regex(
  /^[a-z0-9-_]+$/,
  "Invalid project name: must contain only lowercase letters, numbers, hyphens, and underscores"
).refine(
  (name) => !name.startsWith("-") && !name.endsWith("-"),
  "Invalid project name: cannot start or end with a hyphen"
).refine(
  (name) => !name.startsWith("_") && !name.endsWith("_"),
  "Invalid project name: cannot start or end with an underscore"
);
var PluginNameSchema = z2.string().min(1, "Plugin name cannot be empty").regex(
  /^[a-z0-9-_]+$/,
  "Plugin name must contain only lowercase letters, numbers, hyphens, and underscores"
).refine(
  (name) => !name.startsWith("-") && !name.endsWith("-"),
  "Plugin name cannot start or end with a hyphen"
).refine(
  (name) => !name.startsWith("_") && !name.endsWith("_"),
  "Plugin name cannot start or end with an underscore"
);
function validateCreateOptions(options) {
  try {
    return initOptionsSchema.parse(options);
  } catch (error) {
    if (error instanceof z2.ZodError) {
      const typeError = error.errors.find(
        (e) => e.path.includes("type") && e.code === "invalid_enum_value"
      );
      if (typeError && "received" in typeError) {
        const enumError = typeError;
        throw new Error(
          `Invalid type '${enumError.received}'. Expected: ${enumError.options?.join(", ")}`
        );
      }
    }
    throw error;
  }
}
function validateProjectName(name) {
  if (name === ".") {
    return { isValid: true };
  }
  try {
    ProjectNameSchema.parse(name);
    return { isValid: true };
  } catch (error) {
    if (error instanceof z2.ZodError) {
      return { isValid: false, error: error.errors[0].message };
    }
    return { isValid: false, error: "Invalid project name" };
  }
}
function processPluginName(name) {
  try {
    let processedName = name.replace(/^(eliza-?|elizaos-?|plugin-?)/i, "").replace(/(-?plugin|-?eliza|-?elizaos)$/i, "").toLowerCase().replace(/[^a-z0-9-_]/g, "-").replace(/-+/g, "-").replace(/^-+|-+$/g, "");
    if (!processedName) {
      return { isValid: false, error: "Plugin name cannot be empty after processing" };
    }
    PluginNameSchema.parse(processedName);
    return { isValid: true, processedName };
  } catch (error) {
    if (error instanceof z2.ZodError) {
      return { isValid: false, error: error.errors[0].message };
    }
    return { isValid: false, error: "Invalid plugin name" };
  }
}
async function validateTargetDirectory(targetDir) {
  try {
    if (!existsSync(targetDir)) {
      return { isValid: true };
    }
    const entries = await fs.readdir(targetDir);
    if (entries.length > 0) {
      return {
        isValid: false,
        error: `Directory ${targetDir} already exists and is not empty. Please choose an empty directory or a new name.`
      };
    }
    return { isValid: true };
  } catch (error) {
    return {
      isValid: false,
      error: `Failed to validate directory: ${error instanceof Error ? error.message : "Unknown error"}`
    };
  }
}

// src/commands/create/utils/selection.ts
import * as clack from "@clack/prompts";
function getAvailableAIModels() {
  return [
    {
      title: "Local AI",
      value: "local",
      description: "Local models, no API required"
    },
    {
      title: "OpenAI",
      value: "openai",
      description: "GPT-4 models"
    },
    {
      title: "Anthropic",
      value: "claude",
      description: "Claude models"
    },
    {
      title: "OpenRouter",
      value: "openrouter",
      description: "Access multiple AI models"
    },
    {
      title: "Ollama",
      value: "ollama",
      description: "Self-hosted models"
    },
    {
      title: "Google Generative AI",
      value: "google",
      description: "Gemini models"
    }
  ];
}
function getAvailableDatabases() {
  return [
    {
      title: "Pglite (Pglite)",
      value: "pglite",
      description: "Local development"
    },
    {
      title: "PostgreSQL",
      value: "postgres",
      description: "Production database"
    }
  ];
}
async function selectDatabase() {
  const availableDatabases = getAvailableDatabases();
  const database = await clack.select({
    message: "Which database would you like to use?",
    options: availableDatabases.map((db) => ({
      label: db.title,
      value: db.value,
      hint: db.description
    })),
    initialValue: "pglite"
  });
  if (clack.isCancel(database)) {
    clack.cancel("Operation cancelled.");
    process.exit(0);
  }
  return database;
}
async function selectAIModel() {
  const availableModels = getAvailableAIModels();
  const aiModel = await clack.select({
    message: "Which AI model would you like to use?",
    options: availableModels.map((model) => ({
      label: model.title,
      value: model.value,
      hint: model.description
    })),
    initialValue: "local"
  });
  if (clack.isCancel(aiModel)) {
    clack.cancel("Operation cancelled.");
    process.exit(0);
  }
  return aiModel;
}
function getAvailableEmbeddingModels() {
  return [
    {
      title: "Local AI",
      value: "local",
      description: "Local embeddings, no API required"
    },
    {
      title: "OpenAI",
      value: "openai",
      description: "OpenAI text-embedding-ada-002"
    },
    {
      title: "Ollama",
      value: "ollama",
      description: "Self-hosted embedding models"
    },
    {
      title: "Google Generative AI",
      value: "google",
      description: "Google embedding models"
    }
  ];
}
async function selectEmbeddingModel() {
  const availableModels = getAvailableEmbeddingModels();
  const embeddingModel = await clack.select({
    message: "Select an embedding model (required since your AI model doesn't support embeddings):",
    options: availableModels.map((model) => ({
      label: model.title,
      value: model.value,
      hint: model.description
    })),
    initialValue: "local"
  });
  if (clack.isCancel(embeddingModel)) {
    clack.cancel("Operation cancelled.");
    process.exit(0);
  }
  return embeddingModel;
}

// src/commands/create/actions/setup.ts
import { existsSync as existsSync2 } from "fs";
import fs2 from "fs/promises";
async function createProjectDirectories(targetDir) {
  await ensureElizaDir(targetDir);
}
async function setupAIModelConfig(aiModel, envFilePath, isNonInteractive = false) {
  try {
    switch (aiModel) {
      case "local": {
        console.info("[\u221A] Using Local AI - no additional configuration needed");
        break;
      }
      case "openai": {
        if (isNonInteractive) {
          let content = "";
          if (existsSync2(envFilePath)) {
            content = await fs2.readFile(envFilePath, "utf8");
          }
          if (content && !content.endsWith("\n")) {
            content += "\n";
          }
          content += "\n# AI Model Configuration\n";
          content += "# OpenAI Configuration\n";
          content += "OPENAI_API_KEY=your_openai_api_key_here\n";
          content += "# Get your API key from: https://platform.openai.com/api-keys\n";
          await fs2.writeFile(envFilePath, content, "utf8");
          console.info("[\u221A] OpenAI placeholder configuration added to .env file");
        } else {
          await promptAndStoreOpenAIKey(envFilePath);
        }
        break;
      }
      case "claude": {
        if (isNonInteractive) {
          let content = "";
          if (existsSync2(envFilePath)) {
            content = await fs2.readFile(envFilePath, "utf8");
          }
          if (content && !content.endsWith("\n")) {
            content += "\n";
          }
          content += "\n# AI Model Configuration\n";
          content += "# Anthropic API Configuration\n";
          content += "ANTHROPIC_API_KEY=your_anthropic_api_key_here\n";
          content += "# Get your API key from: https://console.anthropic.com/\n";
          await fs2.writeFile(envFilePath, content, "utf8");
          console.info("[\u221A] Anthropic API placeholder configuration added to .env file");
        } else {
          await promptAndStoreAnthropicKey(envFilePath);
        }
        break;
      }
      case "openrouter": {
        if (isNonInteractive) {
          let content = "";
          if (existsSync2(envFilePath)) {
            content = await fs2.readFile(envFilePath, "utf8");
          }
          if (content && !content.endsWith("\n")) {
            content += "\n";
          }
          content += "\n# AI Model Configuration\n";
          content += "# OpenRouter Configuration\n";
          content += "OPENROUTER_API_KEY=your_openrouter_api_key_here\n";
          content += "# Get your API key from: https://openrouter.ai/keys\n";
          await fs2.writeFile(envFilePath, content, "utf8");
          console.info("[\u221A] OpenRouter placeholder configuration added to .env file");
        } else {
          await promptAndStoreOpenRouterKey(envFilePath);
        }
        break;
      }
      case "ollama": {
        if (isNonInteractive) {
          let content = "";
          if (existsSync2(envFilePath)) {
            content = await fs2.readFile(envFilePath, "utf8");
          }
          if (content && !content.endsWith("\n")) {
            content += "\n";
          }
          content += "\n# AI Model Configuration\n";
          content += "# Ollama Configuration\n";
          content += "OLLAMA_API_ENDPOINT=http://localhost:11434\n";
          content += "OLLAMA_MODEL=llama2\n";
          content += "USE_OLLAMA_TEXT_MODELS=true\n";
          content += "# Make sure Ollama is installed and running: https://ollama.ai/\n";
          await fs2.writeFile(envFilePath, content, "utf8");
          console.info("[\u221A] Ollama placeholder configuration added to .env file");
        } else {
          await promptAndStoreOllamaConfig(envFilePath);
        }
        break;
      }
      case "google": {
        if (isNonInteractive) {
          let content = "";
          if (existsSync2(envFilePath)) {
            content = await fs2.readFile(envFilePath, "utf8");
          }
          if (content && !content.endsWith("\n")) {
            content += "\n";
          }
          content += "\n# AI Model Configuration\n";
          content += "# Google Generative AI Configuration\n";
          content += "GOOGLE_GENERATIVE_AI_API_KEY=your_google_api_key_here\n";
          content += "# Get your API key from: https://aistudio.google.com/apikey\n";
          await fs2.writeFile(envFilePath, content, "utf8");
          console.info("[\u221A] Google Generative AI placeholder configuration added to .env file");
        } else {
          await promptAndStoreGoogleKey(envFilePath);
        }
        break;
      }
      default:
        console.warn(`Unknown AI model: ${aiModel}, skipping configuration`);
        return;
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    console.error(`Failed to set up AI model configuration: ${errorMessage}`);
  }
}
function hasValidApiKey(content, keyName) {
  const regex = new RegExp(`^${keyName}=(.+)$`, "m");
  const match = content.match(regex);
  if (!match) return false;
  const value = match[1].trim();
  return value !== "" && !value.includes("your_") && !value.includes("_here") && !value.includes("PLACEHOLDER") && !value.includes("placeholder");
}
async function setupEmbeddingModelConfig(embeddingModel, envFilePath, isNonInteractive = false) {
  try {
    let content = "";
    if (existsSync2(envFilePath)) {
      content = await fs2.readFile(envFilePath, "utf8");
    }
    if (content && !content.endsWith("\n")) {
      content += "\n";
    }
    switch (embeddingModel) {
      case "local": {
        content += "\n# Embedding Model Configuration (Fallback)\n";
        content += "# Using local embeddings - no additional configuration needed\n";
        await fs2.writeFile(envFilePath, content, "utf8");
        console.info("[\u221A] Using Local embeddings - no additional configuration needed");
        break;
      }
      case "openai": {
        if (!hasValidApiKey(content, "OPENAI_API_KEY")) {
          if (isNonInteractive) {
            if (!content.includes("OPENAI_API_KEY=")) {
              content += "\n# Embedding Model Configuration (Fallback)\n";
              content += "# OpenAI Embeddings Configuration\n";
              content += "OPENAI_API_KEY=your_openai_api_key_here\n";
              content += "# Get your API key from: https://platform.openai.com/api-keys\n";
            }
            await fs2.writeFile(envFilePath, content, "utf8");
            console.info("[\u221A] OpenAI embeddings placeholder configuration added to .env file");
          } else {
            console.info("\n[!] OpenAI API key is required for embeddings");
            await promptAndStoreOpenAIKey(envFilePath);
          }
        } else {
          console.info("[\u221A] OpenAI API key already configured - will use for embeddings");
        }
        break;
      }
      case "ollama": {
        if (!hasValidApiKey(content, "OLLAMA_API_ENDPOINT")) {
          if (isNonInteractive) {
            if (!content.includes("OLLAMA_API_ENDPOINT=")) {
              content += "\n# Embedding Model Configuration (Fallback)\n";
              content += "# Ollama Embeddings Configuration\n";
              content += "OLLAMA_API_ENDPOINT=http://localhost:11434\n";
              content += "OLLAMA_EMBEDDING_MODEL=nomic-embed-text\n";
              content += "USE_OLLAMA_EMBEDDINGS=true\n";
              content += "# Make sure Ollama is installed and running: https://ollama.ai/\n";
            }
            await fs2.writeFile(envFilePath, content, "utf8");
            console.info("[\u221A] Ollama embeddings placeholder configuration added to .env file");
          } else {
            console.info("\n[!] Ollama embedding model configuration is required");
            await promptAndStoreOllamaEmbeddingConfig(envFilePath);
          }
        } else {
          if (isNonInteractive) {
            if (!content.includes("OLLAMA_EMBEDDING_MODEL")) {
              content += "OLLAMA_EMBEDDING_MODEL=nomic-embed-text\n";
            }
            if (!content.includes("USE_OLLAMA_EMBEDDINGS")) {
              content += "USE_OLLAMA_EMBEDDINGS=true\n";
            }
            await fs2.writeFile(envFilePath, content, "utf8");
            console.info("[\u221A] Ollama embedding model configuration added to .env file");
          } else {
            console.info("\n[!] Please select an Ollama embedding model");
            await promptAndStoreOllamaEmbeddingConfig(envFilePath);
          }
        }
        break;
      }
      case "google": {
        if (!hasValidApiKey(content, "GOOGLE_GENERATIVE_AI_API_KEY")) {
          if (isNonInteractive) {
            if (!content.includes("GOOGLE_GENERATIVE_AI_API_KEY=")) {
              content += "\n# Embedding Model Configuration (Fallback)\n";
              content += "# Google Generative AI Embeddings Configuration\n";
              content += "GOOGLE_GENERATIVE_AI_API_KEY=your_google_api_key_here\n";
              content += "# Get your API key from: https://aistudio.google.com/apikey\n";
            }
            await fs2.writeFile(envFilePath, content, "utf8");
            console.info("[\u221A] Google embeddings placeholder configuration added to .env file");
          } else {
            console.info("\n[!] Google Generative AI API key is required for embeddings");
            await promptAndStoreGoogleKey(envFilePath);
          }
        } else {
          console.info("[\u221A] Google API key already configured - will use for embeddings");
        }
        break;
      }
      default:
        console.warn(`Unknown embedding model: ${embeddingModel}, skipping configuration`);
        return;
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    console.error(`Failed to set up embedding model configuration: ${errorMessage}`);
  }
}
async function installDependencies(targetDir) {
  if (process.env.CI === "true" || process.env.ELIZA_TEST_MODE === "true") {
    console.info("Skipping dependency installation in CI/test environment...");
    return;
  }
  console.info("Installing dependencies...");
  await runBunCommand(["install"], targetDir);
}
async function setupProjectEnvironment(targetDir, database, aiModel, embeddingModel, isNonInteractive = false) {
  await createProjectDirectories(targetDir);
  const envFilePath = `${targetDir}/.env`;
  if (database === "postgres" && !isNonInteractive) {
    await promptAndStorePostgresUrl(envFilePath);
  } else if (database === "pglite") {
    await setupPgLite(void 0, `${targetDir}/.env`, targetDir);
  }
  await setupAIModelConfig(aiModel, envFilePath, isNonInteractive);
  if (embeddingModel) {
    await setupEmbeddingModelConfig(embeddingModel, envFilePath, isNonInteractive);
  }
}

// src/commands/create/actions/creators.ts
async function createPlugin(pluginName, targetDir, isNonInteractive = false) {
  const nameResult = processPluginName(pluginName);
  if (!nameResult.isValid) {
    throw new Error(nameResult.error || "Invalid plugin name");
  }
  const processedName = nameResult.processedName;
  const pluginDirName = processedName.startsWith("plugin-") ? processedName : `plugin-${processedName}`;
  const pluginTargetDir = join(targetDir, pluginDirName);
  const dirResult = await validateTargetDirectory(pluginTargetDir);
  if (!dirResult.isValid) {
    throw new Error(dirResult.error || "Invalid target directory");
  }
  if (!isNonInteractive) {
    const confirmCreate = await clack2.confirm({
      message: `Create plugin "${pluginDirName}" in ${pluginTargetDir}?`
    });
    if (clack2.isCancel(confirmCreate) || !confirmCreate) {
      clack2.cancel("Plugin creation cancelled.");
      process.exit(0);
    }
  }
  await copyTemplate("plugin", pluginTargetDir);
  await installDependencies(pluginTargetDir);
  console.info(`
${colors.green("\u2713")} Plugin "${pluginDirName}" created successfully!`);
  console.info(`
Next steps:`);
  console.info(`  cd ${pluginDirName}`);
  console.info(`  bun run build`);
  console.info(`  bun run test
`);
}
async function createAgent(agentName, targetDir, isNonInteractive = false) {
  const agentFilePath = join(targetDir, `${agentName}.json`);
  try {
    await fs3.access(agentFilePath);
    throw new Error(`Agent file ${agentFilePath} already exists`);
  } catch (error) {
    if (error.code !== "ENOENT") {
      throw error;
    }
  }
  if (!isNonInteractive) {
    const confirmCreate = await clack2.confirm({
      message: `Create agent "${agentName}" at ${agentFilePath}?`
    });
    if (clack2.isCancel(confirmCreate) || !confirmCreate) {
      clack2.cancel("Agent creation cancelled.");
      process.exit(0);
    }
  }
  const agentCharacter = {
    ...getElizaCharacter(),
    name: agentName,
    bio: [
      `${agentName} is a helpful AI assistant created to provide assistance and engage in meaningful conversations.`,
      `${agentName} is knowledgeable, creative, and always eager to help users with their questions and tasks.`
    ]
  };
  await fs3.writeFile(agentFilePath, JSON.stringify(agentCharacter, null, 2));
  if (!isNonInteractive) {
    console.info(`
${colors.green("\u2713")} Agent "${agentName}" created successfully!`);
  }
  console.info(`Agent character created successfully at: ${agentFilePath}`);
  console.info(`
To use this agent:`);
  console.info(`  elizaos agent start --path ${agentFilePath}
`);
}
async function createTEEProject(projectName, targetDir, database, aiModel, embeddingModel, isNonInteractive = false) {
  const teeTargetDir = join(targetDir, projectName);
  const dirResult = await validateTargetDirectory(teeTargetDir);
  if (!dirResult.isValid) {
    throw new Error(dirResult.error || "Invalid target directory");
  }
  if (!isNonInteractive) {
    const confirmCreate = await clack2.confirm({
      message: `Create TEE project "${projectName}" in ${teeTargetDir}?`
    });
    if (clack2.isCancel(confirmCreate) || !confirmCreate) {
      clack2.cancel("TEE project creation cancelled.");
      process.exit(0);
    }
  }
  await copyTemplate("project-tee-starter", teeTargetDir);
  await setupProjectEnvironment(teeTargetDir, database, aiModel, embeddingModel, isNonInteractive);
  await installDependencies(teeTargetDir);
  await buildProject(teeTargetDir);
  console.info(`
${colors.green("\u2713")} TEE project "${projectName}" created successfully!`);
  console.info(`
Next steps:`);
  console.info(`  cd ${projectName}`);
  console.info(`  bun run dev
`);
}
async function createProject(projectName, targetDir, database, aiModel, embeddingModel, isNonInteractive = false) {
  const projectTargetDir = projectName === "." ? targetDir : join(targetDir, projectName);
  const dirResult = await validateTargetDirectory(projectTargetDir);
  if (!dirResult.isValid) {
    throw new Error(dirResult.error || "Invalid target directory");
  }
  if (!isNonInteractive) {
    const confirmCreate = await clack2.confirm({
      message: `Create project "${projectName}" in ${projectTargetDir}?`
    });
    if (clack2.isCancel(confirmCreate) || !confirmCreate) {
      clack2.cancel("Project creation cancelled.");
      process.exit(0);
    }
  }
  await copyTemplate("project-starter", projectTargetDir);
  await setupProjectEnvironment(
    projectTargetDir,
    database,
    aiModel,
    embeddingModel,
    isNonInteractive
  );
  await installDependencies(projectTargetDir);
  await buildProject(projectTargetDir);
  const displayName = projectName === "." ? "Project" : `Project "${projectName}"`;
  console.info(`
${colors.green("\u2713")} ${displayName} initialized successfully!`);
  console.info(`
Next steps:`);
  console.info(`  cd ${projectName}`);
  console.info(`  bun run dev
`);
}

export {
  validateCreateOptions,
  validateProjectName,
  selectDatabase,
  selectAIModel,
  selectEmbeddingModel,
  getElizaCharacter,
  createProjectDirectories,
  setupAIModelConfig,
  setupEmbeddingModelConfig,
  installDependencies,
  setupProjectEnvironment,
  createPlugin,
  createAgent,
  createTEEProject,
  createProject
};
