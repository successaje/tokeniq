
import { createRequire } from 'module';
const require = createRequire(import.meta.url);

import {
  runBunCommand
} from "./chunk-RIAWNDYI.js";
import "./chunk-KB3JDWUI.js";
import "./chunk-AQ6OMR2A.js";

// src/utils/plugin-creator.ts
import Anthropic from "@anthropic-ai/sdk";
import { logger } from "@elizaos/core";
import { execa } from "execa";
import * as fs from "fs-extra";
import inquirer from "inquirer";
import ora from "ora";
import * as path from "path";
import simpleGit from "simple-git";
import * as os from "os";
var MAX_BUILD_ITERATIONS = 5;
var MAX_TEST_ITERATIONS = 5;
var MAX_REVISION_ITERATIONS = 3;
var CLAUDE_CODE_TIMEOUT = 15 * 60 * 1e3;
var MIN_DISK_SPACE_GB = 2;
var PluginCreator = class {
  git;
  pluginPath = null;
  anthropic = null;
  activeClaudeProcess = null;
  options;
  constructor(options = {}) {
    this.git = simpleGit();
    this.options = options;
    this.registerCleanupHandlers();
  }
  registerCleanupHandlers() {
    const cleanup = async () => {
      logger.info("Cleaning up plugin creation process...");
      if (this.activeClaudeProcess) {
        try {
          this.activeClaudeProcess.kill();
          logger.info("Terminated active Claude Code process");
        } catch (error) {
          logger.error("Failed to terminate Claude Code process:", error);
        }
      }
      process.exit(1);
    };
    process.on("SIGINT", cleanup);
    process.on("SIGTERM", cleanup);
    process.on("uncaughtException", async (error) => {
      logger.error("Uncaught exception:", error);
      await cleanup();
    });
  }
  async initializeAnthropic() {
    const apiKey = process.env.ANTHROPIC_API_KEY;
    if (!apiKey) {
      logger.error("ANTHROPIC_API_KEY not found in environment.");
      throw new Error("ANTHROPIC_API_KEY is required for plugin generation");
    }
    this.anthropic = new Anthropic({ apiKey });
  }
  async create(pluginSpec) {
    const spinner = ora("Initializing plugin creator...").start();
    try {
      await this.initializeAnthropic();
      spinner.info("Checking disk space...");
      await this.checkDiskSpace();
      try {
        await execa("claude", ["--version"], { stdio: "pipe" });
      } catch {
        throw new Error(
          "Claude Code is required for plugin generation. Install with: bun install -g @anthropic-ai/claude-code"
        );
      }
      spinner.info("Collecting plugin specification...");
      const spec = pluginSpec || this.options.spec || await this.collectPluginSpecification();
      spinner.succeed("Plugin specification collected");
      spinner.info("Creating plugin from template...");
      await this.createFromTemplate(spec.name);
      spinner.succeed("Plugin structure created");
      spinner.info("Generating detailed plugin specification...");
      const detailedSpec = await this.generateDetailedSpecification(spec);
      spinner.succeed("Detailed specification generated");
      spinner.info("Creating plugin specification document...");
      await this.createSpecificationDocument(spec, detailedSpec);
      spinner.succeed("Specification document created");
      spinner.info("Generating plugin code...");
      const generationSuccess = await this.runGenerationWithValidation();
      if (!generationSuccess) {
        throw new Error("Plugin generation failed after maximum iterations");
      }
      spinner.succeed("Plugin code generated and validated");
      const targetPath = await this.copyToCWD();
      logger.info(`\u2705 Plugin successfully created!`);
      logger.info(`\u{1F4C1} Plugin location: ${targetPath}`);
      logger.info(`
\u{1F4CC} Next steps:`);
      logger.info(`1. cd ${path.basename(targetPath)}`);
      logger.info(`2. Review the generated code`);
      logger.info(`3. Run tests: bun test`);
      logger.info(`4. Add to your ElizaOS project
`);
      return {
        success: true,
        pluginName: spec.name,
        pluginPath: targetPath
      };
    } catch (error) {
      spinner.fail("Plugin creation failed");
      logger.error("Error creating plugin:", error);
      return {
        success: false,
        pluginName: "",
        pluginPath: "",
        error
      };
    }
  }
  async collectPluginSpecification() {
    if (this.options.skipPrompts) {
      throw new Error("Plugin specification required when skipping prompts");
    }
    const answers = await inquirer.prompt([
      {
        type: "input",
        name: "name",
        message: 'Plugin name (without "plugin-" prefix):',
        validate: (input) => {
          if (!input || input.trim() === "") {
            return "Plugin name is required";
          }
          return true;
        },
        filter: (input) => input.toLowerCase().replace(/\s+/g, "-")
      },
      {
        type: "input",
        name: "description",
        message: "Plugin description:",
        validate: (input) => input.length > 0 || "Description is required"
      },
      {
        type: "input",
        name: "features",
        message: "Main features (comma-separated):",
        filter: (input) => input.split(",").map((f) => f.trim()).filter((f) => f)
      },
      {
        type: "checkbox",
        name: "components",
        message: "Which components will this plugin include?",
        choices: [
          { name: "Actions", value: "actions" },
          { name: "Providers", value: "providers" },
          { name: "Evaluators", value: "evaluators" },
          { name: "Services", value: "services" }
        ],
        default: ["actions", "providers"]
      }
    ]);
    const spec = {
      name: answers.name,
      description: answers.description,
      features: answers.features
    };
    if (answers.components.includes("actions")) {
      const actionAnswers = await inquirer.prompt([
        {
          type: "input",
          name: "actions",
          message: "Action names (comma-separated):",
          filter: (input) => input.split(",").map((a) => a.trim()).filter((a) => a)
        }
      ]);
      spec.actions = actionAnswers.actions;
    }
    if (answers.components.includes("providers")) {
      const providerAnswers = await inquirer.prompt([
        {
          type: "input",
          name: "providers",
          message: "Provider names (comma-separated):",
          filter: (input) => input.split(",").map((p) => p.trim()).filter((p) => p)
        }
      ]);
      spec.providers = providerAnswers.providers;
    }
    if (answers.components.includes("evaluators")) {
      const evaluatorAnswers = await inquirer.prompt([
        {
          type: "input",
          name: "evaluators",
          message: "Evaluator names (comma-separated):",
          filter: (input) => input.split(",").map((e) => e.trim()).filter((e) => e)
        }
      ]);
      spec.evaluators = evaluatorAnswers.evaluators;
    }
    if (answers.components.includes("services")) {
      const serviceAnswers = await inquirer.prompt([
        {
          type: "input",
          name: "services",
          message: "Service names (comma-separated):",
          filter: (input) => input.split(",").map((s) => s.trim()).filter((s) => s)
        }
      ]);
      spec.services = serviceAnswers.services;
    }
    return spec;
  }
  async createFromTemplate(pluginName) {
    const tempDir = path.join(os.tmpdir(), `plugin-${pluginName}-${Date.now()}`);
    await fs.ensureDir(tempDir);
    this.pluginPath = path.join(tempDir, `plugin-${pluginName}`);
    try {
      await execa(
        "bunx",
        ["@elizaos/cli", "create", `plugin-${pluginName}`, "-t", "plugin-starter"],
        {
          cwd: tempDir,
          stdio: "pipe"
        }
      );
    } catch (error) {
      logger.warn("Failed to use elizaos create, creating structure manually");
      await this.createPluginStructureManually(pluginName);
    }
    this.git = simpleGit(this.pluginPath);
    await this.git.init();
    await this.git.add(".");
    await this.git.commit("Initial commit from plugin-starter template");
  }
  async createPluginStructureManually(pluginName) {
    await fs.ensureDir(this.pluginPath);
    const dirs = ["src", "src/actions", "src/providers", "src/evaluators", "src/services", "tests"];
    for (const dir of dirs) {
      await fs.ensureDir(path.join(this.pluginPath, dir));
    }
    const packageJson = {
      name: `@elizaos/plugin-${pluginName}`,
      version: "0.1.0",
      description: `ElizaOS ${pluginName} plugin`,
      main: "dist/index.js",
      types: "dist/index.d.ts",
      scripts: {
        build: "tsup",
        dev: "tsup --watch",
        test: "bun test",
        "test:watch": "bun test --watch"
      },
      dependencies: {
        "@elizaos/core": "^1.0.0"
      },
      devDependencies: {
        tsup: "^8.4.0",
        typescript: "^5.3.0",
        "@types/bun": "^1.0.0",
        "@types/node": "^20.0.0"
      },
      peerDependencies: {
        "@elizaos/core": "1.x"
      },
      files: ["dist", "README.md"]
    };
    await fs.writeJSON(path.join(this.pluginPath, "package.json"), packageJson, { spaces: 2 });
    const tsconfig = {
      extends: "../../tsconfig.json",
      compilerOptions: {
        outDir: "./dist",
        rootDir: "./src"
      },
      include: ["src/**/*"],
      exclude: ["node_modules", "dist"]
    };
    await fs.writeJSON(path.join(this.pluginPath, "tsconfig.json"), tsconfig, { spaces: 2 });
    const tsupConfig = `import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['src/index.ts'],
  format: ['cjs', 'esm'],
  dts: true,
  sourcemap: true,
  clean: true,
  external: ['@elizaos/core'],
});
`;
    await fs.writeFile(path.join(this.pluginPath, "tsup.config.ts"), tsupConfig);
    const gitignore = `node_modules/
dist/
*.log
.env
.DS_Store
coverage/
`;
    await fs.writeFile(path.join(this.pluginPath, ".gitignore"), gitignore);
    const readme = `# @elizaos/plugin-${pluginName}

ElizaOS ${pluginName} plugin

## Installation

\`\`\`bash
bun install @elizaos/plugin-${pluginName}
\`\`\`

## Usage

\`\`\`typescript
import { plugin${pluginName.split("-").map((p) => p.charAt(0).toUpperCase() + p.slice(1)).join("")} } from '@elizaos/plugin-${pluginName}';

// Add to your ElizaOS configuration
\`\`\`
`;
    await fs.writeFile(path.join(this.pluginPath, "README.md"), readme);
    const indexContent = `import { Plugin } from '@elizaos/core';

export const plugin${pluginName.split("-").map((p) => p.charAt(0).toUpperCase() + p.slice(1)).join("")}: Plugin = {
  name: 'plugin-${pluginName}',
  version: '0.1.0',
  actions: [],
  providers: [],
  evaluators: [],
  services: [],
};

export default plugin${pluginName.split("-").map((p) => p.charAt(0).toUpperCase() + p.slice(1)).join("")};
`;
    await fs.writeFile(path.join(this.pluginPath, "src/index.ts"), indexContent);
  }
  async generateDetailedSpecification(spec) {
    const prompt = `You are creating a detailed technical specification for an ElizaOS plugin.

## Plugin Overview
Name: ${spec.name}
Description: ${spec.description}
Features: ${spec.features.join(", ")}

${spec.actions ? `Actions: ${spec.actions.join(", ")}` : ""}
${spec.providers ? `Providers: ${spec.providers.join(", ")}` : ""}
${spec.evaluators ? `Evaluators: ${spec.evaluators.join(", ")}` : ""}
${spec.services ? `Services: ${spec.services.join(", ")}` : ""}

## CRITICAL REQUIREMENTS

### 1. Database Compatibility (MANDATORY)
This plugin MUST work with both Pglite and PostgreSQL. The specification must include:
- Database-agnostic design patterns
- Use of runtime APIs only (no direct database access)
- Memory operations using runtime.createMemory(), runtime.searchMemories()
- Goal operations using runtime.createGoal(), runtime.updateGoal()
- Relationship operations using runtime.ensureConnection()
- NO database-specific code or SQL queries
- NO direct database adapter imports

### 2. Import Requirements (MANDATORY)
- ALL imports must come from @elizaos/core ONLY
- NO imports from @elizaos/plugin, @elizaos/types, @elizaos/logger (these don't exist)
- Use: import { Plugin, Action, AgentRuntime, logger, Memory, State } from '@elizaos/core'

## Task
Generate a detailed technical specification that includes:

1. **Architecture Overview**: How the plugin components work together (database-agnostic)
2. **Component Specifications**: Detailed specs for each action, provider, evaluator, and service
3. **Data Flow**: How data moves through the plugin using runtime APIs
4. **Integration Points**: How the plugin integrates with ElizaOS runtime
5. **Implementation Details**: Specific algorithms, APIs, or techniques to use (database-agnostic)
6. **Database Abstraction**: How to use runtime APIs for all data operations
7. **Testing Strategy**: What tests are needed (including database compatibility tests)
8. **Error Handling**: How errors should be handled
9. **Configuration**: Any configuration options needed

## Database Abstraction Examples:
\`\`\`typescript
// Memory operations - works with both Pglite and PostgreSQL
await runtime.createMemory({
  entityId: message.entityId,
  agentId: runtime.agentId,
  content: { text: 'Important information' },
  roomId: message.roomId,
  embedding: await runtime.embed('Important information'),
});

// Search memories - database-agnostic
const memories = await runtime.searchMemories({
  text: query,
  entityId: message.entityId,
  count: 10,
});

// Goal operations - database-agnostic
await runtime.createGoal({
  entityId: message.entityId,
  agentId: runtime.agentId,
  name: 'Complete task',
  status: 'IN_PROGRESS',
});
\`\`\`

Be extremely detailed and specific. This specification will be used to generate the actual code.
Remember: The plugin must work with BOTH Pglite and PostgreSQL without any code changes.`;
    const message = await this.anthropic.messages.create({
      model: "claude-opus-4-20250514",
      max_tokens: 8192,
      temperature: 0.3,
      messages: [
        {
          role: "user",
          content: prompt
        }
      ]
    });
    return message.content.map((block) => block.type === "text" ? block.text : "").join("");
  }
  async createSpecificationDocument(spec, detailedSpec) {
    const content = `# Plugin Specification: ${spec.name}

## Overview
${spec.description}

## Features
${spec.features.map((f) => `- ${f}`).join("\n")}

## Components
${spec.actions ? `### Actions
${spec.actions.map((a) => `- ${a}`).join("\n")}` : ""}
${spec.providers ? `### Providers
${spec.providers.map((p) => `- ${p}`).join("\n")}` : ""}
${spec.evaluators ? `### Evaluators
${spec.evaluators.map((e) => `- ${e}`).join("\n")}` : ""}
${spec.services ? `### Services
${spec.services.map((s) => `- ${s}`).join("\n")}` : ""}

## CRITICAL REQUIREMENTS

### Database Compatibility (MANDATORY)
This plugin MUST work with both Pglite and PostgreSQL without any code changes.

#### Database Abstraction Rules:
- \u2705 Use ONLY runtime.databaseAdapter for database operations
- \u2705 Use runtime.createMemory(), runtime.searchMemories(), runtime.createGoal()
- \u2705 Use runtime.ensureConnection() for relationships
- \u274C NEVER import database adapters directly (PgliteDatabaseAdapter, PgDatabaseAdapter)
- \u274C NEVER use database-specific SQL or queries
- \u274C NEVER make assumptions about database type

#### Example Database-Agnostic Code:
\`\`\`typescript
// \u2705 CORRECT - Memory operations
await runtime.createMemory({
  entityId: message.entityId,
  agentId: runtime.agentId,
  content: { text: 'Information to store' },
  roomId: message.roomId,
  embedding: await runtime.embed('Information to store'),
});

// \u2705 CORRECT - Search operations
const memories = await runtime.searchMemories({
  text: searchQuery,
  entityId: message.entityId,
  count: 10,
});

// \u274C WRONG - Direct database imports
import { PgliteDatabaseAdapter } from '@elizaos/plugin-sql';
\`\`\`

### Import Requirements (MANDATORY)
ALL imports must come from @elizaos/core ONLY:

\`\`\`typescript
// \u2705 CORRECT - All from @elizaos/core
import {
  Plugin,
  Action,
  AgentRuntime,
  logger,
  Memory,
  State,
  Content,
  HandlerCallback,
  Service,
} from '@elizaos/core';

// \u274C WRONG - These packages don't exist
import { logger } from '@elizaos/logger';
import { Action } from '@elizaos/types';
import { PgliteDatabaseAdapter } from '@elizaos/plugin-sql';
\`\`\`

## Detailed Technical Specification

${detailedSpec}

## Implementation Instructions

You are now going to implement this plugin following ElizaOS 1.0.0 best practices:

### 1. Core Implementation
- **Use TypeScript** for all code
- **Follow the ElizaOS plugin structure** exactly
- **Implement all components** specified above
- **Create comprehensive tests** for each component
- **Use proper error handling** throughout
- **Add detailed logging** using the ElizaOS logger

### 2. Database Compatibility
- **MANDATORY**: Plugin must work with both Pglite and PostgreSQL
- **Use ONLY runtime APIs** for all data operations
- **NO direct database imports** or database-specific code
- **Test with both databases** in test suite

### 3. Import Compliance
- **ALL imports from @elizaos/core ONLY**
- **NO imports from non-existent packages**
- **Follow import examples above exactly**

### 4. Component Requirements
- **Services**: Must extend the base Service class with lifecycle methods (initialize, start, stop)
- **Actions**: Must implement validate and handler functions
- **Providers**: Must return formatted context strings using runtime APIs
- **Evaluators**: Run after interactions, store data using runtime APIs
- **All components**: Must be properly exported in index.ts

### 5. Testing Requirements
- **Tests must use bun test** and cover all functionality
- **Database compatibility tests**:
  \`\`\`typescript
  describe('Database Compatibility', () => {
    it('should work with Pglite', async () => {
      process.env.PGLITE_DATA_DIR = './.test-db';
      delete process.env.POSTGRES_URL;
      // Test plugin functionality
    });
    
    it('should work with PostgreSQL', async () => {
      process.env.POSTGRES_URL = 'postgresql://test:test@localhost:5432/test';
      delete process.env.PGLITE_DATA_DIR;
      // Test plugin functionality
    });
  });
  \`\`\`

### 6. Quality Requirements
- **NO stubs or incomplete code**
- **Production-ready implementation**
- **Proper error handling**
- **Clean, well-organized code**

## Production Readiness Checklist

Before considering implementation complete, verify:

- \u2705 All imports come from @elizaos/core only
- \u2705 No direct database adapter imports
- \u2705 Uses runtime APIs for all data operations
- \u2705 Works with both Pglite and PostgreSQL
- \u2705 Has comprehensive tests for both database types
- \u2705 No database-specific code or SQL
- \u2705 Proper error handling throughout
- \u2705 No stubs or incomplete code
- \u2705 Services extend base Service class
- \u2705 Actions have validation and handlers
- \u2705 All components properly exported

Work systematically through each component, implementing it completely before moving to the next.
Remember: Database compatibility is MANDATORY - the plugin MUST work with both Pglite and PostgreSQL.
`;
    await fs.writeFile(path.join(this.pluginPath, "PLUGIN_SPEC.md"), content);
  }
  async runGenerationWithValidation() {
    await this.runClaudeCode();
    if (!await this.runBuildLoop()) {
      return false;
    }
    if (!this.options.skipTests && !await this.runTestLoop()) {
      return false;
    }
    if (!this.options.skipValidation && !await this.runProductionValidationLoop()) {
      return false;
    }
    return true;
  }
  async runBuildLoop() {
    let buildIteration = 0;
    let buildSuccess = false;
    while (buildIteration < MAX_BUILD_ITERATIONS && !buildSuccess) {
      buildIteration++;
      logger.info(`Build iteration ${buildIteration}/${MAX_BUILD_ITERATIONS}`);
      if (buildIteration > 1) {
        const buildErrors = await this.getBuildErrors();
        await this.runClaudeCodeWithContext(buildErrors);
      }
      const buildResult = await this.runBuild();
      buildSuccess = buildResult.success;
      if (buildSuccess) {
        logger.info("\u2705 Build successful!");
        return true;
      } else {
        logger.warn(`Build failed. ${MAX_BUILD_ITERATIONS - buildIteration} attempts remaining.`);
      }
    }
    return buildSuccess;
  }
  async runTestLoop() {
    let testIteration = 0;
    let allTestsPass = false;
    while (testIteration < MAX_TEST_ITERATIONS && !allTestsPass) {
      testIteration++;
      logger.info(`Test iteration ${testIteration}/${MAX_TEST_ITERATIONS}`);
      if (testIteration > 1) {
        const testErrors = await this.getTestErrors();
        await this.runClaudeCodeWithContext(testErrors);
      }
      const testResult = await this.runTests();
      allTestsPass = testResult.success;
      if (allTestsPass) {
        logger.info("\u2705 All tests passing!");
        return true;
      } else {
        logger.warn(`Tests failed. ${MAX_TEST_ITERATIONS - testIteration} attempts remaining.`);
      }
    }
    return allTestsPass;
  }
  async runProductionValidationLoop() {
    let revisionIteration = 0;
    let productionReady = false;
    while (revisionIteration < MAX_REVISION_ITERATIONS && !productionReady) {
      revisionIteration++;
      logger.info(
        `Production validation iteration ${revisionIteration}/${MAX_REVISION_ITERATIONS}`
      );
      const validationResult = await this.validateProductionReadiness();
      productionReady = validationResult.production_ready;
      if (productionReady) {
        logger.info("\u2705 Plugin validated as production ready!");
        return true;
      } else if (validationResult.revision_instructions) {
        logger.warn("Plugin needs revisions. Applying changes...");
        await this.runClaudeCodeWithContext(validationResult.revision_instructions);
        if (!await this.runBuildLoop() || !this.options.skipTests && !await this.runTestLoop()) {
          return false;
        }
      }
    }
    return productionReady;
  }
  async runClaudeCode() {
    const prompt = `Please read the PLUGIN_SPEC.md file in this repository and implement the complete plugin as specified. Create all components, tests, and ensure everything is production-ready with no stubs or incomplete code.`;
    await this.runClaudeCodeWithPrompt(prompt);
  }
  async runClaudeCodeWithContext(context) {
    const prompt = `Please read the PLUGIN_SPEC.md file and fix the following issues:

${context}

Make all necessary changes to fix the issues and ensure the plugin builds and all tests pass.`;
    await this.runClaudeCodeWithPrompt(prompt);
  }
  async runClaudeCodeWithPrompt(prompt) {
    process.chdir(this.pluginPath);
    logger.info("\u{1F916} Starting Claude Code execution...");
    logger.info(`\u{1F4C1} Working directory: ${this.pluginPath}`);
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        reject(
          new Error(`Claude Code execution timed out after ${CLAUDE_CODE_TIMEOUT / 1e3} seconds`)
        );
      }, CLAUDE_CODE_TIMEOUT);
    });
    const executePromise = (async () => {
      try {
        const claudeArgs = [
          "--print",
          "--max-turns",
          "30",
          "--verbose",
          "--model",
          "opus",
          "--dangerously-skip-permissions",
          prompt
        ];
        logger.info(`\u{1F680} Executing: claude ${claudeArgs.join(" ")}`);
        this.activeClaudeProcess = execa("claude", claudeArgs, {
          stdio: "inherit",
          cwd: this.pluginPath
        });
        await this.activeClaudeProcess;
        this.activeClaudeProcess = null;
        logger.info("\u2705 Claude Code execution completed successfully");
      } catch (error) {
        this.activeClaudeProcess = null;
        if (error.code === "ENOENT") {
          throw new Error(
            "Claude Code not found! Install with: bun install -g @anthropic-ai/claude-code"
          );
        }
        throw error;
      }
    })();
    try {
      await Promise.race([executePromise, timeoutPromise]);
    } catch (error) {
      if (this.activeClaudeProcess) {
        try {
          this.activeClaudeProcess.kill();
          this.activeClaudeProcess = null;
          logger.warn("\u{1F6D1} Claude Code process terminated due to timeout");
        } catch (killError) {
          logger.error("Failed to kill timed-out process:", killError);
        }
      }
      logger.error("\u274C Claude Code execution failed:", error);
      throw error;
    }
  }
  async runBuild() {
    try {
      logger.info("Installing dependencies with bun...");
      await runBunCommand(["install"], this.pluginPath);
      logger.info("Running build with bun...");
      await runBunCommand(["run", "build"], this.pluginPath);
      return { success: true };
    } catch (error) {
      const errorOutput = (error.stdout || "") + "\n" + (error.stderr || "");
      logger.error("Build failed:", errorOutput);
      return { success: false, errors: errorOutput };
    }
  }
  async getBuildErrors() {
    const result = await this.runBuild();
    return result.errors || "Build failed but no specific errors captured";
  }
  async runTests() {
    try {
      logger.info("Running tests with bun...");
      await runBunCommand(["test"], this.pluginPath);
      return { success: true };
    } catch (error) {
      const errorOutput = (error.stdout || "") + "\n" + (error.stderr || "");
      logger.error("Tests failed:", errorOutput);
      return { success: false, errors: errorOutput };
    }
  }
  async getTestErrors() {
    const result = await this.runTests();
    return result.errors || "Tests failed but no specific errors captured";
  }
  async validateProductionReadiness() {
    const allFiles = await this.getAllPluginFiles();
    const prompt = `You are reviewing a newly generated ElizaOS plugin for production readiness.

## Plugin Files:
${allFiles}

## Evaluation Criteria:

### 1. Import Compliance (CRITICAL - MANDATORY)
- \u2705 ALL imports must come from @elizaos/core ONLY
- \u274C NO imports from @elizaos/plugin, @elizaos/types, @elizaos/logger, etc. (these don't exist)
- \u274C NO direct database adapter imports (PgliteDatabaseAdapter, PgDatabaseAdapter)
- \u2705 Correct import format: import { Plugin, Action, AgentRuntime, logger } from '@elizaos/core'

### 2. Database Compatibility (CRITICAL - MANDATORY)
- \u2705 Plugin must work with both Pglite and PostgreSQL without code changes
- \u2705 Uses ONLY runtime.databaseAdapter for database operations
- \u2705 Uses runtime.createMemory(), runtime.searchMemories(), runtime.createGoal()
- \u2705 Uses runtime.ensureConnection() for relationships
- \u274C NO database-specific SQL or queries
- \u274C NO assumptions about database type
- \u274C NO direct database adapter usage
- \u2705 Database compatibility tests for both Pglite and PostgreSQL

### 3. Component Implementation
- \u2705 All components are fully implemented (no stubs or TODOs)
- \u2705 Services extend base Service class with lifecycle methods (initialize, start, stop)
- \u2705 Actions have proper validation and handlers
- \u2705 Providers return formatted context using runtime APIs
- \u2705 Evaluators store data using runtime APIs

### 4. Testing Coverage
- \u2705 Comprehensive tests exist for all functionality
- \u2705 Tests use bun test framework
- \u2705 Database compatibility tests included
- \u2705 Tests cover main plugin functionality
- \u2705 Error handling tests included

### 5. Code Quality
- \u2705 Proper error handling throughout
- \u2705 Follows ElizaOS 1.0.0 patterns and best practices
- \u2705 Documentation is complete
- \u2705 Code is clean and well-organized
- \u2705 Plugin exports are correct
- \u2705 No stubs or incomplete code remains

## Response Format:
Respond with a JSON object:
{
  "production_ready": boolean,
  "revision_instructions": "Detailed instructions for what needs to be fixed (only if not production ready)"
}

## Validation Priority (ALL MUST PASS):
1. Import compliance is MANDATORY - any non-@elizaos/core imports = NOT production ready
2. Database compatibility is MANDATORY - must work with both Pglite and PostgreSQL
3. All components must be fully implemented
4. Comprehensive tests must exist
5. All other criteria must also pass

If ANY of the CRITICAL requirements fail, the plugin is NOT production ready.`;
    const message = await this.anthropic.messages.create({
      model: "claude-opus-4-20250514",
      max_tokens: 8192,
      temperature: 0,
      messages: [
        {
          role: "user",
          content: prompt
        }
      ]
    });
    try {
      const responseText = message.content.map((block) => block.type === "text" ? block.text : "").join("");
      const jsonMatch = responseText.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
      throw new Error("No JSON found in response");
    } catch (error) {
      logger.error("Failed to parse validation response:", error);
      return {
        production_ready: false,
        revision_instructions: "Failed to parse validation response. Please review manually."
      };
    }
  }
  async getAllPluginFiles() {
    let content = "";
    const files = await fs.readdir(this.pluginPath, { recursive: true });
    for (const file of files) {
      if (typeof file !== "string") continue;
      const filePath = path.join(this.pluginPath, file);
      const stat2 = await fs.stat(filePath);
      if (stat2.isFile() && !file.includes("node_modules") && !file.includes(".git")) {
        const ext = path.extname(file);
        if ([".ts", ".js", ".json", ".md"].includes(ext)) {
          const fileContent = await fs.readFile(filePath, "utf-8");
          content += `
### File: ${file}
\`\`\`${ext.slice(1)}
${fileContent}
\`\`\`
`;
        }
      }
    }
    return content;
  }
  async copyToCWD() {
    const pluginName = path.basename(this.pluginPath);
    const targetPath = path.join(process.cwd(), pluginName);
    if (await fs.pathExists(targetPath)) {
      const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
      const backupPath = `${targetPath}-backup-${timestamp}`;
      logger.info(`Backing up existing ${pluginName} to ${path.basename(backupPath)}`);
      await fs.move(targetPath, backupPath);
    }
    logger.info(`Copying plugin to ${targetPath}`);
    await fs.copy(this.pluginPath, targetPath, {
      filter: (src) => {
        const relativePath = path.relative(this.pluginPath, src);
        return !relativePath.includes(".git") && !relativePath.includes("node_modules");
      }
    });
    return targetPath;
  }
  async checkDiskSpace() {
    const diskSpace = await this.getAvailableDiskSpace();
    if (diskSpace < MIN_DISK_SPACE_GB) {
      throw new Error(
        `Insufficient disk space. Need at least ${MIN_DISK_SPACE_GB}GB free, but only ${diskSpace.toFixed(2)}GB available.`
      );
    }
  }
  async getAvailableDiskSpace() {
    try {
      const result = await execa("df", ["-k", os.tmpdir()]);
      const lines = result.stdout.split("\n");
      const dataLine = lines[1];
      const parts = dataLine.split(/\s+/);
      const availableKB = parseInt(parts[3]);
      return availableKB / 1024 / 1024;
    } catch (error) {
      logger.warn("Could not check disk space, proceeding anyway");
      return MIN_DISK_SPACE_GB + 1;
    }
  }
};
export {
  PluginCreator
};
