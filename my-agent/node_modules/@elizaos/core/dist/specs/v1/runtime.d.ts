import { IAgentRuntime, UUID, IDatabaseAdapter, Character, Action, Evaluator, Provider, Plugin, IMemoryManager, Service, ServiceType, ModelProviderName, ICacheManager, Adapter, Memory, State, HandlerCallback } from './types.js';
import 'stream';

declare class AgentRuntime implements IAgentRuntime {
    private _runtime;
    get agentId(): UUID;
    get serverUrl(): string;
    get databaseAdapter(): IDatabaseAdapter;
    get token(): string;
    get character(): Character;
    get actions(): Action[];
    get evaluators(): Evaluator[];
    get providers(): Provider[];
    get plugins(): Plugin[];
    get modelProvider(): any;
    get imageModelProvider(): any;
    get imageVisionModelProvider(): any;
    get messageManager(): any;
    get routes(): any;
    get services(): any;
    get events(): any;
    get descriptionManager(): any;
    get documentsManager(): any;
    get knowledgeManager(): any;
    get ragKnowledgeManager(): any;
    get loreManager(): any;
    get cacheManager(): any;
    get clients(): any;
    registerMemoryManager(_manager: IMemoryManager): void;
    getMemoryManager(_tableName: string): any;
    getService<T extends Service>(service: ServiceType): T | null;
    registerService(service: Service): Promise<void>;
    /**
     * Creates an instance of AgentRuntime.
     * @param opts - The options for configuring the AgentRuntime.
     * @param opts.conversationLength - The number of messages to hold in the recent message cache.
     * @param opts.token - The JWT token, can be a JWT token if outside worker, or an OpenAI token if inside worker.
     * @param opts.serverUrl - The URL of the worker.
     * @param opts.actions - Optional custom actions.
     * @param opts.evaluators - Optional custom evaluators.
     * @param opts.services - Optional custom services.
     * @param opts.memoryManagers - Optional custom memory managers.
     * @param opts.providers - Optional context providers.
     * @param opts.model - The model to use for generateText.
     * @param opts.embeddingModel - The model to use for embedding.
     * @param opts.agentId - Optional ID of the agent.
     * @param opts.databaseAdapter - The database adapter used for interacting with the database.
     * @param opts.fetch - Custom fetch function to use for making requests.
     */
    constructor(opts: {
        conversationLength?: number;
        agentId?: UUID;
        character?: Character;
        token: string;
        serverUrl?: string;
        actions?: Action[];
        evaluators?: Evaluator[];
        plugins?: Plugin[];
        providers?: Provider[];
        modelProvider: ModelProviderName;
        services?: Service[];
        managers?: IMemoryManager[];
        databaseAdapter?: IDatabaseAdapter;
        fetch?: typeof fetch | unknown;
        speechModelPath?: string;
        cacheManager?: ICacheManager;
        logging?: boolean;
    });
    initialize(): Promise<any>;
    stop(): Promise<any>;
    getSetting(key: string): any;
    /**
     * Get the number of messages that are kept in the conversation buffer.
     * @returns The number of recent messages to be kept in memory.
     */
    getConversationLength(): any;
    /**
     * Register an action for the agent to perform.
     * @param action The action to register.
     */
    registerAction(action: Action): any;
    /**
     * Register an evaluator to assess and guide the agent's responses.
     * @param evaluator The evaluator to register.
     */
    registerEvaluator(evaluator: Evaluator): any;
    /**
     * Register a context provider to provide context for message generation.
     * @param provider The context provider to register.
     */
    registerContextProvider(provider: Provider): any;
    /**
     * Register an adapter for the agent to use.
     * @param adapter The adapter to register.
     */
    registerAdapter(_adapter: Adapter): void;
    /**
     * Process the actions of a message.
     * @param message The message to process.
     * @param content The content of the message to process actions from.
     */
    processActions(message: Memory, responses: Memory[], state?: State, callback?: HandlerCallback): Promise<void>;
    /**
     * Evaluate the message and state using the registered evaluators.
     * @param message The message to evaluate.
     * @param state The state of the agent.
     * @param didRespond Whether the agent responded to the message.~
     * @param callback The handler callback
     * @returns The results of the evaluation.
     */
    evaluate(message: Memory, state: State, didRespond?: boolean, callback?: HandlerCallback): Promise<any>;
    /**
     * Ensure the existence of a participant in the room. If the participant does not exist, they are added to the room.
     * @param userId - The user ID to ensure the existence of.
     * @throws An error if the participant cannot be added.
     */
    ensureParticipantExists(_userId: UUID, _roomId: UUID): Promise<void>;
    /**
     * Ensure the existence of a user in the database. If the user does not exist, they are added to the database.
     * @param userId - The user ID to ensure the existence of.
     * @param userName - The user name to ensure the existence of.
     * @returns
     */
    ensureUserExists(_userId: UUID, _userName: string | null, _name: string | null, _email?: string | null, _source?: string | null): Promise<void>;
    ensureParticipantInRoom(userId: UUID, roomId: UUID): Promise<any>;
    ensureConnection(userId: UUID, roomId: UUID, userName?: string, _userScreenName?: string, source?: string): Promise<any>;
    /**
     * Ensure the existence of a room between the agent and a user. If no room exists, a new room is created and the user
     * and agent are added as participants. The room ID is returned.
     * @param roomId - The room ID to create a room with.
     * @returns The room ID of the room between the agent and the user.
     * @throws An error if the room cannot be created.
     */
    ensureRoomExists(roomId: UUID): Promise<any>;
    /**
     * Compose the state of the agent into an object that can be passed or used for response generation.
     * @param message The message to compose the state from.
     * @returns The state of the agent.
     */
    composeState(message: Memory, _additionalKeys?: {
        [key: string]: unknown;
    }): Promise<any>;
    updateRecentMessageState(state: State): Promise<State>;
}

export { AgentRuntime };
