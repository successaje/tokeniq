import { M as Metadata, S as Service, T as TemplateType, a as State, b as Memory, E as Entity, I as IAgentRuntime, U as UUID, C as ContentType, c as Character, A as Action, d as IDatabaseAdapter, e as Component, L as Log, f as MemoryMetadata, W as World, R as Room, P as Participant, g as Relationship, h as Agent, i as Task, j as Role, k as Evaluator, l as Provider, m as Plugin, n as ServiceTypeName, o as ModelHandler, p as Route, q as RuntimeSettings, H as HandlerCallback, r as ChannelType, s as ModelTypeName, t as ModelResultMap, u as ModelParamsMap, v as TaskWorker, w as SendHandlerFunction, x as TargetInfo, y as Content, z as Setting, B as WorldSettings, O as OnboardingConfig, D as v2 } from './index-BPoUPiEk.js';
export { b9 as ActionEventPayload, al as ActionExample, ak as AgentStatus, aQ as AudioProcessingParams, Z as BaseMetadata, aI as BaseModelParams, af as CacheKeyPrefix, b6 as ChannelClearedPayload, ah as ChunkRow, bi as ControlMessage, a2 as CustomMetadata, a_ as DbConnection, a1 as DescriptionMetadata, aH as DetokenizeTextParams, ag as DirectoryItem, _ as DocumentMetadata, aU as EmbeddingSearchResult, Q as EnhancedState, b4 as EntityPayload, ao as EvaluationExample, ba as EvaluatorEventPayload, be as EventHandler, b2 as EventPayload, bd as EventPayloadMap, b0 as EventType, $ as FragmentMetadata, aG as GenerateTextParams, am as Handler, aN as ImageDescriptionParams, aM as ImageGenerationParams, b7 as InvokePayload, av as IsValidServiceType, aS as JSONSchema, ad as KnowledgeItem, ae as KnowledgeScope, G as Media, aV as MemoryRetrievalOptions, Y as MemoryScope, aW as MemorySearchOptions, X as MemoryType, V as MemoryTypeAlias, aj as MessageExample, a3 as MessageMemory, a0 as MessageMetadata, b5 as MessagePayload, bc as MessageReceivedHandlerParams, bb as ModelEventPayload, aF as ModelType, aX as MultiRoomMemoryOptions, aT as ObjectGenerationParams, b1 as PlatformPrefix, aq as PluginEvents, as as Project, ar as ProjectAgent, ap as ProviderResult, ai as RoomMetadata, b8 as RunEventPayload, bh as SOCKET_MESSAGE_TYPE, bl as ServiceBuilder, ax as ServiceClassMap, bn as ServiceDefinition, aD as ServiceError, ay as ServiceInstance, az as ServiceRegistry, aA as ServiceType, at as ServiceTypeRegistry, au as ServiceTypeValue, N as StateArray, K as StateObject, J as StateValue, bg as TaskMetadata, bj as TestCase, bk as TestSuite, aK as TextEmbeddingParams, aJ as TextGenerationParams, aP as TextToSpeechParams, aL as TokenizeTextParams, aO as TranscriptionParams, bf as TypedEventHandler, aB as TypedService, aw as TypedServiceClass, aY as UnifiedMemoryOptions, aZ as UnifiedSearchOptions, a$ as VECTOR_DIMS, an as Validator, aR as VideoProcessingParams, b3 as WorldPayload, F as asUUID, a4 as createMessageMemory, bm as createService, aE as createServiceError, bo as defineService, ac as getMemoryText, aC as getTypedService, a9 as isCustomMetadata, a8 as isDescriptionMetadata, aa as isDocumentMemory, a5 as isDocumentMetadata, ab as isFragmentMemory, a6 as isFragmentMetadata, a7 as isMessageMetadata } from './index-BPoUPiEk.js';
import { z } from 'zod';
import * as pino from 'pino';
import * as browser from '@sentry/browser';
export { browser as Sentry };
export { i as v1 } from './index-BHW44X0A.js';
import './types-BhMd7Ajo.js';
import './specs/v1/messages.js';
import './specs/v1/types.js';
import 'stream';
import './specs/v1/posts.js';
import './specs/v1/runtime.js';
import './specs/v1/state.js';
import './specs/v1/uuid.js';
import './specs/v1/actionExample.js';
import './specs/v1/provider.js';
import './specs/v1/templates.js';

/**
 * Represents an agent's registration details within a Trusted Execution Environment (TEE) context.
 * This is typically stored in a database table (e.g., `TeeAgent`) to manage agents operating in a TEE.
 * It allows for multiple registrations of the same `agentId` to support scenarios where an agent might restart,
 * generating a new keypair and attestation each time.
 */
interface TeeAgent {
    /** Primary key for the TEE agent registration record (e.g., a UUID or auto-incrementing ID). */
    id: string;
    /** The core identifier of the agent, which can be duplicated across multiple TEE registrations. */
    agentId: string;
    /** The human-readable name of the agent. */
    agentName: string;
    /** Timestamp (e.g., Unix epoch in milliseconds) when this TEE registration was created. */
    createdAt: number;
    /** The public key associated with this specific TEE agent instance/session. */
    publicKey: string;
    /** The attestation document proving the authenticity and integrity of the TEE instance. */
    attestation: string;
}
/**
 * Defines the operational modes for a Trusted Execution Environment (TEE).
 * This enum is used to configure how TEE functionalities are engaged, allowing for
 * different setups for local development, Docker-based development, and production.
 */
declare enum TEEMode {
    /** TEE functionality is completely disabled. */
    OFF = "OFF",
    /** For local development, potentially using a TEE simulator. */
    LOCAL = "LOCAL",// For local development with simulator
    /** For Docker-based development environments, possibly with a TEE simulator. */
    DOCKER = "DOCKER",// For docker development with simulator
    /** For production deployments, using actual TEE hardware without a simulator. */
    PRODUCTION = "PRODUCTION"
}
/**
 * Represents a quote obtained during remote attestation for a Trusted Execution Environment (TEE).
 * This quote is a piece of evidence provided by the TEE, cryptographically signed, which can be
 * verified by a relying party to ensure the TEE's integrity and authenticity.
 */
interface RemoteAttestationQuote {
    /** The attestation quote data, typically a base64 encoded string or similar format. */
    quote: string;
    /** Timestamp (e.g., Unix epoch in milliseconds) when the quote was generated or received. */
    timestamp: number;
}
/**
 * Data structure used in the attestation process for deriving a key within a Trusted Execution Environment (TEE).
 * This information helps establish a secure channel or verify the identity of the agent instance
 * requesting key derivation.
 */
interface DeriveKeyAttestationData {
    /** The unique identifier of the agent for which the key derivation is being attested. */
    agentId: string;
    /** The public key of the agent instance involved in the key derivation process. */
    publicKey: string;
    /** Optional subject or context information related to the key derivation. */
    subject?: string;
}
/**
 * Represents a message that has been attested by a Trusted Execution Environment (TEE).
 * This structure binds a message to an agent's identity and a timestamp, all within the
 * context of a remote attestation process, ensuring the message originated from a trusted TEE instance.
 */
interface RemoteAttestationMessage {
    /** The unique identifier of the agent sending the attested message. */
    agentId: string;
    /** Timestamp (e.g., Unix epoch in milliseconds) when the message was attested or sent. */
    timestamp: number;
    /** The actual message content, including details about the entity, room, and the content itself. */
    message: {
        entityId: string;
        roomId: string;
        content: string;
    };
}
/**
 * Enumerates different types or vendors of Trusted Execution Environments (TEEs).
 * This allows the system to adapt to specific TEE technologies, like Intel TDX on DSTACK.
 */
declare enum TeeType {
    /** Represents Intel Trusted Domain Extensions (TDX) running on DSTACK infrastructure. */
    TDX_DSTACK = "tdx_dstack"
}
/**
 * Configuration for a TEE (Trusted Execution Environment) plugin.
 * This allows specifying the TEE vendor and any vendor-specific configurations.
 * It's used to initialize and configure TEE-related functionalities within the agent system.
 */
interface TeePluginConfig {
    /** Optional. The name or identifier of the TEE vendor (e.g., 'tdx_dstack' from `TeeType`). */
    vendor?: string;
    /** Optional. Vendor-specific configuration options, conforming to `TeeVendorConfig`. */
    vendorConfig?: Metadata;
}

/**
 * A standardized representation of a token holding.
 */
interface TokenBalance {
    address: string;
    balance: string;
    decimals: number;
    uiAmount?: number;
    name?: string;
    symbol?: string;
    logoURI?: string;
}
/**
 * Generic representation of token data that can be provided by various services.
 */
interface TokenData {
    id: string;
    symbol: string;
    name: string;
    address: string;
    chain: string;
    sourceProvider: string;
    price?: number;
    priceChange24hPercent?: number;
    priceChange24hUSD?: number;
    volume24hUSD?: number;
    marketCapUSD?: number;
    liquidity?: number;
    holders?: number;
    logoURI?: string;
    decimals?: number;
    lastUpdatedAt?: Date;
    raw?: any;
}
/**
 * Interface for a generic service that provides token data.
 */
declare abstract class ITokenDataService extends Service {
    static readonly serviceType: "token_data";
    readonly capabilityDescription: string;
    /**
     * Fetches detailed information for a single token.
     * @param address The token's contract address.
     * @param chain The blockchain the token resides on.
     * @returns A Promise resolving to TokenData or null if not found.
     */
    abstract getTokenDetails(address: string, chain: string): Promise<TokenData | null>;
    /**
     * Fetches a list of trending tokens.
     * @param chain Optional: Filter by a specific blockchain.
     * @param limit Optional: Number of tokens to return. Defaults to a service-specific value.
     * @param timePeriod Optional: Time period for trending data (e.g., '24h', '7d'). Defaults to service-specific.
     * @returns A Promise resolving to an array of TokenData.
     */
    abstract getTrendingTokens(chain?: string, limit?: number, timePeriod?: string): Promise<TokenData[]>;
    /**
     * Searches for tokens based on a query string.
     * @param query The search query (e.g., symbol, name, address).
     * @param chain Optional: Filter by a specific blockchain.
     * @param limit Optional: Number of results to return.
     * @returns A Promise resolving to an array of TokenData.
     */
    abstract searchTokens(query: string, chain?: string, limit?: number): Promise<TokenData[]>;
    /**
     * Fetches data for multiple tokens by their addresses on a specific chain.
     * @param addresses Array of token contract addresses.
     * @param chain The blockchain the tokens reside on.
     * @returns A Promise resolving to an array of TokenData. May not include all requested if some are not found.
     */
    abstract getTokensByAddresses(addresses: string[], chain: string): Promise<TokenData[]>;
}

/**
 * Represents a single asset holding within a wallet, including its value.
 * This extends a generic TokenBalance with wallet-specific valuation.
 */
interface WalletAsset extends TokenBalance {
    priceUsd?: number;
    valueUsd?: number;
}
/**
 * Represents the entire portfolio of assets in a wallet.
 */
interface WalletPortfolio {
    totalValueUsd: number;
    assets: WalletAsset[];
}
/**
 * Abstract interface for a Wallet Service.
 * Plugins that provide wallet functionality (e.g., for Solana, EVM) should implement this service.
 * It provides a standardized way for other plugins to query the state of a wallet.
 */
declare abstract class IWalletService extends Service {
    static readonly serviceType: "wallet";
    readonly capabilityDescription = "Provides standardized access to wallet balances and portfolios.";
    /**
     * Retrieves the entire portfolio of assets held by the wallet.
     * @param owner - Optional: The specific wallet address/owner to query if the service manages multiple.
     * @returns A promise that resolves to the wallet's portfolio.
     */
    abstract getPortfolio(owner?: string): Promise<WalletPortfolio>;
    /**
     * Retrieves the balance of a specific asset in the wallet.
     * @param assetAddress - The mint address or native identifier of the asset.
     * @param owner - Optional: The specific wallet address/owner to query.
     * @returns A promise that resolves to the user-friendly (decimal-adjusted) balance of the asset held.
     */
    abstract getBalance(assetAddress: string, owner?: string): Promise<number>;
    /**
     * Transfers SOL from a specified keypair to a given public key.
     * This is a low-level function primarily for Solana-based wallet services.
     * @param from - The Keypair of the sender.
     * @param to - The PublicKey of the recipient.
     * @param lamports - The amount in lamports to transfer.
     * @returns A promise that resolves with the transaction signature.
     */
    abstract transferSol(from: any, to: any, lamports: number): Promise<string>;
}

/**
 * A standardized representation of a liquidity pool from any DEX.
 */
type PoolInfo = {
    id: string;
    displayName?: string;
    dex: string;
    tokenA: {
        mint: string;
        symbol?: string;
        reserve?: string;
        decimals?: number;
    };
    tokenB: {
        mint: string;
        symbol?: string;
        reserve?: string;
        decimals?: number;
    };
    lpTokenMint?: string;
    apr?: number;
    apy?: number;
    tvl?: number;
    fee?: number;
    metadata?: Metadata;
};
/**
 * A standardized representation of a user's position in a liquidity pool.
 */
type LpPositionDetails = {
    poolId: string;
    dex: string;
    lpTokenBalance: TokenBalance;
    underlyingTokens: TokenBalance[];
    valueUsd?: number;
    accruedFees?: TokenBalance[];
    rewards?: TokenBalance[];
    metadata?: Metadata;
};
/**
 * A standardized result for blockchain transactions.
 */
type TransactionResult = {
    success: boolean;
    transactionId?: string;
    error?: string;
    data?: any;
};
/**
 * Abstract interface for a Liquidity Pool Service.
 * DEX-specific plugins (e.g., for Orca, Raydium) must implement this service
 * to allow the LP Manager to interact with them in a standardized way.
 */
declare abstract class ILpService extends Service {
    static readonly serviceType = "lp";
    readonly capabilityDescription = "Provides standardized access to DEX liquidity pools.";
    /**
     * Returns the name of the DEX this service interacts with.
     * @returns The name of the DEX (e.g., "Orca", "Raydium").
     */
    abstract getDexName(): string;
    /**
     * Fetches a list of available liquidity pools from the DEX.
     * @param tokenAMint - Optional: Filter pools by the mint address of the first token.
     * @param tokenBMint - Optional: Filter pools by the mint address of the second token.
     * @returns A promise that resolves to an array of standardized PoolInfo objects.
     */
    abstract getPools(tokenAMint?: string, tokenBMint?: string): Promise<PoolInfo[]>;
    /**
     * Adds liquidity to a specified pool.
     * @param params - The parameters for adding liquidity.
     * @returns A promise resolving to a transaction result, including the LP tokens received.
     */
    abstract addLiquidity(params: {
        userVault: any;
        poolId: string;
        tokenAAmountLamports: string;
        tokenBAmountLamports?: string;
        slippageBps: number;
        tickLowerIndex?: number;
        tickUpperIndex?: number;
    }): Promise<TransactionResult & {
        lpTokensReceived?: TokenBalance;
    }>;
    /**
     * Removes liquidity from a specified pool.
     * @param params - The parameters for removing liquidity.
     * @returns A promise resolving to a transaction result, including the tokens received.
     */
    abstract removeLiquidity(params: {
        userVault: any;
        poolId: string;
        lpTokenAmountLamports: string;
        slippageBps: number;
    }): Promise<TransactionResult & {
        tokensReceived?: TokenBalance[];
    }>;
    /**
     * Fetches the details of a specific LP position for a user.
     * @param userAccountPublicKey - The user's wallet public key.
     * @param poolOrPositionIdentifier - The identifier for the pool or a specific position (e.g., position NFT mint).
     * @returns A promise resolving to the position details or null if not found.
     */
    abstract getLpPositionDetails(userAccountPublicKey: string, poolOrPositionIdentifier: string): Promise<LpPositionDetails | null>;
    /**
     * Fetches the latest market data (e.g., APY, TVL) for a list of pools.
     * @param poolIds - An array of pool IDs to fetch data for.
     * @returns A promise resolving to a map of pool IDs to their partial market data.
     */
    abstract getMarketDataForPools(poolIds: string[]): Promise<Record<string, Partial<PoolInfo>>>;
}

/**
 * Composes a context string by replacing placeholders in a template with corresponding values from the state.
 *
 * This function takes a template string with placeholders in the format `{{placeholder}}` and a state object.
 * It replaces each placeholder with the value from the state object that matches the placeholder's name.
 * If a matching key is not found in the state object for a given placeholder, the placeholder is replaced with an empty string.
 *
 * @param {Object} params - The parameters for composing the context.
 * @param {State} params.state - The state object containing values to replace the placeholders in the template.
 * @param {TemplateType} params.template - The template string or function containing placeholders to be replaced with state values.
 * @returns {string} The composed context string with placeholders replaced by corresponding state values.
 *
 * @example
 * // Given a state object and a template
 * const state = { userName: "Alice", userAge: 30 };
 * const template = "Hello, {{userName}}! You are {{userAge}} years old";
 *
 * // Composing the context with simple string replacement will result in:
 * // "Hello, Alice! You are 30 years old."
 * const contextSimple = composePromptFromState({ state, template });
 *
 * // Using composePromptFromState with a template function for dynamic template
 * const template = ({ state }) => {
 * const tone = Math.random() > 0.5 ? "kind" : "rude";
 *   return `Hello, {{userName}}! You are {{userAge}} years old. Be ${tone}`;
 * };
 * const contextSimple = composePromptFromState({ state, template });
 */
/**
 * Function to compose a prompt using a provided template and state.
 * It compiles the template (upgrading double braces to triple braces for non-HTML escaping)
 * and then populates it with values from the state. Additionally, it processes the
 * resulting string with `composeRandomUser` to replace placeholders like `{{nameX}}`.
 *
 * @param {Object} options - Object containing state and template information.
 * @param {State} options.state - The state object containing values to fill the template.
 * @param {TemplateType} options.template - The template string or function to be used for composing the prompt.
 * @returns {string} The composed prompt output, with state values and random user names populated.
 */
declare const composePrompt: ({ state, template, }: {
    state: {
        [key: string]: string;
    };
    template: TemplateType;
}) => string;
/**
 * Function to compose a prompt using a provided template and state.
 *
 * @param {Object} options - Object containing state and template information.
 * @param {State} options.state - The state object containing values to fill the template.
 * @param {TemplateType} options.template - The template to be used for composing the prompt.
 * @returns {string} The composed prompt output.
 */
declare const composePromptFromState: ({ state, template, }: {
    state: State;
    template: TemplateType;
}) => string;
/**
 * Adds a header to a body of text.
 *
 * This function takes a header string and a body string and returns a new string with the header prepended to the body.
 * If the body string is empty, the header is returned as is.
 *
 * @param {string} header - The header to add to the body.
 * @param {string} body - The body to which to add the header.
 * @returns {string} The body with the header prepended.
 *
 * @example
 * // Given a header and a body
 * const header = "Header";
 * const body = "Body";
 *
 * // Adding the header to the body will result in:
 * // "Header\nBody"
 * const text = addHeader(header, body);
 */
declare const addHeader: (header: string, body: string) => string;
declare const formatPosts: ({ messages, entities, conversationHeader, }: {
    messages: Memory[];
    entities: Entity[];
    conversationHeader?: boolean;
}) => string;
/**
 * Format messages into a string
 * @param {Object} params - The formatting parameters
 * @param {Memory[]} params.messages - List of messages to format
 * @param {Entity[]} params.entities - List of entities for name resolution
 * @returns {string} Formatted message string with timestamps and user information
 */
declare const formatMessages: ({ messages, entities, }: {
    messages: Memory[];
    entities: Entity[];
}) => string;
declare const formatTimestamp: (messageDate: number) => string;
/**
 * Parses key-value pairs from a simple XML structure within a given text.
 * It looks for an XML block (e.g., <response>...</response>) and extracts
 * text content from direct child elements (e.g., <key>value</key>).
 *
 * Note: This uses regex and is suitable for simple, predictable XML structures.
 * For complex XML, a proper parsing library is recommended.
 *
 * @param text - The input text containing the XML structure.
 * @returns An object with key-value pairs extracted from the XML, or null if parsing fails.
 */
declare function parseKeyValueXml(text: string): Record<string, any> | null;
/**
 * Parses a JSON object from a given text. The function looks for a JSON block wrapped in triple backticks
 * with `json` language identifier, and if not found, it searches for an object pattern within the text.
 * It then attempts to parse the JSON string into a JavaScript object. If parsing is successful and the result
 * is an object (but not an array), it returns the object; otherwise, it tries to parse an array if the result
 * is an array, or returns null if parsing is unsuccessful or the result is neither an object nor an array.
 *
 * @param text - The input text from which to extract and parse the JSON object.
 * @returns An object parsed from the JSON string if successful; otherwise, null or the result of parsing an array.
 */
declare function parseJSONObjectFromText(text: string): Record<string, any> | null;
/**
 * Normalizes a JSON-like string by correcting formatting issues:
 * - Removes extra spaces after '{' and before '}'.
 * - Wraps unquoted values in double quotes.
 * - Converts single-quoted values to double-quoted.
 * - Ensures consistency in key-value formatting.
 * - Normalizes mixed adjacent quote pairs.
 *
 * This is useful for cleaning up improperly formatted JSON strings
 * before parsing them into valid JSON.
 *
 * @param str - The JSON-like string to normalize.
 * @returns A properly formatted JSON string.
 */
declare const normalizeJsonString: (str: string) => string;
/**
 * Truncate text to fit within the character limit, ensuring it ends at a complete sentence.
 */
declare function truncateToCompleteSentence(text: string, maxLength: number): string;
declare function splitChunks(content: string, chunkSize?: number, bleed?: number): Promise<string[]>;
/**
 * Trims the provided text prompt to a specified token limit using a tokenizer model and type.
 */
declare function trimTokens(prompt: string, maxTokens: number, runtime: IAgentRuntime): Promise<string>;
declare function safeReplacer(): (_key: string, value: any) => any;
/**
 * Parses a string to determine its boolean equivalent.
 *
 * Recognized affirmative values: "YES", "Y", "TRUE", "T", "1", "ON", "ENABLE"
 * Recognized negative values: "NO", "N", "FALSE", "F", "0", "OFF", "DISABLE"
 *
 * @param {string | undefined | null} value - The input text to parse
 * @returns {boolean} - Returns `true` for affirmative inputs, `false` for negative or unrecognized inputs
 */
declare function parseBooleanFromText(value: string | undefined | null): boolean;
/**
 * Validates a UUID value.
 *
 * @param {unknown} value - The value to validate.
 * @returns {UUID | null} Returns the validated UUID value or null if validation fails.
 */
declare function validateUuid(value: unknown): UUID | null;
/**
 * Converts a string or number to a UUID.
 *
 * @param {string | number} target - The string or number to convert to a UUID.
 * @returns {UUID} The UUID generated from the input target.
 * @throws {TypeError} Throws an error if the input target is not a string.
 */
declare function stringToUuid(target: string | number): UUID;
declare const getContentTypeFromMimeType: (mimeType: string) => ContentType | undefined;
declare function getLocalServerUrl(path: string): string;

declare const characterSchema: z.ZodObject<{
    id: z.ZodOptional<z.ZodString>;
    name: z.ZodString;
    username: z.ZodOptional<z.ZodString>;
    system: z.ZodOptional<z.ZodString>;
    templates: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodFunction<z.ZodTuple<[], z.ZodUnknown>, z.ZodUnknown>>]>>>;
    bio: z.ZodUnion<[z.ZodString, z.ZodArray<z.ZodString, "many">]>;
    messageExamples: z.ZodOptional<z.ZodArray<z.ZodArray<z.ZodObject<{
        name: z.ZodString;
        content: z.ZodObject<{
            text: z.ZodOptional<z.ZodString>;
            thought: z.ZodOptional<z.ZodString>;
            actions: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            providers: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            source: z.ZodOptional<z.ZodString>;
            target: z.ZodOptional<z.ZodString>;
            url: z.ZodOptional<z.ZodString>;
            inReplyTo: z.ZodOptional<z.ZodString>;
            attachments: z.ZodOptional<z.ZodArray<z.ZodAny, "many">>;
            channelType: z.ZodOptional<z.ZodString>;
        }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
            text: z.ZodOptional<z.ZodString>;
            thought: z.ZodOptional<z.ZodString>;
            actions: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            providers: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            source: z.ZodOptional<z.ZodString>;
            target: z.ZodOptional<z.ZodString>;
            url: z.ZodOptional<z.ZodString>;
            inReplyTo: z.ZodOptional<z.ZodString>;
            attachments: z.ZodOptional<z.ZodArray<z.ZodAny, "many">>;
            channelType: z.ZodOptional<z.ZodString>;
        }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
            text: z.ZodOptional<z.ZodString>;
            thought: z.ZodOptional<z.ZodString>;
            actions: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            providers: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            source: z.ZodOptional<z.ZodString>;
            target: z.ZodOptional<z.ZodString>;
            url: z.ZodOptional<z.ZodString>;
            inReplyTo: z.ZodOptional<z.ZodString>;
            attachments: z.ZodOptional<z.ZodArray<z.ZodAny, "many">>;
            channelType: z.ZodOptional<z.ZodString>;
        }, z.ZodTypeAny, "passthrough">>;
    }, "strip", z.ZodTypeAny, {
        name?: string;
        content?: {
            thought?: string;
            text?: string;
            actions?: string[];
            providers?: string[];
            source?: string;
            target?: string;
            url?: string;
            inReplyTo?: string;
            attachments?: any[];
            channelType?: string;
        } & {
            [k: string]: unknown;
        };
    }, {
        name?: string;
        content?: {
            thought?: string;
            text?: string;
            actions?: string[];
            providers?: string[];
            source?: string;
            target?: string;
            url?: string;
            inReplyTo?: string;
            attachments?: any[];
            channelType?: string;
        } & {
            [k: string]: unknown;
        };
    }>, "many">, "many">>;
    postExamples: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    topics: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    adjectives: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    knowledge: z.ZodOptional<z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodObject<{
        path: z.ZodString;
        shared: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        shared?: boolean;
        path?: string;
    }, {
        shared?: boolean;
        path?: string;
    }>, z.ZodObject<{
        directory: z.ZodString;
        shared: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        shared?: boolean;
        directory?: string;
    }, {
        shared?: boolean;
        directory?: string;
    }>]>, "many">>;
    plugins: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    settings: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodString, z.ZodBoolean, z.ZodNumber, z.ZodAny]>>>;
    secrets: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodString, z.ZodBoolean, z.ZodNumber]>>>;
    style: z.ZodOptional<z.ZodObject<{
        all: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        chat: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        post: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, "strip", z.ZodTypeAny, {
        all?: string[];
        chat?: string[];
        post?: string[];
    }, {
        all?: string[];
        chat?: string[];
        post?: string[];
    }>>;
}, "strict", z.ZodTypeAny, {
    knowledge?: (string | {
        shared?: boolean;
        directory?: string;
    } | {
        shared?: boolean;
        path?: string;
    })[];
    username?: string;
    name?: string;
    id?: string;
    system?: string;
    templates?: Record<string, string | ((...args: unknown[]) => unknown)>;
    bio?: string | string[];
    messageExamples?: {
        name?: string;
        content?: {
            thought?: string;
            text?: string;
            actions?: string[];
            providers?: string[];
            source?: string;
            target?: string;
            url?: string;
            inReplyTo?: string;
            attachments?: any[];
            channelType?: string;
        } & {
            [k: string]: unknown;
        };
    }[][];
    postExamples?: string[];
    topics?: string[];
    adjectives?: string[];
    plugins?: string[];
    settings?: Record<string, any>;
    secrets?: Record<string, string | number | boolean>;
    style?: {
        all?: string[];
        chat?: string[];
        post?: string[];
    };
}, {
    knowledge?: (string | {
        shared?: boolean;
        directory?: string;
    } | {
        shared?: boolean;
        path?: string;
    })[];
    username?: string;
    name?: string;
    id?: string;
    system?: string;
    templates?: Record<string, string | ((...args: unknown[]) => unknown)>;
    bio?: string | string[];
    messageExamples?: {
        name?: string;
        content?: {
            thought?: string;
            text?: string;
            actions?: string[];
            providers?: string[];
            source?: string;
            target?: string;
            url?: string;
            inReplyTo?: string;
            attachments?: any[];
            channelType?: string;
        } & {
            [k: string]: unknown;
        };
    }[][];
    postExamples?: string[];
    topics?: string[];
    adjectives?: string[];
    plugins?: string[];
    settings?: Record<string, any>;
    secrets?: Record<string, string | number | boolean>;
    style?: {
        all?: string[];
        chat?: string[];
        post?: string[];
    };
}>;
interface CharacterValidationResult {
    success: boolean;
    data?: Character;
    error?: {
        message: string;
        issues?: z.ZodIssue[];
    };
}
/**
 * Safely validates character data using Zod schema
 * @param data - Raw character data to validate
 * @returns Validation result with success flag and either data or error
 */
declare function validateCharacter(data: unknown): CharacterValidationResult;
/**
 * Safely parses JSON string and validates as character
 * @param jsonString - JSON string to parse and validate
 * @returns Validation result with success flag and either data or error
 */
declare function parseAndValidateCharacter(jsonString: string): CharacterValidationResult;
/**
 * Type guard to check if data is a valid Character
 * @param data - Data to check
 * @returns True if data is a valid Character
 */
declare function isValidCharacter(data: unknown): data is Character;

/**
 * Composes a set of example conversations based on provided actions and a specified count.
 * It randomly selects examples from the provided actions and formats them with generated names.
 *
 * @param actionsData - An array of `Action` objects from which to draw examples.
 * @param count - The number of examples to generate.
 * @returns A string containing formatted examples of conversations.
 */
declare const composeActionExamples: (actionsData: Action[], count: number) => string;
/**
 * Formats the names of the provided actions into a comma-separated string.
 * @param actions - An array of `Action` objects from which to extract names.
 * @returns A comma-separated string of action names.
 */
declare function formatActionNames(actions: Action[]): string;
/**
 * Formats the provided actions into a detailed string listing each action's name and description.
 * @param actions - An array of `Action` objects to format.
 * @returns A detailed string of actions, including names and descriptions.
 */
declare function formatActions(actions: Action[]): string;

/**
 * An abstract class representing a database adapter for managing various entities
 * like entities, memories, entities, goals, and rooms.
 */
/**
 * Database adapter class to be extended by individual database adapters.
 *
 * @template DB - The type of the database instance.
 * @abstract
 * implements IDatabaseAdapter
 */
declare abstract class DatabaseAdapter<DB = unknown> implements IDatabaseAdapter {
    /**
     * The database instance.
     */
    db: DB;
    /**
     * Initialize the database adapter.
     * @returns A Promise that resolves when initialization is complete.
     */
    abstract initialize(config?: any): Promise<void>;
    /**
     * Initialize the database adapter.
     * @returns A Promise that resolves when initialization is complete.
     */
    abstract init(): Promise<void>;
    /**
     * Run database migrations
     * @param migrationsPaths Optional array of paths to migration folders
     * @returns A Promise that resolves when migrations are complete.
     */
    abstract runMigrations(migrationsPaths?: string[]): Promise<void>;
    /**
     * Check if the database connection is ready.
     * @returns A Promise that resolves to true if the database is ready, false otherwise.
     */
    abstract isReady(): Promise<boolean>;
    /**
     * Optional close method for the database adapter.
     * @returns A Promise that resolves when closing is complete.
     */
    abstract close(): Promise<void>;
    /**
     * Retrieves a connection to the database.
     * @returns A Promise that resolves to the database connection.
     */
    abstract getConnection(): Promise<unknown>;
    /**
     * Retrieves an account by its ID.
     * @param entityIds The UUIDs of the user account to retrieve.
     * @returns A Promise that resolves to the Entity object or null if not found.
     */
    abstract getEntityByIds(entityIds: UUID[]): Promise<Entity[] | null>;
    abstract getEntitiesForRoom(roomId: UUID, includeComponents?: boolean): Promise<Entity[]>;
    /**
     * Creates a new entities in the database.
     * @param entities The entity objects to create.
     * @returns A Promise that resolves when the account creation is complete.
     */
    abstract createEntities(entities: Entity[]): Promise<boolean>;
    /**
     * Updates an existing entity in the database.
     * @param entity The entity object with updated properties.
     * @returns A Promise that resolves when the account update is complete.
     */
    abstract updateEntity(entity: Entity): Promise<void>;
    /**
     * Retrieves a single component by entity ID and type.
     * @param entityId The UUID of the entity the component belongs to
     * @param type The type identifier for the component
     * @param worldId Optional UUID of the world the component belongs to
     * @param sourceEntityId Optional UUID of the source entity
     * @returns Promise resolving to the Component if found, null otherwise
     */
    abstract getComponent(entityId: UUID, type: string, worldId?: UUID, sourceEntityId?: UUID): Promise<Component | null>;
    /**
     * Retrieves all components for an entity.
     * @param entityId The UUID of the entity to get components for
     * @param worldId Optional UUID of the world to filter components by
     * @param sourceEntityId Optional UUID of the source entity to filter by
     * @returns Promise resolving to array of Component objects
     */
    abstract getComponents(entityId: UUID, worldId?: UUID, sourceEntityId?: UUID): Promise<Component[]>;
    /**
     * Creates a new component in the database.
     * @param component The component object to create
     * @returns Promise resolving to true if creation was successful
     */
    abstract createComponent(component: Component): Promise<boolean>;
    /**
     * Updates an existing component in the database.
     * @param component The component object with updated properties
     * @returns Promise that resolves when the update is complete
     */
    abstract updateComponent(component: Component): Promise<void>;
    /**
     * Deletes a component from the database.
     * @param componentId The UUID of the component to delete
     * @returns Promise that resolves when the deletion is complete
     */
    abstract deleteComponent(componentId: UUID): Promise<void>;
    /**
     * Retrieves memories based on the specified parameters.
     * @param params An object containing parameters for the memory retrieval.
     * @returns A Promise that resolves to an array of Memory objects.
     */
    abstract getMemories(params: {
        entityId?: UUID;
        agentId?: UUID;
        count?: number;
        unique?: boolean;
        tableName: string;
        start?: number;
        end?: number;
        roomId?: UUID;
        worldId?: UUID;
    }): Promise<Memory[]>;
    abstract getMemoriesByRoomIds(params: {
        roomIds: UUID[];
        tableName: string;
        limit?: number;
    }): Promise<Memory[]>;
    abstract getMemoryById(id: UUID): Promise<Memory | null>;
    /**
     * Retrieves multiple memories by their IDs
     * @param memoryIds Array of UUIDs of the memories to retrieve
     * @param tableName Optional table name to filter memories by type
     * @returns Promise resolving to array of Memory objects
     */
    abstract getMemoriesByIds(memoryIds: UUID[], tableName?: string): Promise<Memory[]>;
    /**
     * Retrieves cached embeddings based on the specified query parameters.
     * @param params An object containing parameters for the embedding retrieval.
     * @returns A Promise that resolves to an array of objects containing embeddings and levenshtein scores.
     */
    abstract getCachedEmbeddings({ query_table_name, query_threshold, query_input, query_field_name, query_field_sub_name, query_match_count, }: {
        query_table_name: string;
        query_threshold: number;
        query_input: string;
        query_field_name: string;
        query_field_sub_name: string;
        query_match_count: number;
    }): Promise<{
        embedding: number[];
        levenshtein_score: number;
    }[]>;
    /**
     * Logs an event or action with the specified details.
     * @param params An object containing parameters for the log entry.
     * @returns A Promise that resolves when the log entry has been saved.
     */
    abstract log(params: {
        body: {
            [key: string]: unknown;
        };
        entityId: UUID;
        roomId: UUID;
        type: string;
    }): Promise<void>;
    /**
     * Retrieves logs based on the specified parameters.
     * @param params An object containing parameters for the log retrieval.
     * @returns A Promise that resolves to an array of Log objects.
     */
    abstract getLogs(params: {
        entityId: UUID;
        roomId?: UUID;
        type?: string;
        count?: number;
        offset?: number;
    }): Promise<Log[]>;
    /**
     * Deletes a log from the database.
     * @param logId The UUID of the log to delete.
     * @returns A Promise that resolves when the log has been deleted.
     */
    abstract deleteLog(logId: UUID): Promise<void>;
    /**
     * Searches for memories based on embeddings and other specified parameters.
     * @param params An object containing parameters for the memory search.
     * @returns A Promise that resolves to an array of Memory objects.
     */
    abstract searchMemories(params: {
        tableName: string;
        embedding: number[];
        match_threshold?: number;
        count?: number;
        unique?: boolean;
        query?: string;
        roomId?: UUID;
        worldId?: UUID;
        entityId?: UUID;
    }): Promise<Memory[]>;
    /**
     * Creates a new memory in the database.
     * @param memory The memory object to create.
     * @param tableName The table where the memory should be stored.
     * @param unique Indicates if the memory should be unique.
     * @returns A Promise that resolves when the memory has been created.
     */
    abstract createMemory(memory: Memory, tableName: string, unique?: boolean): Promise<UUID>;
    /**
     * Updates an existing memory in the database.
     * @param memory The memory object with updated content and optional embedding
     * @returns Promise resolving to boolean indicating success
     */
    abstract updateMemory(memory: Partial<Memory> & {
        id: UUID;
        metadata?: MemoryMetadata;
    }): Promise<boolean>;
    /**
     * Removes a specific memory from the database.
     * @param memoryId The UUID of the memory to remove.
     * @returns A Promise that resolves when the memory has been removed.
     */
    abstract deleteMemory(memoryId: UUID): Promise<void>;
    /**
     * Removes multiple memories from the database in a single batch operation.
     * @param memoryIds An array of UUIDs of the memories to remove.
     * @returns A Promise that resolves when all memories have been removed.
     */
    abstract deleteManyMemories(memoryIds: UUID[]): Promise<void>;
    /**
     * Removes all memories associated with a specific room.
     * @param roomId The UUID of the room whose memories should be removed.
     * @param tableName The table from which the memories should be removed.
     * @returns A Promise that resolves when all memories have been removed.
     */
    abstract deleteAllMemories(roomId: UUID, tableName: string): Promise<void>;
    /**
     * Counts the number of memories in a specific room.
     * @param roomId The UUID of the room for which to count memories.
     * @param unique Specifies whether to count only unique memories.
     * @param tableName Optional table name to count memories from.
     * @returns A Promise that resolves to the number of memories.
     */
    abstract countMemories(roomId: UUID, unique?: boolean, tableName?: string): Promise<number>;
    /**
     * Retrieves a world by its ID.
     * @param id The UUID of the world to retrieve.
     * @returns A Promise that resolves to the World object or null if not found.
     */
    abstract getWorld(id: UUID): Promise<World | null>;
    /**
     * Retrieves all worlds for an agent.
     * @returns A Promise that resolves to an array of World objects.
     */
    abstract getAllWorlds(): Promise<World[]>;
    /**
     * Creates a new world in the database.
     * @param world The world object to create.
     * @returns A Promise that resolves to the UUID of the created world.
     */
    abstract createWorld(world: World): Promise<UUID>;
    /**
     * Updates an existing world in the database.
     * @param world The world object with updated properties.
     * @returns A Promise that resolves when the world has been updated.
     */
    abstract updateWorld(world: World): Promise<void>;
    /**
     * Removes a specific world from the database.
     * @param id The UUID of the world to remove.
     * @returns A Promise that resolves when the world has been removed.
     */
    abstract removeWorld(id: UUID): Promise<void>;
    /**
     * Retrieves the room ID for a given room, if it exists.
     * @param roomId The UUID of the room to retrieve.
     * @returns A Promise that resolves to the room ID or null if not found.
     */
    abstract getRoomsByIds(roomIds: UUID[]): Promise<Room[] | null>;
    /**
     * Retrieves all rooms for a given world.
     * @param worldId The UUID of the world to retrieve rooms for.
     * @returns A Promise that resolves to an array of Room objects.
     */
    abstract getRoomsByWorld(worldId: UUID): Promise<Room[]>;
    /**
     * Creates a new rooms with an optional specified ID.
     * @param roomId Optional UUID to assign to the new room.
     * @returns A Promise that resolves to the UUID of the created rooms.
     */
    abstract createRooms(rooms: Room[]): Promise<UUID[]>;
    /**
     * Updates a specific room in the database.
     * @param room The room object with updated properties.
     * @returns A Promise that resolves when the room has been updated.
     */
    abstract updateRoom(room: Room): Promise<void>;
    /**
     * Removes a specific room from the database.
     * @param roomId The UUID of the room to remove.
     * @returns A Promise that resolves when the room has been removed.
     */
    abstract deleteRoom(roomId: UUID): Promise<void>;
    /**
     * Retrieves room IDs for which a specific user is a participant.
     * @param entityId The UUID of the user.
     * @returns A Promise that resolves to an array of room IDs.
     */
    abstract getRoomsForParticipant(entityId: UUID): Promise<UUID[]>;
    /**
     * Retrieves room IDs for which specific users are participants.
     * @param userIds An array of UUIDs of the users.
     * @returns A Promise that resolves to an array of room IDs.
     */
    abstract getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]>;
    /**
     * Adds users as a participant to a specific room.
     * @param entityIds The UUIDs of the users to add as a participant.
     * @param roomId The UUID of the room to which the user will be added.
     * @returns A Promise that resolves to a boolean indicating success or failure.
     */
    abstract addParticipantsRoom(entityIds: UUID[], roomId: UUID): Promise<boolean>;
    /**
     * Removes a user as a participant from a specific room.
     * @param entityId The UUID of the user to remove as a participant.
     * @param roomId The UUID of the room from which the user will be removed.
     * @returns A Promise that resolves to a boolean indicating success or failure.
     */
    abstract removeParticipant(entityId: UUID, roomId: UUID): Promise<boolean>;
    /**
     * Retrieves participants associated with a specific account.
     * @param entityId The UUID of the account.
     * @returns A Promise that resolves to an array of Participant objects.
     */
    abstract getParticipantsForEntity(entityId: UUID): Promise<Participant[]>;
    /**
     * Retrieves participants for a specific room.
     * @param roomId The UUID of the room for which to retrieve participants.
     * @returns A Promise that resolves to an array of UUIDs representing the participants.
     */
    abstract getParticipantsForRoom(roomId: UUID): Promise<UUID[]>;
    abstract getParticipantUserState(roomId: UUID, entityId: UUID): Promise<'FOLLOWED' | 'MUTED' | null>;
    abstract setParticipantUserState(roomId: UUID, entityId: UUID, state: 'FOLLOWED' | 'MUTED' | null): Promise<void>;
    /**
     * Creates a new relationship between two users.
     * @param params Object containing the relationship details including entity IDs, agent ID, optional tags and metadata
     * @returns A Promise that resolves to a boolean indicating success or failure of the creation.
     */
    abstract createRelationship(params: {
        sourceEntityId: UUID;
        targetEntityId: UUID;
        tags?: string[];
        metadata?: Record<string, unknown>;
    }): Promise<boolean>;
    /**
     * Retrieves a relationship between two users if it exists.
     * @param params Object containing the entity IDs and agent ID
     * @returns A Promise that resolves to the Relationship object or null if not found.
     */
    abstract getRelationship(params: {
        sourceEntityId: UUID;
        targetEntityId: UUID;
    }): Promise<Relationship | null>;
    /**
     * Retrieves all relationships for a specific user.
     * @param params Object containing the user ID, agent ID and optional tags to filter by
     * @returns A Promise that resolves to an array of Relationship objects.
     */
    abstract getRelationships(params: {
        entityId: UUID;
        tags?: string[];
    }): Promise<Relationship[]>;
    /**
     * Updates an existing relationship between two users.
     * @param params Object containing the relationship details to update including entity IDs, agent ID, optional tags and metadata
     * @returns A Promise that resolves to a boolean indicating success or failure of the update.
     */
    abstract updateRelationship(params: {
        sourceEntityId: UUID;
        targetEntityId: UUID;
        tags?: string[];
        metadata?: Record<string, unknown>;
    }): Promise<void>;
    /**
     * Retrieves an agent by its ID.
     * @param agentId The UUID of the agent to retrieve.
     * @returns A Promise that resolves to the Agent object or null if not found.
     */
    abstract getAgent(agentId: UUID): Promise<Agent | null>;
    /**
     * Retrieves all agents from the database.
     * @returns A Promise that resolves to an array of Agent objects.
     */
    abstract getAgents(): Promise<Partial<Agent>[]>;
    /**
     * Creates a new agent in the database.
     * @param agent The agent object to create.
     * @returns A Promise that resolves to a boolean indicating success or failure of the creation.
     */
    abstract createAgent(agent: Partial<Agent>): Promise<boolean>;
    /**
     * Updates an existing agent in the database.
     * @param agentId The UUID of the agent to update.
     * @param agent The agent object with updated properties.
     * @returns A Promise that resolves to a boolean indicating success or failure of the update.
     */
    abstract updateAgent(agentId: UUID, agent: Partial<Agent>): Promise<boolean>;
    /**
     * Deletes an agent from the database.
     * @param agentId The UUID of the agent to delete.
     * @returns A Promise that resolves to a boolean indicating success or failure of the deletion.
     */
    abstract deleteAgent(agentId: UUID): Promise<boolean>;
    /**
     * Ensures an embedding dimension exists in the database.
     * @param dimension The dimension to ensure exists.
     * @returns A Promise that resolves when the embedding dimension has been ensured to exist.
     */
    abstract ensureEmbeddingDimension(dimension: number): Promise<void>;
    /**
     * Retrieves a cached value by key from the database.
     * @param key The key to look up in the cache
     * @returns Promise resolving to the cached string value
     */
    abstract getCache<T>(key: string): Promise<T | undefined>;
    /**
     * Sets a value in the cache with the given key.
     * @param params Object containing the cache key and value
     * @param key The key to store the value under
     * @param value The string value to cache
     * @returns Promise resolving to true if the cache was set successfully
     */
    abstract setCache<T>(key: string, value: T): Promise<boolean>;
    /**
     * Deletes a value from the cache by key.
     * @param key The key to delete from the cache
     * @returns Promise resolving to true if the value was successfully deleted
     */
    abstract deleteCache(key: string): Promise<boolean>;
    /**
     * Creates a new task instance in the database.
     * @param task The task object to create
     * @returns Promise resolving to the UUID of the created task
     */
    abstract createTask(task: Task): Promise<UUID>;
    /**
     * Retrieves tasks based on specified parameters.
     * @param params Object containing optional roomId and tags to filter tasks
     * @returns Promise resolving to an array of Task objects
     */
    abstract getTasks(params: {
        roomId?: UUID;
        tags?: string[];
        entityId?: UUID;
    }): Promise<Task[]>;
    /**
     * Retrieves a specific task by its ID.
     * @param id The UUID of the task to retrieve
     * @returns Promise resolving to the Task object if found, null otherwise
     */
    abstract getTask(id: UUID): Promise<Task | null>;
    /**
     * Retrieves a specific task by its name.
     * @param name The name of the task to retrieve
     * @returns Promise resolving to the Task object if found, null otherwise
     */
    abstract getTasksByName(name: string): Promise<Task[]>;
    /**
     * Updates an existing task in the database.
     * @param id The UUID of the task to update
     * @param task Partial Task object containing the fields to update
     * @returns Promise resolving when the update is complete
     */
    abstract updateTask(id: UUID, task: Partial<Task>): Promise<void>;
    /**
     * Deletes a task from the database.
     * @param id The UUID of the task to delete
     * @returns Promise resolving when the deletion is complete
     */
    abstract deleteTask(id: UUID): Promise<void>;
    abstract getMemoriesByWorldId(params: {
        worldId: UUID;
        count?: number;
        tableName?: string;
    }): Promise<Memory[]>;
    abstract deleteRoomsByWorldId(worldId: UUID): Promise<void>;
}

/**
 * Finds an entity by name in the given runtime environment.
 *
 * @param {IAgentRuntime} runtime - The agent runtime environment.
 * @param {Memory} message - The memory message containing relevant information.
 * @param {State} state - The current state of the system.
 * @returns {Promise<Entity | null>} A promise that resolves to the found entity or null if not found.
 */
declare function findEntityByName(runtime: IAgentRuntime, message: Memory, state: State): Promise<Entity | null>;
/**
 * Function to create a unique UUID based on the runtime and base user ID.
 *
 * @param {RuntimeContext} runtime - The runtime context object.
 * @param {UUID|string} baseUserId - The base user ID to use in generating the UUID.
 * @returns {UUID} - The unique UUID generated based on the runtime and base user ID.
 */
declare const createUniqueUuid: (runtime: any, baseUserId: UUID | string) => UUID;
/**
 * Get details for a list of entities.
 */
/**
 * Retrieves entity details for a specific room from the database.
 *
 * @param {Object} params - The input parameters
 * @param {IAgentRuntime} params.runtime - The Agent Runtime instance
 * @param {UUID} params.roomId - The ID of the room to retrieve entity details for
 * @returns {Promise<Array>} - A promise that resolves to an array of unique entity details
 */
declare function getEntityDetails({ runtime, roomId, }: {
    runtime: IAgentRuntime;
    roomId: UUID;
}): Promise<any[]>;
/**
 * Format entities into a string
 * @param entities - list of entities
 * @returns string
 */
/**
 * Format the given entities into a string representation.
 *
 * @param {Object} options - The options object.
 * @param {Entity[]} options.entities - The list of entities to format.
 * @returns {string} A formatted string representing the entities.
 */
declare function formatEntities({ entities }: {
    entities: Entity[];
}): string;

declare const createLogger: (bindings?: any | boolean) => pino.Logger<never, boolean>;
declare let logger: pino.Logger<string, boolean>;

declare const elizaLogger: pino.Logger<string, boolean>;

declare const shouldRespondTemplate = "<task>Decide on behalf of {{agentName}} whether they should respond to the message, ignore it or stop the conversation.</task>\n\n<providers>\n{{providers}}\n</providers>\n\n<instructions>Decide if {{agentName}} should respond to or interact with the conversation.\nIf the message is directed at or relevant to {{agentName}}, respond with RESPOND action.\nIf a user asks {{agentName}} to be quiet, respond with STOP action.\nIf {{agentName}} should ignore the message, respond with IGNORE action.</instructions>\n\n<output>\nDo NOT include any thinking, reasoning, or <think> sections in your response. \nGo directly to the XML response format without any preamble or explanation.\n\nRespond using XML format like this:\n<response>\n  <name>{{agentName}}</name>\n  <reasoning>Your reasoning here</reasoning>\n  <action>RESPOND | IGNORE | STOP</action>\n</response>\n\nIMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.\n</output>";
declare const messageHandlerTemplate = "<task>Generate dialog and actions for the character {{agentName}}.</task>\n\n<providers>\n{{providers}}\n</providers>\n\nThese are the available valid actions:\n<actionNames>\n{{actionNames}}\n</actionNames>\n\n<instructions>\nWrite a thought and plan for {{agentName}} and decide what actions to take. Also include the providers that {{agentName}} will use to have the right context for responding and acting, if any.\n\nIMPORTANT ACTION ORDERING RULES:\n- Actions are executed in the ORDER you list them - the order MATTERS!\n- REPLY should come FIRST to acknowledge the user's request before executing other actions\n- Common patterns:\n  - For requests requiring tool use: REPLY,CALL_MCP_TOOL (acknowledge first, then gather info)\n  - For task execution: REPLY,SEND_MESSAGE or REPLY,EVM_SWAP_TOKENS (acknowledge first, then do the task)\n  - For multi-step operations: REPLY,ACTION1,ACTION2 (acknowledge first, then complete all steps)\n- REPLY is used to acknowledge and inform the user about what you're going to do\n- Follow-up actions execute the actual tasks after acknowledgment\n- Use IGNORE only when you should not respond at all\n\nIMPORTANT PROVIDER SELECTION RULES:\n- If the message mentions images, photos, pictures, attachments, or visual content, OR if you see \"(Attachments:\" in the conversation, you MUST include \"ATTACHMENTS\" in your providers list\n- If the message asks about or references specific people, include \"ENTITIES\" in your providers list  \n- If the message asks about relationships or connections between people, include \"RELATIONSHIPS\" in your providers list\n- If the message asks about facts or specific information, include \"FACTS\" in your providers list\n- If the message asks about the environment or world context, include \"WORLD\" in your providers list\n- If you need external knowledge, information, or context beyond the current conversation to provide a helpful response, include \"KNOWLEDGE\" in your providers list\n\nFirst, think about what you want to do next and plan your actions. Then, write the next message and include the actions you plan to take.\n</instructions>\n\n<keys>\n\"thought\" should be a short description of what the agent is thinking about and planning.\n\"actions\" should be a comma-separated list of the actions {{agentName}} plans to take based on the thought, IN THE ORDER THEY SHOULD BE EXECUTED (if none, use IGNORE, if simply responding with text, use REPLY)\n\"providers\" should be a comma-separated list of the providers that {{agentName}} will use to have the right context for responding and acting (NEVER use \"IGNORE\" as a provider - use specific provider names like ATTACHMENTS, ENTITIES, FACTS, KNOWLEDGE, etc.)\n\"text\" should be the text of the next message for {{agentName}} which they will send to the conversation.\n</keys>\n\n<output>\nDo NOT include any thinking, reasoning, or <think> sections in your response. \nGo directly to the XML response format without any preamble or explanation.\n\nRespond using XML format like this:\n<response>\n    <thought>Your thought here</thought>\n    <actions>ACTION1,ACTION2</actions>\n    <providers>PROVIDER1,PROVIDER2</providers>\n    <text>Your response text here</text>\n</response>\n\nIMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.\n</output>";
declare const postCreationTemplate = "# Task: Create a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.\n\nExample task outputs:\n1. A post about the importance of AI in our lives\n<response>\n  <thought>I am thinking about writing a post about the importance of AI in our lives</thought>\n  <post>AI is changing the world and it is important to understand how it works</post>\n  <imagePrompt>A futuristic cityscape with flying cars and people using AI to do things</imagePrompt>\n</response>\n\n2. A post about dogs\n<response>\n  <thought>I am thinking about writing a post about dogs</thought>\n  <post>Dogs are man's best friend and they are loyal and loving</post>\n  <imagePrompt>A dog playing with a ball in a park</imagePrompt>\n</response>\n\n3. A post about finding a new job\n<response>\n  <thought>Getting a job is hard, I bet there's a good tweet in that</thought>\n  <post>Just keep going!</post>\n  <imagePrompt>A person looking at a computer screen with a job search website</imagePrompt>\n</response>\n\n{{providers}}\n\nWrite a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.\nYour response should be 1, 2, or 3 sentences (choose the length at random).\nYour response should not contain any questions. Brief, concise statements only. The total character count MUST be less than 280. No emojis. Use \\n\\n (double spaces) between statements if there are multiple statements in your response.\n\nYour output should be formatted in XML like this:\n<response>\n  <thought>Your thought here</thought>\n  <post>Your post text here</post>\n  <imagePrompt>Optional image prompt here</imagePrompt>\n</response>\n\nThe \"post\" field should be the post you want to send. Do not including any thinking or internal reflection in the \"post\" field.\nThe \"imagePrompt\" field is optional and should be a prompt for an image that is relevant to the post. It should be a single sentence that captures the essence of the post. ONLY USE THIS FIELD if it makes sense that the post would benefit from an image.\nThe \"thought\" field should be a short description of what the agent is thinking about before responding, inlcuding a brief justification for the response. Includate an explanation how the post is relevant to the topic but unique and different than other posts.\n\nDo NOT include any thinking, reasoning, or <think> sections in your response. \nGo directly to the XML response format without any preamble or explanation.\n\nIMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.";
declare const booleanFooter = "Respond with only a YES or a NO.";
declare const imageDescriptionTemplate = "<task>Analyze the provided image and generate a comprehensive description with multiple levels of detail.</task>\n\n<instructions>\nCarefully examine the image and provide:\n1. A concise, descriptive title that captures the main subject or scene\n2. A brief summary description (1-2 sentences) highlighting the key elements\n3. An extensive, detailed description that covers all visible elements, composition, lighting, colors, mood, and any other relevant details\n\nBe objective and descriptive. Focus on what you can actually see in the image rather than making assumptions about context or meaning.\n</instructions>\n\n<output>\nDo NOT include any thinking, reasoning, or <think> sections in your response. \nGo directly to the XML response format without any preamble or explanation.\n\nRespond using XML format like this:\n<response>\n  <title>A concise, descriptive title for the image</title>\n  <description>A brief 1-2 sentence summary of the key elements in the image</description>\n  <text>An extensive, detailed description covering all visible elements, composition, lighting, colors, mood, setting, objects, people, activities, and any other relevant details you can observe in the image</text>\n</response>\n\nIMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.\n</output>";

/**
 * Represents the state of server ownership, including a mapping of server IDs to their respective World objects.
 */
/**
 * Interface representing the ownership state of servers.
 * @property {Object.<string, World>} servers - The servers and their corresponding worlds, where the key is the server ID and the value is the World object.
 */
interface ServerOwnershipState {
    servers: {
        [serverId: string]: World;
    };
}
/**
 * Gets a user's role from world metadata
 */
/**
 * Retrieve the server role of a specified user entity within a given server.
 *
 * @param {IAgentRuntime} runtime - The runtime object containing necessary configurations and services.
 * @param {string} entityId - The unique identifier of the user entity.
 * @param {string} serverId - The unique identifier of the server.
 * @returns {Promise<Role>} The role of the user entity within the server, resolved as a Promise.
 */
declare function getUserServerRole(runtime: IAgentRuntime, entityId: string, serverId: string): Promise<Role>;
/**
 * Finds a server where the given user is the owner
 */
declare function findWorldsForOwner(runtime: IAgentRuntime, entityId: string): Promise<World[] | null>;

declare class Semaphore {
    private permits;
    private waiting;
    constructor(count: number);
    acquire(): Promise<void>;
    release(): void;
}
declare class AgentRuntime implements IAgentRuntime {
    #private;
    readonly agentId: UUID;
    readonly character: Character;
    adapter: IDatabaseAdapter;
    readonly actions: Action[];
    readonly evaluators: Evaluator[];
    readonly providers: Provider[];
    readonly plugins: Plugin[];
    private isInitialized;
    events: Map<string, ((params: any) => Promise<void>)[]>;
    stateCache: Map<`${string}-${string}-${string}-${string}-${string}`, {
        values: {
            [key: string]: any;
        };
        data: {
            [key: string]: any;
        };
        text: string;
    }>;
    readonly fetch: typeof fetch;
    services: Map<ServiceTypeName, Service>;
    private serviceTypes;
    models: Map<string, ModelHandler[]>;
    routes: Route[];
    private taskWorkers;
    private sendHandlers;
    private eventHandlers;
    private allAvailablePlugins;
    private characterPlugins;
    logger: any;
    private settings;
    private servicesInitQueue;
    private currentRunId?;
    private currentActionContext?;
    constructor(opts: {
        conversationLength?: number;
        agentId?: UUID;
        character?: Character;
        plugins?: Plugin[];
        fetch?: typeof fetch;
        adapter?: IDatabaseAdapter;
        settings?: RuntimeSettings;
        events?: {
            [key: string]: ((params: any) => void)[];
        };
        allAvailablePlugins?: Plugin[];
    });
    /**
     * Create a new run ID for tracking a sequence of model calls
     */
    createRunId(): UUID;
    /**
     * Start a new run for tracking prompts
     */
    startRun(): UUID;
    /**
     * End the current run
     */
    endRun(): void;
    /**
     * Get the current run ID (creates one if it doesn't exist)
     */
    getCurrentRunId(): UUID;
    registerPlugin(plugin: Plugin): Promise<void>;
    getAllServices(): Map<ServiceTypeName, Service>;
    stop(): Promise<void>;
    initialize(): Promise<void>;
    runPluginMigrations(): Promise<void>;
    getConnection(): Promise<unknown>;
    setSetting(key: string, value: string | boolean | null | any, secret?: boolean): void;
    getSetting(key: string): string | boolean | null | any;
    getConversationLength(): number;
    registerDatabaseAdapter(adapter: IDatabaseAdapter): void;
    registerProvider(provider: Provider): void;
    registerAction(action: Action): void;
    registerEvaluator(evaluator: Evaluator): void;
    processActions(message: Memory, responses: Memory[], state?: State, callback?: HandlerCallback): Promise<void>;
    evaluate(message: Memory, state: State, didRespond?: boolean, callback?: HandlerCallback, responses?: Memory[]): Promise<Evaluator[]>;
    ensureConnections(entities: any, rooms: any, source: any, world: any): Promise<void>;
    ensureConnection({ entityId, roomId, worldId, worldName, userName, name, source, type, channelId, serverId, userId, metadata, }: {
        entityId: UUID;
        roomId: UUID;
        worldId: UUID;
        worldName?: string;
        userName?: string;
        name?: string;
        source?: string;
        type?: ChannelType;
        channelId?: string;
        serverId?: string;
        userId?: UUID;
        metadata?: Record<string, any>;
    }): Promise<void>;
    ensureParticipantInRoom(entityId: UUID, roomId: UUID): Promise<void>;
    removeParticipant(entityId: UUID, roomId: UUID): Promise<boolean>;
    getParticipantsForEntity(entityId: UUID): Promise<Participant[]>;
    getParticipantsForRoom(roomId: UUID): Promise<UUID[]>;
    addParticipant(entityId: UUID, roomId: UUID): Promise<boolean>;
    addParticipantsRoom(entityIds: UUID[], roomId: UUID): Promise<boolean>;
    /**
     * Ensure the existence of a world.
     */
    ensureWorldExists({ id, name, serverId, metadata }: World): Promise<void>;
    ensureRoomExists({ id, name, source, type, channelId, serverId, worldId, metadata }: Room): Promise<void>;
    composeState(message: Memory, includeList?: string[] | null, onlyInclude?: boolean, skipCache?: boolean): Promise<State>;
    getService<T extends Service = Service>(serviceName: ServiceTypeName | string): T | null;
    /**
     * Type-safe service getter that ensures the correct service type is returned
     * @template T - The expected service class type
     * @param serviceName - The service type name
     * @returns The service instance with proper typing, or null if not found
     */
    getTypedService<T extends Service = Service>(serviceName: ServiceTypeName | string): T | null;
    /**
     * Get all registered service types
     * @returns Array of registered service type names
     */
    getRegisteredServiceTypes(): ServiceTypeName[];
    /**
     * Check if a service type is registered
     * @param serviceType - The service type to check
     * @returns true if the service is registered
     */
    hasService(serviceType: ServiceTypeName | string): boolean;
    registerService(serviceDef: typeof Service): Promise<void>;
    registerModel(modelType: ModelTypeName, handler: (params: any) => Promise<any>, provider: string, priority?: number): void;
    getModel(modelType: ModelTypeName, provider?: string): ((runtime: IAgentRuntime, params: any) => Promise<any>) | undefined;
    useModel<T extends ModelTypeName, R = ModelResultMap[T]>(modelType: T, params: Omit<ModelParamsMap[T], 'runtime'> | any, provider?: string): Promise<R>;
    registerEvent(event: string, handler: (params: any) => Promise<void>): void;
    getEvent(event: string): ((params: any) => Promise<void>)[] | undefined;
    emitEvent(event: string | string[], params: any): Promise<void>;
    ensureEmbeddingDimension(): Promise<void>;
    registerTaskWorker(taskHandler: TaskWorker): void;
    getTaskWorker(name: string): TaskWorker | undefined;
    get db(): any;
    init(): Promise<void>;
    close(): Promise<void>;
    getAgent(agentId: UUID): Promise<Agent | null>;
    getAgents(): Promise<Partial<Agent>[]>;
    createAgent(agent: Partial<Agent>): Promise<boolean>;
    updateAgent(agentId: UUID, agent: Partial<Agent>): Promise<boolean>;
    deleteAgent(agentId: UUID): Promise<boolean>;
    ensureAgentExists(agent: Partial<Agent>): Promise<Agent>;
    getEntityById(entityId: UUID): Promise<Entity | null>;
    getEntityByIds(entityIds: UUID[]): Promise<Entity[] | null>;
    getEntitiesForRoom(roomId: UUID, includeComponents?: boolean): Promise<Entity[]>;
    createEntity(entity: Entity): Promise<boolean>;
    createEntities(entities: Entity[]): Promise<boolean>;
    updateEntity(entity: Entity): Promise<void>;
    getComponent(entityId: UUID, type: string, worldId?: UUID, sourceEntityId?: UUID): Promise<Component | null>;
    getComponents(entityId: UUID, worldId?: UUID, sourceEntityId?: UUID): Promise<Component[]>;
    createComponent(component: Component): Promise<boolean>;
    updateComponent(component: Component): Promise<void>;
    deleteComponent(componentId: UUID): Promise<void>;
    addEmbeddingToMemory(memory: Memory): Promise<Memory>;
    getMemories(params: {
        entityId?: UUID;
        agentId?: UUID;
        roomId?: UUID;
        count?: number;
        unique?: boolean;
        tableName: string;
        start?: number;
        end?: number;
    }): Promise<Memory[]>;
    getAllMemories(): Promise<Memory[]>;
    getMemoryById(id: UUID): Promise<Memory | null>;
    getMemoriesByIds(ids: UUID[], tableName?: string): Promise<Memory[]>;
    getMemoriesByRoomIds(params: {
        tableName: string;
        roomIds: UUID[];
        limit?: number;
    }): Promise<Memory[]>;
    getCachedEmbeddings(params: {
        query_table_name: string;
        query_threshold: number;
        query_input: string;
        query_field_name: string;
        query_field_sub_name: string;
        query_match_count: number;
    }): Promise<{
        embedding: number[];
        levenshtein_score: number;
    }[]>;
    log(params: {
        body: {
            [key: string]: unknown;
        };
        entityId: UUID;
        roomId: UUID;
        type: string;
    }): Promise<void>;
    searchMemories(params: {
        embedding: number[];
        query?: string;
        match_threshold?: number;
        count?: number;
        roomId?: UUID;
        unique?: boolean;
        worldId?: UUID;
        entityId?: UUID;
        tableName: string;
    }): Promise<Memory[]>;
    rerankMemories(query: string, memories: Memory[]): Promise<Memory[]>;
    createMemory(memory: Memory, tableName: string, unique?: boolean): Promise<UUID>;
    updateMemory(memory: Partial<Memory> & {
        id: UUID;
        metadata?: MemoryMetadata;
    }): Promise<boolean>;
    deleteMemory(memoryId: UUID): Promise<void>;
    deleteManyMemories(memoryIds: UUID[]): Promise<void>;
    clearAllAgentMemories(): Promise<void>;
    deleteAllMemories(roomId: UUID, tableName: string): Promise<void>;
    countMemories(roomId: UUID, unique?: boolean, tableName?: string): Promise<number>;
    getLogs(params: {
        entityId: UUID;
        roomId?: UUID;
        type?: string;
        count?: number;
        offset?: number;
    }): Promise<Log[]>;
    deleteLog(logId: UUID): Promise<void>;
    createWorld(world: World): Promise<UUID>;
    getWorld(id: UUID): Promise<World | null>;
    removeWorld(worldId: UUID): Promise<void>;
    getAllWorlds(): Promise<World[]>;
    updateWorld(world: World): Promise<void>;
    getRoom(roomId: UUID): Promise<Room | null>;
    getRoomsByIds(roomIds: UUID[]): Promise<Room[] | null>;
    createRoom({ id, name, source, type, channelId, serverId, worldId }: Room): Promise<UUID>;
    createRooms(rooms: Room[]): Promise<UUID[]>;
    deleteRoom(roomId: UUID): Promise<void>;
    deleteRoomsByWorldId(worldId: UUID): Promise<void>;
    updateRoom(room: Room): Promise<void>;
    getRoomsForParticipant(entityId: UUID): Promise<UUID[]>;
    getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]>;
    getRooms(worldId: UUID): Promise<Room[]>;
    getRoomsByWorld(worldId: UUID): Promise<Room[]>;
    getParticipantUserState(roomId: UUID, entityId: UUID): Promise<'FOLLOWED' | 'MUTED' | null>;
    setParticipantUserState(roomId: UUID, entityId: UUID, state: 'FOLLOWED' | 'MUTED' | null): Promise<void>;
    createRelationship(params: {
        sourceEntityId: UUID;
        targetEntityId: UUID;
        tags?: string[];
        metadata?: {
            [key: string]: any;
        };
    }): Promise<boolean>;
    updateRelationship(relationship: Relationship): Promise<void>;
    getRelationship(params: {
        sourceEntityId: UUID;
        targetEntityId: UUID;
    }): Promise<Relationship | null>;
    getRelationships(params: {
        entityId: UUID;
        tags?: string[];
    }): Promise<Relationship[]>;
    getCache<T>(key: string): Promise<T | undefined>;
    setCache<T>(key: string, value: T): Promise<boolean>;
    deleteCache(key: string): Promise<boolean>;
    createTask(task: Task): Promise<UUID>;
    getTasks(params: {
        roomId?: UUID;
        tags?: string[];
        entityId?: UUID;
    }): Promise<Task[]>;
    getTask(id: UUID): Promise<Task | null>;
    getTasksByName(name: string): Promise<Task[]>;
    updateTask(id: UUID, task: Partial<Task>): Promise<void>;
    deleteTask(id: UUID): Promise<void>;
    on(event: string, callback: (data: any) => void): void;
    off(event: string, callback: (data: any) => void): void;
    emit(event: string, data: any): void;
    sendControlMessage(params: {
        roomId: UUID;
        action: 'enable_input' | 'disable_input';
        target?: string;
    }): Promise<void>;
    registerSendHandler(source: string, handler: SendHandlerFunction): void;
    sendMessageToTarget(target: TargetInfo, content: Content): Promise<void>;
    getMemoriesByWorldId(params: {
        worldId: UUID;
        count?: number;
        tableName?: string;
    }): Promise<Memory[]>;
    runMigrations(migrationsPaths?: string[]): Promise<void>;
    isReady(): Promise<boolean>;
}

/**
 * Creates a new Setting object based on provided config settings.
 * @param {Omit<Setting, "value">} configSetting - The configuration settings for the new Setting object.
 * @returns {Setting} - The newly created Setting object.
 */
/**
 * Creates a Setting object from a configSetting object by omitting the 'value' property.
 *
 * @param {Omit<Setting, 'value'>} configSetting - The configSetting object to create the Setting from.
 * @returns {Setting} A new Setting object created from the provided configSetting object.
 */
declare function createSettingFromConfig(configSetting: Omit<Setting, 'value'>): Setting;
/**
 * Retrieves the salt based on env variable SECRET_SALT
 *
 * @returns {string} The salt for the agent.
 */
declare function getSalt(): string;
/**
 * Common encryption function for string values
 * @param {string} value - The string value to encrypt
 * @param {string} salt - The salt to use for encryption
 * @returns {string} - The encrypted value in 'iv:encrypted' format
 */
declare function encryptStringValue(value: string, salt: string): string;
/**
 * Common decryption function for string values
 * @param {string} value - The encrypted value in 'iv:encrypted' format
 * @param {string} salt - The salt to use for decryption
 * @returns {string} - The decrypted string value
 */
declare function decryptStringValue(value: string, salt: string): string;
/**
 * Applies salt to the value of a setting
 * Only applies to secret settings with string values
 */
declare function saltSettingValue(setting: Setting, salt: string): Setting;
/**
 * Removes salt from the value of a setting
 * Only applies to secret settings with string values
 */
declare function unsaltSettingValue(setting: Setting, salt: string): Setting;
/**
 * Applies salt to all settings in a WorldSettings object
 */
declare function saltWorldSettings(worldSettings: WorldSettings, salt: string): WorldSettings;
/**
 * Removes salt from all settings in a WorldSettings object
 */
declare function unsaltWorldSettings(worldSettings: WorldSettings, salt: string): WorldSettings;
/**
 * Updates settings state in world metadata
 */
declare function updateWorldSettings(runtime: IAgentRuntime, serverId: string, worldSettings: WorldSettings): Promise<boolean>;
/**
 * Gets settings state from world metadata
 */
declare function getWorldSettings(runtime: IAgentRuntime, serverId: string): Promise<WorldSettings | null>;
/**
 * Initializes settings configuration for a server
 */
declare function initializeOnboarding(runtime: IAgentRuntime, world: World, config: OnboardingConfig): Promise<WorldSettings | null>;
/**
 * Encrypts sensitive data in a Character object
 * @param {Character} character - The character object to encrypt secrets for
 * @returns {Character} - A copy of the character with encrypted secrets
 */
declare function encryptedCharacter(character: Character): Character;
/**
 * Decrypts sensitive data in a Character object
 * @param {Character} character - The character object with encrypted secrets
 * @param {IAgentRuntime} runtime - The runtime information needed for salt generation
 * @returns {Character} - A copy of the character with decrypted secrets
 */
declare function decryptedCharacter(character: Character, _runtime: IAgentRuntime): Character;
/**
 * Helper function to encrypt all string values in an object
 * @param {Record<string, any>} obj - Object with values to encrypt
 * @param {string} salt - The salt to use for encryption
 * @returns {Record<string, any>} - Object with encrypted values
 */
declare function encryptObjectValues(obj: Record<string, any>, salt: string): Record<string, any>;
/**
 * Helper function to decrypt all string values in an object
 * @param {Record<string, any>} obj - Object with encrypted values
 * @param {string} salt - The salt to use for decryption
 * @returns {Record<string, any>} - Object with decrypted values
 */
declare function decryptObjectValues(obj: Record<string, any>, salt: string): Record<string, any>;

declare const defaultSpec: typeof v2;

export { Action, Agent, AgentRuntime, ChannelType, Character, type CharacterValidationResult, Component, Content, ContentType, DatabaseAdapter, type DeriveKeyAttestationData, Entity, Evaluator, HandlerCallback, IAgentRuntime, IDatabaseAdapter, ILpService, ITokenDataService, IWalletService, Log, type LpPositionDetails, Memory, MemoryMetadata, Metadata, ModelHandler, ModelParamsMap, ModelResultMap, ModelTypeName, OnboardingConfig, Participant, Plugin, type PoolInfo, Provider, Relationship, type RemoteAttestationMessage, type RemoteAttestationQuote, Role, Room, Route, RuntimeSettings, Semaphore, SendHandlerFunction, type ServerOwnershipState, Service, ServiceTypeName, Setting, State, TEEMode, TargetInfo, Task, TaskWorker, type TeeAgent, type TeePluginConfig, TeeType, TemplateType, type TokenBalance, type TokenData, type TransactionResult, UUID, type WalletAsset, type WalletPortfolio, World, WorldSettings, addHeader, booleanFooter, characterSchema, composeActionExamples, composePrompt, composePromptFromState, createLogger, createSettingFromConfig, createUniqueUuid, decryptObjectValues, decryptStringValue as decryptSecret, decryptStringValue, decryptedCharacter, defaultSpec, elizaLogger, encryptObjectValues, encryptStringValue, encryptedCharacter, findEntityByName, findWorldsForOwner, formatActionNames, formatActions, formatEntities, formatMessages, formatPosts, formatTimestamp, getContentTypeFromMimeType, getEntityDetails, getLocalServerUrl, getSalt, getUserServerRole, getWorldSettings, imageDescriptionTemplate, initializeOnboarding, isValidCharacter, logger, messageHandlerTemplate, normalizeJsonString, parseAndValidateCharacter, parseBooleanFromText, parseJSONObjectFromText, parseKeyValueXml, postCreationTemplate, safeReplacer, saltSettingValue, saltWorldSettings, shouldRespondTemplate, splitChunks, stringToUuid, trimTokens, truncateToCompleteSentence, unsaltSettingValue, unsaltWorldSettings, updateWorldSettings, v2, validateCharacter, validateUuid };
