import { A as Action$1, I as IDatabaseAdapter$1, U as UUID$1, E as Entity$1, C as Component$1, M as Memory$1, L as Log$1, a as MemoryMetadata$1, W as World$1, R as Room$1, P as Participant$1, b as Relationship$1, c as Agent$1, T as Task$1, d as IAgentRuntime$1, e as Role$1, S as ServiceTypeName$1, f as Service$1, g as Route$1, h as Character$1, i as Provider$1, j as Evaluator$1, k as Plugin$1, l as RuntimeSettings$1, m as State$1, H as HandlerCallback$1, n as ModelTypeName$1, o as ModelResultMap$1, p as ModelParamsMap$1, q as TaskWorker$1, r as SendHandlerFunction$1, s as TargetInfo$1, t as Content$1, u as TemplateType$1, v as ActionEventPayload$1, w as ActionExample$1, x as AgentStatus$1, y as AudioProcessingParams$1, B as BaseMetadata$1, z as BaseModelParams$1, D as CacheKeyPrefix$1, F as ChannelClearedPayload$1, G as ChannelType$1, J as ChunkRow$1, K as ComponentData, N as ContentType$1, O as ControlMessage$1, Q as CustomMetadata$1, V as DbConnection$1, X as DeriveKeyAttestationData, Y as DescriptionMetadata$1, Z as DetokenizeTextParams$1, _ as DirectoryItem$1, $ as DocumentMetadata$1, a0 as EmbeddingSearchResult$1, a1 as EnhancedState$1, a2 as EntityPayload$1, a3 as EvaluationExample$1, a4 as EvaluatorEventPayload$1, a5 as EventDataObject, a6 as EventHandler$1, a7 as EventPayload$1, a8 as EventPayloadMap$1, a9 as EventType$1, aa as FragmentMetadata$1, ab as GenerateTextParams$1, ac as Handler$1, ad as ImageDescriptionParams$1, ae as ImageGenerationParams$1, af as InvokePayload$1, ag as IsValidServiceType$1, ah as JSONSchema$1, ai as KnowledgeItem$1, aj as KnowledgeScope$1, ak as Media$1, al as MemoryRetrievalOptions$1, am as MemoryScope$1, an as MemorySearchOptions$1, ao as MemoryType$1, ap as MemoryTypeAlias$1, aq as MessageExample$1, ar as MessageMemory$1, as as MessageMetadata$1, at as MessagePayload$1, au as MessageReceivedHandlerParams$1, av as MetadataObject, aw as ModelEventPayload$1, ax as ModelHandler$1, ay as ModelType$1, az as MultiRoomMemoryOptions$1, aA as ObjectGenerationParams$1, aB as OnboardingConfig$1, aC as PlatformPrefix$1, aD as PluginEvents$1, aE as Project$1, aF as ProjectAgent$1, aG as ProviderResult$1, aH as RemoteAttestationMessage, aI as RemoteAttestationQuote, aJ as RoomMetadata$1, aK as RunEventPayload$1, aL as SOCKET_MESSAGE_TYPE$1, aM as ServiceClassMap$1, aN as ServiceConfig, aO as ServiceError$1, aP as ServiceInstance$1, aQ as ServiceRegistry$1, aR as ServiceType$1, aS as ServiceTypeRegistry$1, aT as ServiceTypeValue$1, aU as Setting$1, aV as StateArray$1, aW as StateObject$1, aX as StateValue$1, aY as TEEMode, aZ as TaskMetadata$1, a_ as TeeAgent, a$ as TeePluginConfig, b0 as TeeType, b1 as TeeVendorConfig, b2 as TestCase$1, b3 as TestSuite$1, b4 as TextEmbeddingParams$1, b5 as TextGenerationParams$1, b6 as TextToSpeechParams$1, b7 as TokenizeTextParams$1, b8 as TranscriptionParams$1, b9 as TypedEventHandler$1, ba as TypedService$1, bb as TypedServiceClass$1, bc as UnifiedMemoryOptions$1, bd as UnifiedSearchOptions$1, be as VECTOR_DIMS$1, bf as Validator$1, bg as VideoProcessingParams$1, bh as WorldPayload$1, bi as WorldSettings$1, bj as asUUID$1, bk as createMessageMemory$1, bl as createServiceError$1, bm as getMemoryText$1, bn as getTypedService$1, bo as isCustomMetadata$1, bp as isDescriptionMetadata$1, bq as isDocumentMemory$1, br as isDocumentMetadata$1, bs as isFragmentMemory$1, bt as isFragmentMetadata$1, bu as isMessageMetadata$1 } from './types-BhMd7Ajo.js';

/**
 * Defines a custom type UUID representing a universally unique identifier
 */
type UUID = `${string}-${string}-${string}-${string}-${string}`;
/**
 * Helper function to safely cast a string to strongly typed UUID
 * @param id The string UUID to validate and cast
 * @returns The same UUID with branded type information
 */
declare function asUUID(id: string): UUID;
/**
 * Represents the content of a memory, message, or other information
 */
interface Content {
    /** The agent's internal thought process */
    thought?: string;
    /** The main text content visible to users */
    text?: string;
    /** Optional actions to be performed */
    actions?: string[];
    /** Optional providers to use for context generation */
    providers?: string[];
    /** Optional source/origin of the content */
    source?: string;
    /** Optional target/destination for responses */
    target?: string;
    /** URL of the original message/post (e.g. tweet URL, Discord message link) */
    url?: string;
    /** UUID of parent message if this is a reply/thread */
    inReplyTo?: UUID;
    /** Array of media attachments */
    attachments?: Media[];
    /** room type */
    channelType?: string;
    /**
     * Additional dynamic properties
     * Use specific properties above instead of this when possible
     */
    [key: string]: unknown;
}
/**
 * Represents a media attachment
 */
type Media = {
    /** Unique identifier */
    id: string;
    /** Media URL */
    url: string;
    /** Media title */
    title?: string;
    /** Media source */
    source?: string;
    /** Media description */
    description?: string;
    /** Text content */
    text?: string;
    /** Content type */
    contentType?: ContentType;
};
declare enum ContentType {
    IMAGE = "image",
    VIDEO = "video",
    AUDIO = "audio",
    DOCUMENT = "document",
    LINK = "link"
}
/**
 * A generic type for metadata objects, allowing for arbitrary key-value pairs.
 * This encourages consumers to perform type checking or casting.
 */
type Metadata = Record<string, unknown>;

/**
 * Represents the current state or context of a conversation or agent interaction.
 * This interface is a flexible container for various pieces of information that define the agent's
 * understanding at a point in time. It includes:
 * - `values`: A key-value store for general state variables, often populated by providers.
 * - `data`: Another key-value store, potentially for more structured or internal data.
 * - `text`: A string representation of the current context, often a summary or concatenated history.
 * The `[key: string]: any;` allows for dynamic properties, though `EnhancedState` offers better typing.
 * This state object is passed to handlers for actions, evaluators, and providers.
 */
interface State {
    /** Additional dynamic properties */
    [key: string]: any;
    values: {
        [key: string]: any;
    };
    data: {
        [key: string]: any;
    };
    text: string;
}
/**
 * Defines the possible primitive types or structured types for a value within the agent's state.
 * This type is used to provide more specific typing for properties within `StateObject` and `StateArray`,
 * moving away from a generic 'any' type for better type safety and clarity in state management.
 */
type StateValue = string | number | boolean | null | StateObject | StateArray;
/**
 * Represents a generic object structure within the agent's state, where keys are strings
 * and values can be any `StateValue`. This allows for nested objects within the state.
 * It's a fundamental part of the `EnhancedState` interface.
 */
interface StateObject {
    [key: string]: StateValue;
}
/**
 * Represents an array of `StateValue` types within the agent's state.
 * This allows for lists of mixed or uniform types to be stored in the state,
 * contributing to the structured definition of `EnhancedState`.
 */
type StateArray = StateValue[];
/**
 * Enhanced State interface with more specific types for its core properties.
 * This interface provides a more structured representation of an agent's conversational state,
 * building upon the base `State` by typing `values` and `data` as `StateObject`.
 * The `text` property typically holds a textual summary or context derived from the state.
 * Additional dynamic properties are still allowed via the index signature `[key: string]: StateValue;`.
 */
interface EnhancedState {
    /** Holds directly accessible state values, often used for template rendering or quick lookups. */
    values: StateObject;
    /** Stores more complex or structured data, potentially namespaced by providers or internal systems. */
    data: StateObject;
    /** A textual representation or summary of the current state, often used as context for models. */
    text: string;
    /** Allows for additional dynamic properties to be added to the state object. */
    [key: string]: StateValue;
}

/**
 * Memory type enumeration for built-in memory types
 */
type MemoryTypeAlias = string;
/**
 * Enumerates the built-in types of memories that can be stored and retrieved.
 * - `DOCUMENT`: Represents a whole document or a large piece of text.
 * - `FRAGMENT`: A chunk or segment of a `DOCUMENT`, often created for embedding and search.
 * - `MESSAGE`: A conversational message, typically from a user or the agent.
 * - `DESCRIPTION`: A descriptive piece of information, perhaps about an entity or concept.
 * - `CUSTOM`: For any other type of memory not covered by the built-in types.
 * This enum is used in `MemoryMetadata` to categorize memories and influences how they are processed or queried.
 */
declare enum MemoryType {
    DOCUMENT = "document",
    FRAGMENT = "fragment",
    MESSAGE = "message",
    DESCRIPTION = "description",
    CUSTOM = "custom"
}
/**
 * Defines the scope of a memory, indicating its visibility and accessibility.
 * - `shared`: The memory is accessible to multiple entities or across different contexts (e.g., a public fact).
 * - `private`: The memory is specific to a single entity or a private context (e.g., a user's personal preference).
 * - `room`: The memory is scoped to a specific room or channel.
 * This is used in `MemoryMetadata` to control how memories are stored and retrieved based on context.
 */
type MemoryScope = 'shared' | 'private' | 'room';
/**
 * Base interface for all memory metadata types.
 * It includes common properties for all memories, such as:
 * - `type`: The kind of memory (e.g., `MemoryType.MESSAGE`, `MemoryType.DOCUMENT`).
 * - `source`: An optional string indicating the origin of the memory (e.g., 'discord', 'user_input').
 * - `sourceId`: An optional UUID linking to a source entity or object.
 * - `scope`: The visibility scope of the memory (`shared`, `private`, or `room`).
 * - `timestamp`: An optional numerical timestamp (e.g., milliseconds since epoch) of when the memory was created or relevant.
 * - `tags`: Optional array of strings for categorizing or filtering memories.
 * Specific metadata types like `DocumentMetadata` or `MessageMetadata` extend this base.
 */
interface BaseMetadata {
    type: MemoryTypeAlias;
    source?: string;
    sourceId?: UUID;
    scope?: MemoryScope;
    timestamp?: number;
    tags?: string[];
}
interface DocumentMetadata extends BaseMetadata {
    type: MemoryType.DOCUMENT;
}
interface FragmentMetadata extends BaseMetadata {
    type: MemoryType.FRAGMENT;
    documentId: UUID;
    position: number;
}
interface MessageMetadata extends BaseMetadata {
    type: MemoryType.MESSAGE;
}
interface DescriptionMetadata extends BaseMetadata {
    type: MemoryType.DESCRIPTION;
}
interface CustomMetadata extends BaseMetadata {
    [key: string]: unknown;
}
type MemoryMetadata = DocumentMetadata | FragmentMetadata | MessageMetadata | DescriptionMetadata | CustomMetadata;
/**
 * Represents a stored memory/message
 */
interface Memory {
    /** Optional unique identifier */
    id?: UUID;
    /** Associated user ID */
    entityId: UUID;
    /** Associated agent ID */
    agentId?: UUID;
    /** Optional creation timestamp in milliseconds since epoch */
    createdAt?: number;
    /** Memory content */
    content: Content;
    /** Optional embedding vector for semantic search */
    embedding?: number[];
    /** Associated room ID */
    roomId: UUID;
    /** Associated world ID (optional) */
    worldId?: UUID;
    /** Whether memory is unique (used to prevent duplicates) */
    unique?: boolean;
    /** Embedding similarity score (set when retrieved via search) */
    similarity?: number;
    /** Metadata for the memory */
    metadata?: MemoryMetadata;
}
/**
 * Specialized memory type for messages with enhanced type checking
 */
interface MessageMemory extends Memory {
    metadata: MessageMetadata;
    content: Content & {
        text: string;
    };
}
/**
 * Factory function to create a new message memory with proper defaults
 */
declare function createMessageMemory(params: {
    id?: UUID;
    entityId: UUID;
    agentId?: UUID;
    roomId: UUID;
    content: Content & {
        text: string;
    };
    embedding?: number[];
}): MessageMemory;
/**
 * Type guard to check if a memory metadata is a DocumentMetadata
 * @param metadata The metadata to check
 * @returns True if the metadata is a DocumentMetadata
 */
declare function isDocumentMetadata(metadata: MemoryMetadata): metadata is DocumentMetadata;
/**
 * Type guard to check if a memory metadata is a FragmentMetadata
 * @param metadata The metadata to check
 * @returns True if the metadata is a FragmentMetadata
 */
declare function isFragmentMetadata(metadata: MemoryMetadata): metadata is FragmentMetadata;
/**
 * Type guard to check if a memory metadata is a MessageMetadata
 * @param metadata The metadata to check
 * @returns True if the metadata is a MessageMetadata
 */
declare function isMessageMetadata(metadata: MemoryMetadata): metadata is MessageMetadata;
/**
 * Type guard to check if a memory metadata is a DescriptionMetadata
 * @param metadata The metadata to check
 * @returns True if the metadata is a DescriptionMetadata
 */
declare function isDescriptionMetadata(metadata: MemoryMetadata): metadata is DescriptionMetadata;
/**
 * Type guard to check if a memory metadata is a CustomMetadata
 * @param metadata The metadata to check
 * @returns True if the metadata is a CustomMetadata
 */
declare function isCustomMetadata(metadata: MemoryMetadata): metadata is CustomMetadata;
/**
 * Memory type guard for document memories
 */
declare function isDocumentMemory(memory: Memory): memory is Memory & {
    metadata: DocumentMetadata;
};
/**
 * Memory type guard for fragment memories
 */
declare function isFragmentMemory(memory: Memory): memory is Memory & {
    metadata: FragmentMetadata;
};
/**
 * Safely access the text content of a memory
 * @param memory The memory to extract text from
 * @param defaultValue Optional default value if no text is found
 * @returns The text content or default value
 */
declare function getMemoryText(memory: Memory, defaultValue?: string): string;

/**
 * Represents a single item of knowledge that can be processed and stored by the agent.
 * Knowledge items consist of content (text and optional structured data) and metadata.
 * These items are typically added to the agent's knowledge base via `AgentRuntime.addKnowledge`
 * and retrieved using `AgentRuntime.getKnowledge`.
 * The `id` is a unique identifier for the knowledge item, often derived from its source or content.
 */
type KnowledgeItem = {
    /** A Universally Unique Identifier for this specific knowledge item. */
    id: UUID;
    /** The actual content of the knowledge item, which must include text and can have other fields. */
    content: Content;
    /** Optional metadata associated with this knowledge item, conforming to `MemoryMetadata`. */
    metadata?: MemoryMetadata;
};
/**
 * Defines the scope or visibility of knowledge items within the agent's system.
 * - `SHARED`: Indicates knowledge that is broadly accessible, potentially across different agents or users if the system architecture permits.
 * - `PRIVATE`: Indicates knowledge that is restricted, typically to the specific agent or user context it belongs to.
 * This enum is used to manage access and retrieval of knowledge items, often in conjunction with `AgentRuntime.addKnowledge` or `AgentRuntime.getKnowledge` scopes.
 */
declare enum KnowledgeScope {
    SHARED = "shared",
    PRIVATE = "private"
}
/**
 * Specifies prefixes for keys used in caching mechanisms, helping to namespace cached data.
 * For example, `KNOWLEDGE` might be used to prefix keys for cached knowledge embeddings or processed documents.
 * This helps in organizing the cache and avoiding key collisions.
 * Used internally by caching strategies, potentially within `IDatabaseAdapter` cache methods or runtime caching layers.
 */
declare enum CacheKeyPrefix {
    KNOWLEDGE = "knowledge"
}
/**
 * Represents an item within a directory listing, specifically for knowledge loading.
 * When an agent's `Character.knowledge` configuration includes a directory, this type
 * is used to specify the path to that directory and whether its contents should be treated as shared.
 * - `directory`: The path to the directory containing knowledge files.
 * - `shared`: An optional boolean (defaults to false) indicating if the knowledge from this directory is considered shared or private.
 */
interface DirectoryItem {
    /** The path to the directory containing knowledge files. */
    directory: string;
    /** If true, knowledge from this directory is considered shared; otherwise, it's private. Defaults to false. */
    shared?: boolean;
}
/**
 * Represents a row structure, typically from a database query related to text chunking or processing.
 * This interface is quite minimal and seems to be a placeholder or a base for more specific chunk-related types.
 * The `id` would be the unique identifier for the chunk.
 * It might be used when splitting large documents into smaller, manageable pieces for embedding or analysis.
 */
interface ChunkRow {
    /** The unique identifier for this chunk of text. */
    id: string;
}

interface Component {
    id: UUID;
    entityId: UUID;
    agentId: UUID;
    roomId: UUID;
    worldId: UUID;
    sourceEntityId: UUID;
    type: string;
    createdAt: number;
    data: Metadata;
}
/**
 * Represents a user account
 */
interface Entity {
    /** Unique identifier, optional on creation */
    id?: UUID;
    /** Names of the entity */
    names: string[];
    /** Optional additional metadata */
    metadata?: Metadata;
    /** Agent ID this account is related to, for agents should be themselves */
    agentId: UUID;
    /** Optional array of components */
    components?: Component[];
}
/**
 * Defines roles within a system, typically for access control or permissions, often within a `World`.
 * - `OWNER`: Represents the highest level of control, typically the creator or primary administrator.
 * - `ADMIN`: Represents administrative privileges, usually a subset of owner capabilities.
 * - `NONE`: Indicates no specific role or default, minimal permissions.
 * These roles are often used in `World.metadata.roles` to assign roles to entities.
 */
declare enum Role {
    OWNER = "OWNER",
    ADMIN = "ADMIN",
    NONE = "NONE"
}
type World = {
    id: UUID;
    name?: string;
    agentId: UUID;
    serverId: string;
    metadata?: {
        ownership?: {
            ownerId: string;
        };
        roles?: {
            [entityId: UUID]: Role;
        };
        [key: string]: unknown;
    };
};
declare enum ChannelType {
    SELF = "SELF",// Messages to self
    DM = "DM",// Direct messages between two participants
    GROUP = "GROUP",// Group messages with multiple participants
    VOICE_DM = "VOICE_DM",// Voice direct messages
    VOICE_GROUP = "VOICE_GROUP",// Voice channels with multiple participants
    FEED = "FEED",// Social media feed
    THREAD = "THREAD",// Threaded conversation
    WORLD = "WORLD",// World channel
    FORUM = "FORUM",// Forum discussion
    API = "API"
}
type Room = {
    id: UUID;
    name?: string;
    agentId?: UUID;
    source: string;
    type: ChannelType;
    channelId?: string;
    serverId?: string;
    worldId?: UUID;
    metadata?: Metadata;
};
type RoomMetadata = {
    [key: string]: unknown;
};
/**
 * Room participant with account details
 */
interface Participant {
    /** Unique identifier */
    id: UUID;
    /** Associated account */
    entity: Entity;
}
/**
 * Represents a relationship between users
 */
interface Relationship {
    /** Unique identifier */
    id: UUID;
    /** First user ID */
    sourceEntityId: UUID;
    /** Second user ID */
    targetEntityId: UUID;
    /** Agent ID */
    agentId: UUID;
    /** Tags for filtering/categorizing relationships */
    tags: string[];
    /** Additional metadata about the relationship */
    metadata: Metadata;
    /** Optional creation timestamp */
    createdAt?: string;
}

/**
 * Example message for demonstration
 */
interface MessageExample {
    /** Associated user */
    name: string;
    /** Message content */
    content: Content;
}
type TemplateType = string | ((options: {
    state: State | {
        [key: string]: string;
    };
}) => string);
/**
 * Configuration for an agent's character, defining its personality, knowledge, and capabilities.
 * This is a central piece of an agent's definition, used by the `AgentRuntime` to initialize and operate the agent.
 * It includes:
 * - `id`: Optional unique identifier for the character.
 * - `name`, `username`: Identifying names for the character.
 * - `system`: A system prompt that guides the agent's overall behavior.
 * - `templates`: A map of prompt templates for various situations (e.g., message generation, summarization).
 * - `bio`: A textual biography or description of the character.
 * - `messageExamples`, `postExamples`: Examples of how the character communicates.
 * - `topics`, `adjectives`: Keywords describing the character's knowledge areas and traits.
 * - `knowledge`: Paths to knowledge files or directories to be loaded into the agent's memory.
 * - `plugins`: A list of plugin names to be loaded for this character.
 * - `settings`, `secrets`: Configuration key-value pairs, with secrets being handled more securely.
 * - `style`: Guidelines for the character's writing style in different contexts (chat, post).
 */
interface Character {
    /** Optional unique identifier */
    id?: UUID;
    /** Character name */
    name: string;
    /** Optional username */
    username?: string;
    /** Optional system prompt */
    system?: string;
    /** Optional prompt templates */
    templates?: {
        [key: string]: TemplateType;
    };
    /** Character biography */
    bio: string | string[];
    /** Example messages */
    messageExamples?: MessageExample[][];
    /** Example posts */
    postExamples?: string[];
    /** Known topics */
    topics?: string[];
    /** Character traits */
    adjectives?: string[];
    /** Optional knowledge base */
    knowledge?: (string | {
        path: string;
        shared?: boolean;
    } | DirectoryItem)[];
    /** Available plugins */
    plugins?: string[];
    /** Optional configuration */
    settings?: {
        [key: string]: string | boolean | number | Record<string, any>;
    };
    /** Optional secrets */
    secrets?: {
        [key: string]: string | boolean | number;
    };
    /** Writing style guides */
    style?: {
        all?: string[];
        chat?: string[];
        post?: string[];
    };
}
declare enum AgentStatus {
    ACTIVE = "active",
    INACTIVE = "inactive"
}
/**
 * Represents an operational agent, extending the `Character` definition with runtime status and timestamps.
 * While `Character` defines the blueprint, `Agent` represents an instantiated and potentially running version.
 * It includes:
 * - `enabled`: A boolean indicating if the agent is currently active or disabled.
 * - `status`: The current operational status, typically `AgentStatus.ACTIVE` or `AgentStatus.INACTIVE`.
 * - `createdAt`, `updatedAt`: Timestamps for when the agent record was created and last updated in the database.
 * This interface is primarily used by the `IDatabaseAdapter` for agent management.
 */
interface Agent extends Character {
    enabled?: boolean;
    status?: AgentStatus;
    createdAt: number;
    updatedAt: number;
}

/**
 * Defines the contract for a Task Worker, which is responsible for executing a specific type of task.
 * Task workers are registered with the `AgentRuntime` and are invoked when a `Task` of their designated `name` needs processing.
 * This pattern allows for modular and extensible background task processing.
 */
interface TaskWorker {
    /** The unique name of the task type this worker handles. This name links `Task` instances to this worker. */
    name: string;
    /**
     * The core execution logic for the task. This function is called by the runtime when a task needs to be processed.
     * It receives the `AgentRuntime`, task-specific `options`, and the `Task` object itself.
     */
    execute: (runtime: IAgentRuntime, options: {
        [key: string]: unknown;
    }, task: Task) => Promise<void>;
    /**
     * Optional validation function that can be used to determine if a task is valid or should be executed,
     * often based on the current message and state. This might be used by an action or evaluator
     * before creating or queueing a task.
     */
    validate?: (runtime: IAgentRuntime, message: Memory, state: State) => Promise<boolean>;
}
/**
 * Defines metadata associated with a `Task`.
 * This can include scheduling information like `updateInterval` or UI-related details
 * for presenting task options to a user.
 * The `[key: string]: unknown;` allows for additional, unspecified metadata fields.
 */
type TaskMetadata = {
    /** Optional. If the task is recurring, this specifies the interval in milliseconds between updates or executions. */
    updateInterval?: number;
    /** Optional. Describes options or parameters that can be configured for this task, often for UI presentation. */
    options?: {
        name: string;
        description: string;
    }[];
    /** Allows for other dynamic metadata properties related to the task. */
    [key: string]: unknown;
};
/**
 * Represents a task to be performed, often in the background or at a later time.
 * Tasks are managed by the `AgentRuntime` and processed by registered `TaskWorker`s.
 * They can be associated with a room, world, and tagged for categorization and retrieval.
 * The `IDatabaseAdapter` handles persistence of task data.
 */
interface Task {
    /** Optional. A Universally Unique Identifier for the task. Generated if not provided. */
    id?: UUID;
    /** The name of the task, which should correspond to a registered `TaskWorker.name`. */
    name: string;
    /** Optional. Timestamp of the last update to this task. */
    updatedAt?: number;
    /** Optional. Metadata associated with the task, conforming to `TaskMetadata`. */
    metadata?: TaskMetadata;
    /** A human-readable description of what the task does or its purpose. */
    description: string;
    /** Optional. The UUID of the room this task is associated with. */
    roomId?: UUID;
    /** Optional. The UUID of the world this task is associated with. */
    worldId?: UUID;
    entityId?: UUID;
    tags: string[];
}

/**
 * Represents a log entry
 */
interface Log {
    /** Optional unique identifier */
    id?: UUID;
    /** Associated entity ID */
    entityId: UUID;
    /** Associated room ID */
    roomId?: UUID;
    /** Log body */
    body: {
        [key: string]: unknown;
    };
    /** Log type */
    type: string;
    /** Log creation timestamp */
    createdAt: Date;
}
/**
 * Interface for database operations
 */
interface IDatabaseAdapter {
    /** Database instance */
    db: any;
    /** Initialize database connection */
    initialize(config?: any): Promise<void>;
    /** Initialize database connection */
    init(): Promise<void>;
    /** Run database migrations */
    runMigrations(schema?: any, pluginName?: string): Promise<void>;
    /** Check if the database connection is ready */
    isReady(): Promise<boolean>;
    /** Close database connection */
    close(): Promise<void>;
    getConnection(): Promise<any>;
    getAgent(agentId: UUID): Promise<Agent | null>;
    /** Get all agents */
    getAgents(): Promise<Partial<Agent>[]>;
    createAgent(agent: Partial<Agent>): Promise<boolean>;
    updateAgent(agentId: UUID, agent: Partial<Agent>): Promise<boolean>;
    deleteAgent(agentId: UUID): Promise<boolean>;
    ensureEmbeddingDimension(dimension: number): Promise<void>;
    /** Get entity by IDs */
    getEntityByIds(entityIds: UUID[]): Promise<Entity[] | null>;
    /** Get entities for room */
    getEntitiesForRoom(roomId: UUID, includeComponents?: boolean): Promise<Entity[]>;
    /** Create new entities */
    createEntities(entities: Entity[]): Promise<boolean>;
    /** Update entity */
    updateEntity(entity: Entity): Promise<void>;
    /** Get component by ID */
    getComponent(entityId: UUID, type: string, worldId?: UUID, sourceEntityId?: UUID): Promise<Component | null>;
    /** Get all components for an entity */
    getComponents(entityId: UUID, worldId?: UUID, sourceEntityId?: UUID): Promise<Component[]>;
    /** Create component */
    createComponent(component: Component): Promise<boolean>;
    /** Update component */
    updateComponent(component: Component): Promise<void>;
    /** Delete component */
    deleteComponent(componentId: UUID): Promise<void>;
    /** Get memories matching criteria */
    getMemories(params: {
        entityId?: UUID;
        agentId?: UUID;
        count?: number;
        unique?: boolean;
        tableName: string;
        start?: number;
        end?: number;
        roomId?: UUID;
        worldId?: UUID;
    }): Promise<Memory[]>;
    getMemoryById(id: UUID): Promise<Memory | null>;
    getMemoriesByIds(ids: UUID[], tableName?: string): Promise<Memory[]>;
    getMemoriesByRoomIds(params: {
        tableName: string;
        roomIds: UUID[];
        limit?: number;
    }): Promise<Memory[]>;
    getCachedEmbeddings(params: {
        query_table_name: string;
        query_threshold: number;
        query_input: string;
        query_field_name: string;
        query_field_sub_name: string;
        query_match_count: number;
    }): Promise<{
        embedding: number[];
        levenshtein_score: number;
    }[]>;
    log(params: {
        body: {
            [key: string]: unknown;
        };
        entityId: UUID;
        roomId: UUID;
        type: string;
    }): Promise<void>;
    getLogs(params: {
        entityId: UUID;
        roomId?: UUID;
        type?: string;
        count?: number;
        offset?: number;
    }): Promise<Log[]>;
    deleteLog(logId: UUID): Promise<void>;
    searchMemories(params: {
        embedding: number[];
        match_threshold?: number;
        count?: number;
        unique?: boolean;
        tableName: string;
        query?: string;
        roomId?: UUID;
        worldId?: UUID;
        entityId?: UUID;
    }): Promise<Memory[]>;
    createMemory(memory: Memory, tableName: string, unique?: boolean): Promise<UUID>;
    updateMemory(memory: Partial<Memory> & {
        id: UUID;
        metadata?: MemoryMetadata;
    }): Promise<boolean>;
    deleteMemory(memoryId: UUID): Promise<void>;
    deleteManyMemories(memoryIds: UUID[]): Promise<void>;
    deleteAllMemories(roomId: UUID, tableName: string): Promise<void>;
    countMemories(roomId: UUID, unique?: boolean, tableName?: string): Promise<number>;
    createWorld(world: World): Promise<UUID>;
    getWorld(id: UUID): Promise<World | null>;
    removeWorld(id: UUID): Promise<void>;
    getAllWorlds(): Promise<World[]>;
    updateWorld(world: World): Promise<void>;
    getRoomsByIds(roomIds: UUID[]): Promise<Room[] | null>;
    createRooms(rooms: Room[]): Promise<UUID[]>;
    deleteRoom(roomId: UUID): Promise<void>;
    deleteRoomsByWorldId(worldId: UUID): Promise<void>;
    updateRoom(room: Room): Promise<void>;
    getRoomsForParticipant(entityId: UUID): Promise<UUID[]>;
    getRoomsForParticipants(userIds: UUID[]): Promise<UUID[]>;
    getRoomsByWorld(worldId: UUID): Promise<Room[]>;
    removeParticipant(entityId: UUID, roomId: UUID): Promise<boolean>;
    getParticipantsForEntity(entityId: UUID): Promise<Participant[]>;
    getParticipantsForRoom(roomId: UUID): Promise<UUID[]>;
    addParticipantsRoom(entityIds: UUID[], roomId: UUID): Promise<boolean>;
    getParticipantUserState(roomId: UUID, entityId: UUID): Promise<'FOLLOWED' | 'MUTED' | null>;
    setParticipantUserState(roomId: UUID, entityId: UUID, state: 'FOLLOWED' | 'MUTED' | null): Promise<void>;
    /**
     * Creates a new relationship between two entities.
     * @param params Object containing the relationship details
     * @returns Promise resolving to boolean indicating success
     */
    createRelationship(params: {
        sourceEntityId: UUID;
        targetEntityId: UUID;
        tags?: string[];
        metadata?: Metadata;
    }): Promise<boolean>;
    /**
     * Updates an existing relationship between two entities.
     * @param relationship The relationship object with updated data
     * @returns Promise resolving to void
     */
    updateRelationship(relationship: Relationship): Promise<void>;
    /**
     * Retrieves a relationship between two entities if it exists.
     * @param params Object containing the entity IDs and agent ID
     * @returns Promise resolving to the Relationship object or null if not found
     */
    getRelationship(params: {
        sourceEntityId: UUID;
        targetEntityId: UUID;
    }): Promise<Relationship | null>;
    /**
     * Retrieves all relationships for a specific entity.
     * @param params Object containing the user ID, agent ID and optional tags to filter by
     * @returns Promise resolving to an array of Relationship objects
     */
    getRelationships(params: {
        entityId: UUID;
        tags?: string[];
    }): Promise<Relationship[]>;
    getCache<T>(key: string): Promise<T | undefined>;
    setCache<T>(key: string, value: T): Promise<boolean>;
    deleteCache(key: string): Promise<boolean>;
    createTask(task: Task): Promise<UUID>;
    getTasks(params: {
        roomId?: UUID;
        tags?: string[];
        entityId?: UUID;
    }): Promise<Task[]>;
    getTask(id: UUID): Promise<Task | null>;
    getTasksByName(name: string): Promise<Task[]>;
    updateTask(id: UUID, task: Partial<Task>): Promise<void>;
    deleteTask(id: UUID): Promise<void>;
    getMemoriesByWorldId(params: {
        worldId: UUID;
        count?: number;
        tableName?: string;
    }): Promise<Memory[]>;
}
/**
 * Result interface for embedding similarity searches
 */
interface EmbeddingSearchResult {
    embedding: number[];
    levenshtein_score: number;
}
/**
 * Options for memory retrieval operations
 */
interface MemoryRetrievalOptions {
    roomId: UUID;
    count?: number;
    unique?: boolean;
    start?: number;
    end?: number;
    agentId?: UUID;
}
/**
 * Options for memory search operations
 */
interface MemorySearchOptions {
    embedding: number[];
    match_threshold?: number;
    count?: number;
    roomId: UUID;
    agentId?: UUID;
    unique?: boolean;
    metadata?: Partial<MemoryMetadata>;
}
/**
 * Options for multi-room memory retrieval
 */
interface MultiRoomMemoryOptions {
    roomIds: UUID[];
    limit?: number;
    agentId?: UUID;
}
/**
 * Unified options pattern for memory operations
 * Provides a simpler, more consistent interface
 */
interface UnifiedMemoryOptions {
    roomId: UUID;
    limit?: number;
    agentId?: UUID;
    unique?: boolean;
    start?: number;
    end?: number;
}
/**
 * Specialized memory search options
 */
interface UnifiedSearchOptions extends UnifiedMemoryOptions {
    embedding: number[];
    similarity?: number;
}
/**
 * Represents a generic database connection object.
 * The actual type of this connection will depend on the specific database adapter implementation
 * (e.g., a connection pool object for PostgreSQL, a client instance for a NoSQL database).
 * This `unknown` type serves as a placeholder in the abstract `IDatabaseAdapter`.
 */
type DbConnection = unknown;
declare const VECTOR_DIMS: {
    readonly SMALL: 384;
    readonly MEDIUM: 512;
    readonly LARGE: 768;
    readonly XL: 1024;
    readonly XXL: 1536;
    readonly XXXL: 3072;
};

/**
 * Information describing the target of a message.
 */
interface TargetInfo {
    source: string;
    roomId?: UUID;
    channelId?: string;
    serverId?: string;
    entityId?: UUID;
    threadId?: string;
}
/**
 * Function signature for handlers responsible for sending messages to specific platforms.
 */
type SendHandlerFunction = (runtime: IAgentRuntime, target: TargetInfo, content: Content) => Promise<void>;
declare enum SOCKET_MESSAGE_TYPE {
    ROOM_JOINING = 1,
    SEND_MESSAGE = 2,
    MESSAGE = 3,
    ACK = 4,
    THINKING = 5,
    CONTROL = 6
}
/**
 * Interface for control messages sent from the backend to the frontend
 * to manage UI state and interaction capabilities
 */
interface ControlMessage {
    /** Message type identifier */
    type: 'control';
    /** Control message payload */
    payload: {
        /** Action to perform */
        action: 'disable_input' | 'enable_input';
        /** Optional target element identifier */
        target?: string;
        /** Additional optional parameters */
        [key: string]: unknown;
    };
    /** Room ID to ensure signal is directed to the correct chat window */
    roomId: UUID;
}

type ModelTypeName = (typeof ModelType)[keyof typeof ModelType] | string;
/**
 * Defines the recognized types of models that the agent runtime can use.
 * These include models for text generation (small, large, reasoning, completion),
 * text embedding, tokenization (encode/decode), image generation and description,
 * audio transcription, text-to-speech, and generic object generation.
 * This constant is used throughout the system, particularly in `AgentRuntime.useModel`,
 * `AgentRuntime.registerModel`, and in `ModelParamsMap` / `ModelResultMap` to ensure
 * type safety and clarity when working with different AI models.
 * String values are used for extensibility with custom model types.
 */
declare const ModelType: {
    readonly SMALL: "TEXT_SMALL";
    readonly MEDIUM: "TEXT_LARGE";
    readonly LARGE: "TEXT_LARGE";
    readonly TEXT_SMALL: "TEXT_SMALL";
    readonly TEXT_LARGE: "TEXT_LARGE";
    readonly TEXT_EMBEDDING: "TEXT_EMBEDDING";
    readonly TEXT_TOKENIZER_ENCODE: "TEXT_TOKENIZER_ENCODE";
    readonly TEXT_TOKENIZER_DECODE: "TEXT_TOKENIZER_DECODE";
    readonly TEXT_REASONING_SMALL: "REASONING_SMALL";
    readonly TEXT_REASONING_LARGE: "REASONING_LARGE";
    readonly TEXT_COMPLETION: "TEXT_COMPLETION";
    readonly IMAGE: "IMAGE";
    readonly IMAGE_DESCRIPTION: "IMAGE_DESCRIPTION";
    readonly TRANSCRIPTION: "TRANSCRIPTION";
    readonly TEXT_TO_SPEECH: "TEXT_TO_SPEECH";
    readonly AUDIO: "AUDIO";
    readonly VIDEO: "VIDEO";
    readonly OBJECT_SMALL: "OBJECT_SMALL";
    readonly OBJECT_LARGE: "OBJECT_LARGE";
};
/**
 * Parameters for generating text using a language model.
 * This structure is typically passed to `AgentRuntime.useModel` when the `modelType` is one of
 * `ModelType.TEXT_SMALL`, `ModelType.TEXT_LARGE`, `ModelType.TEXT_REASONING_SMALL`,
 * `ModelType.TEXT_REASONING_LARGE`, or `ModelType.TEXT_COMPLETION`.
 * It includes essential information like the prompt, model type, and various generation controls.
 */
type GenerateTextParams = {
    /** The `AgentRuntime` instance, providing access to models and other services. */
    runtime: IAgentRuntime;
    /** The input string or prompt that the language model will use to generate text. */
    prompt: string;
    /** Specifies the type of text generation model to use (e.g., TEXT_LARGE, REASONING_SMALL). */
    modelType: ModelTypeName;
    /** Optional. The maximum number of tokens to generate in the response. */
    maxTokens?: number;
    /** Optional. Controls randomness (0.0-1.0). Lower values are more deterministic, higher are more creative. */
    temperature?: number;
    /** Optional. Penalizes new tokens based on their existing frequency in the text so far. */
    frequencyPenalty?: number;
    /** Optional. Penalizes new tokens based on whether they appear in the text so far. */
    presencePenalty?: number;
    /** Optional. A list of sequences at which the model will stop generating further tokens. */
    stopSequences?: string[];
};
/**
 * Parameters for detokenizing text, i.e., converting a sequence of numerical tokens back into a string.
 * This is the reverse operation of tokenization.
 * This structure is used with `AgentRuntime.useModel` when the `modelType` is `ModelType.TEXT_TOKENIZER_DECODE`.
 */
interface DetokenizeTextParams {
    /** An array of numerical tokens to be converted back into text. */
    tokens: number[];
    /** The model type used for detokenization, ensuring consistency with the original tokenization. */
    modelType: ModelTypeName;
}
/**
 * Base parameters common to all model types
 */
interface BaseModelParams {
    /** The agent runtime for accessing services and utilities */
    runtime: IAgentRuntime;
}
/**
 * Parameters for text generation models
 */
interface TextGenerationParams extends BaseModelParams {
    /** The prompt to generate text from */
    prompt: string;
    /** Model temperature (0.0 to 1.0, lower is more deterministic) */
    temperature?: number;
    /** Maximum number of tokens to generate */
    maxTokens?: number;
    /** Sequences that should stop generation when encountered */
    stopSequences?: string[];
    /** Frequency penalty to apply */
    frequencyPenalty?: number;
    /** Presence penalty to apply */
    presencePenalty?: number;
}
/**
 * Parameters for text embedding models
 */
interface TextEmbeddingParams extends BaseModelParams {
    /** The text to create embeddings for */
    text: string;
}
/**
 * Parameters for text tokenization models
 */
interface TokenizeTextParams extends BaseModelParams {
    /** The text to tokenize */
    prompt: string;
    /** The model type to use for tokenization */
    modelType: ModelTypeName;
}
/**
 * Parameters for image generation models
 */
interface ImageGenerationParams extends BaseModelParams {
    /** The prompt describing the image to generate */
    prompt: string;
    /** The dimensions of the image to generate */
    size?: string;
    /** Number of images to generate */
    count?: number;
}
/**
 * Parameters for image description models
 */
interface ImageDescriptionParams extends BaseModelParams {
    /** The URL or path of the image to describe */
    imageUrl: string;
    /** Optional prompt to guide the description */
    prompt?: string;
}
/**
 * Parameters for transcription models
 */
interface TranscriptionParams extends BaseModelParams {
    /** The URL or path of the audio file to transcribe */
    audioUrl: string;
    /** Optional prompt to guide transcription */
    prompt?: string;
}
/**
 * Parameters for text-to-speech models
 */
interface TextToSpeechParams extends BaseModelParams {
    /** The text to convert to speech */
    text: string;
    /** The voice to use */
    voice?: string;
    /** The speaking speed */
    speed?: number;
}
/**
 * Parameters for audio processing models
 */
interface AudioProcessingParams extends BaseModelParams {
    /** The URL or path of the audio file to process */
    audioUrl: string;
    /** The type of audio processing to perform */
    processingType: string;
}
/**
 * Parameters for video processing models
 */
interface VideoProcessingParams extends BaseModelParams {
    /** The URL or path of the video file to process */
    videoUrl: string;
    /** The type of video processing to perform */
    processingType: string;
}
/**
 * Optional JSON schema for validating generated objects
 */
type JSONSchema = {
    type: string;
    properties?: Record<string, any>;
    required?: string[];
    items?: JSONSchema;
    [key: string]: any;
};
/**
 * Parameters for object generation models
 * @template T - The expected return type, inferred from schema if provided
 */
interface ObjectGenerationParams extends BaseModelParams {
    /** The prompt describing the object to generate */
    prompt: string;
    /** Optional JSON schema for validation */
    schema?: JSONSchema;
    /** Type of object to generate */
    output?: 'object' | 'array' | 'enum';
    /** For enum type, the allowed values */
    enumValues?: string[];
    /** Model type to use */
    modelType?: ModelTypeName;
    /** Model temperature (0.0 to 1.0) */
    temperature?: number;
    /** Sequences that should stop generation */
    stopSequences?: string[];
}
/**
 * Map of model types to their parameter types
 */
interface ModelParamsMap {
    [ModelType.TEXT_SMALL]: TextGenerationParams;
    [ModelType.TEXT_LARGE]: TextGenerationParams;
    [ModelType.TEXT_EMBEDDING]: TextEmbeddingParams | string | null;
    [ModelType.TEXT_TOKENIZER_ENCODE]: TokenizeTextParams;
    [ModelType.TEXT_TOKENIZER_DECODE]: DetokenizeTextParams;
    [ModelType.TEXT_REASONING_SMALL]: TextGenerationParams;
    [ModelType.TEXT_REASONING_LARGE]: TextGenerationParams;
    [ModelType.IMAGE]: ImageGenerationParams;
    [ModelType.IMAGE_DESCRIPTION]: ImageDescriptionParams | string;
    [ModelType.TRANSCRIPTION]: TranscriptionParams | Buffer | string;
    [ModelType.TEXT_TO_SPEECH]: TextToSpeechParams | string;
    [ModelType.AUDIO]: AudioProcessingParams;
    [ModelType.VIDEO]: VideoProcessingParams;
    [ModelType.OBJECT_SMALL]: ObjectGenerationParams;
    [ModelType.OBJECT_LARGE]: ObjectGenerationParams;
    [key: string]: BaseModelParams | any;
}
/**
 * Map of model types to their return value types
 */
interface ModelResultMap {
    [ModelType.TEXT_SMALL]: string;
    [ModelType.TEXT_LARGE]: string;
    [ModelType.TEXT_EMBEDDING]: number[];
    [ModelType.TEXT_TOKENIZER_ENCODE]: number[];
    [ModelType.TEXT_TOKENIZER_DECODE]: string;
    [ModelType.TEXT_REASONING_SMALL]: string;
    [ModelType.TEXT_REASONING_LARGE]: string;
    [ModelType.IMAGE]: {
        url: string;
    }[];
    [ModelType.IMAGE_DESCRIPTION]: {
        title: string;
        description: string;
    };
    [ModelType.TRANSCRIPTION]: string;
    [ModelType.TEXT_TO_SPEECH]: any | Buffer;
    [ModelType.AUDIO]: any;
    [ModelType.VIDEO]: any;
    [ModelType.OBJECT_SMALL]: any;
    [ModelType.OBJECT_LARGE]: any;
    [key: string]: any;
}
/**
 * Defines the structure for a model handler registration within the `AgentRuntime`.
 * Each model (e.g., for text generation, embedding) is associated with a handler function,
 * the name of the provider (plugin or system) that registered it, and an optional priority.
 * The `priority` (higher is more preferred) helps in selecting which handler to use if multiple
 * handlers are registered for the same model type. The `registrationOrder` (not in type, but used in runtime)
 * serves as a tie-breaker. See `AgentRuntime.registerModel` and `AgentRuntime.getModel`.
 */
interface ModelHandler {
    /** The function that executes the model, taking runtime and parameters, and returning a Promise. */
    handler: (runtime: IAgentRuntime, params: Record<string, unknown>) => Promise<unknown>;
    /** The name of the provider (e.g., plugin name) that registered this model handler. */
    provider: string;
    /**
     * Optional priority for this model handler. Higher numbers indicate higher priority.
     * This is used by `AgentRuntime.getModel` to select the most appropriate handler
     * when multiple are available for a given model type. Defaults to 0 if not specified.
     */
    priority?: number;
    registrationOrder?: number;
}

/**
 * Standard event types across all platforms
 */
declare enum EventType {
    WORLD_JOINED = "WORLD_JOINED",
    WORLD_CONNECTED = "WORLD_CONNECTED",
    WORLD_LEFT = "WORLD_LEFT",
    ENTITY_JOINED = "ENTITY_JOINED",
    ENTITY_LEFT = "ENTITY_LEFT",
    ENTITY_UPDATED = "ENTITY_UPDATED",
    ROOM_JOINED = "ROOM_JOINED",
    ROOM_LEFT = "ROOM_LEFT",
    MESSAGE_RECEIVED = "MESSAGE_RECEIVED",
    MESSAGE_SENT = "MESSAGE_SENT",
    MESSAGE_DELETED = "MESSAGE_DELETED",
    CHANNEL_CLEARED = "CHANNEL_CLEARED",
    VOICE_MESSAGE_RECEIVED = "VOICE_MESSAGE_RECEIVED",
    VOICE_MESSAGE_SENT = "VOICE_MESSAGE_SENT",
    REACTION_RECEIVED = "REACTION_RECEIVED",
    POST_GENERATED = "POST_GENERATED",
    INTERACTION_RECEIVED = "INTERACTION_RECEIVED",
    RUN_STARTED = "RUN_STARTED",
    RUN_ENDED = "RUN_ENDED",
    RUN_TIMEOUT = "RUN_TIMEOUT",
    ACTION_STARTED = "ACTION_STARTED",
    ACTION_COMPLETED = "ACTION_COMPLETED",
    EVALUATOR_STARTED = "EVALUATOR_STARTED",
    EVALUATOR_COMPLETED = "EVALUATOR_COMPLETED",
    MODEL_USED = "MODEL_USED"
}
/**
 * Platform-specific event type prefix
 */
declare enum PlatformPrefix {
    DISCORD = "DISCORD",
    TELEGRAM = "TELEGRAM",
    TWITTER = "TWITTER"
}
/**
 * Base payload interface for all events
 */
interface EventPayload {
    runtime: IAgentRuntime;
    source: string;
    onComplete?: () => void;
}
/**
 * Payload for world-related events
 */
interface WorldPayload extends EventPayload {
    world: World;
    rooms: Room[];
    entities: Entity[];
}
/**
 * Payload for entity-related events
 */
interface EntityPayload extends EventPayload {
    entityId: UUID;
    worldId?: UUID;
    roomId?: UUID;
    metadata?: {
        orginalId: string;
        username: string;
        displayName?: string;
        [key: string]: any;
    };
}
/**
 * Payload for reaction-related events
 */
interface MessagePayload extends EventPayload {
    message: Memory;
    callback?: HandlerCallback;
    onComplete?: () => void;
}
/**
 * Payload for channel cleared events
 */
interface ChannelClearedPayload extends EventPayload {
    roomId: UUID;
    channelId: string;
    memoryCount: number;
}
/**
 * Payload for events that are invoked without a message
 */
interface InvokePayload extends EventPayload {
    worldId: UUID;
    userId: string;
    roomId: UUID;
    callback?: HandlerCallback;
    source: string;
}
/**
 * Run event payload type
 */
interface RunEventPayload extends EventPayload {
    runId: UUID;
    messageId: UUID;
    roomId: UUID;
    entityId: UUID;
    startTime: number;
    status: 'started' | 'completed' | 'timeout';
    endTime?: number;
    duration?: number;
    error?: string;
}
/**
 * Action event payload type
 */
interface ActionEventPayload extends EventPayload {
    actionId: UUID;
    actionName: string;
    startTime?: number;
    completed?: boolean;
    error?: Error;
}
/**
 * Evaluator event payload type
 */
interface EvaluatorEventPayload extends EventPayload {
    evaluatorId: UUID;
    evaluatorName: string;
    startTime?: number;
    completed?: boolean;
    error?: Error;
}
/**
 * Model event payload type
 */
interface ModelEventPayload extends EventPayload {
    provider: string;
    type: ModelTypeName;
    prompt: string;
    tokens?: {
        prompt: number;
        completion: number;
        total: number;
    };
}
type MessageReceivedHandlerParams = {
    runtime: IAgentRuntime;
    message: Memory;
    callback: HandlerCallback;
    onComplete?: () => void;
};
/**
 * Maps event types to their corresponding payload types
 */
interface EventPayloadMap {
    [EventType.WORLD_JOINED]: WorldPayload;
    [EventType.WORLD_CONNECTED]: WorldPayload;
    [EventType.WORLD_LEFT]: WorldPayload;
    [EventType.ENTITY_JOINED]: EntityPayload;
    [EventType.ENTITY_LEFT]: EntityPayload;
    [EventType.ENTITY_UPDATED]: EntityPayload;
    [EventType.MESSAGE_RECEIVED]: MessagePayload;
    [EventType.MESSAGE_SENT]: MessagePayload;
    [EventType.MESSAGE_DELETED]: MessagePayload;
    [EventType.CHANNEL_CLEARED]: ChannelClearedPayload;
    [EventType.REACTION_RECEIVED]: MessagePayload;
    [EventType.POST_GENERATED]: InvokePayload;
    [EventType.INTERACTION_RECEIVED]: MessagePayload;
    [EventType.RUN_STARTED]: RunEventPayload;
    [EventType.RUN_ENDED]: RunEventPayload;
    [EventType.RUN_TIMEOUT]: RunEventPayload;
    [EventType.ACTION_STARTED]: ActionEventPayload;
    [EventType.ACTION_COMPLETED]: ActionEventPayload;
    [EventType.EVALUATOR_STARTED]: EvaluatorEventPayload;
    [EventType.EVALUATOR_COMPLETED]: EvaluatorEventPayload;
    [EventType.MODEL_USED]: ModelEventPayload;
}
/**
 * Event handler function type
 */
type EventHandler<T extends keyof EventPayloadMap> = (payload: EventPayloadMap[T]) => Promise<void>;
/**
 * Defines a more specific type for event handlers, expecting an `Metadata`.
 * This aims to improve upon generic 'any' type handlers, providing a clearer contract
 * for functions that respond to events emitted within the agent runtime (see `emitEvent` in `AgentRuntime`).
 * Handlers can be synchronous or asynchronous.
 */
type TypedEventHandler = (data: Metadata) => Promise<void> | void;

/**
 * Core service type registry that can be extended by plugins via module augmentation.
 * Plugins can extend this interface to add their own service types:
 *
 * @example
 * ```typescript
 * declare module '@elizaos/core' {
 *   interface ServiceTypeRegistry {
 *     MY_CUSTOM_SERVICE: 'my_custom_service';
 *   }
 * }
 * ```
 */
interface ServiceTypeRegistry {
    TRANSCRIPTION: 'transcription';
    VIDEO: 'video';
    BROWSER: 'browser';
    PDF: 'pdf';
    REMOTE_FILES: 'aws_s3';
    WEB_SEARCH: 'web_search';
    EMAIL: 'email';
    TEE: 'tee';
    TASK: 'task';
    WALLET: 'wallet';
    LP_POOL: 'lp_pool';
    TOKEN_DATA: 'token_data';
    DATABASE_MIGRATION: 'database_migration';
    PLUGIN_MANAGER: 'PLUGIN_MANAGER';
    PLUGIN_CONFIGURATION: 'PLUGIN_CONFIGURATION';
    PLUGIN_USER_INTERACTION: 'PLUGIN_USER_INTERACTION';
}
/**
 * Type for service names that includes both core services and any plugin-registered services
 */
type ServiceTypeName = ServiceTypeRegistry[keyof ServiceTypeRegistry];
/**
 * Helper type to extract service type values from the registry
 */
type ServiceTypeValue<K extends keyof ServiceTypeRegistry> = ServiceTypeRegistry[K];
/**
 * Helper type to check if a service type exists in the registry
 */
type IsValidServiceType<T extends string> = T extends ServiceTypeName ? true : false;
/**
 * Type-safe service class definition
 */
type TypedServiceClass<T extends ServiceTypeName> = {
    new (runtime?: IAgentRuntime): Service;
    serviceType: T;
    start(runtime: IAgentRuntime): Promise<Service>;
};
/**
 * Map of service type names to their implementation classes
 */
interface ServiceClassMap {
}
/**
 * Helper to infer service instance type from service type name
 */
type ServiceInstance<T extends ServiceTypeName> = T extends keyof ServiceClassMap ? InstanceType<ServiceClassMap[T]> : Service;
/**
 * Runtime service registry type
 */
type ServiceRegistry<T extends ServiceTypeName = ServiceTypeName> = Map<T, Service>;
/**
 * Enumerates the recognized types of services that can be registered and used by the agent runtime.
 * Services provide specialized functionalities like audio transcription, video processing,
 * web browsing, PDF handling, file storage (e.g., AWS S3), web search, email integration,
 * secure execution via TEE (Trusted Execution Environment), and task management.
 * This constant is used in `AgentRuntime` for service registration and retrieval (e.g., `getService`).
 * Each service typically implements the `Service` abstract class or a more specific interface like `IVideoService`.
 */
declare const ServiceType: {
    readonly TRANSCRIPTION: "transcription";
    readonly VIDEO: "video";
    readonly BROWSER: "browser";
    readonly PDF: "pdf";
    readonly REMOTE_FILES: "aws_s3";
    readonly WEB_SEARCH: "web_search";
    readonly EMAIL: "email";
    readonly TEE: "tee";
    readonly TASK: "task";
    readonly WALLET: "wallet";
    readonly LP_POOL: "lp_pool";
    readonly TOKEN_DATA: "token_data";
    readonly DATABASE_MIGRATION: "database_migration";
    readonly PLUGIN_MANAGER: "PLUGIN_MANAGER";
    readonly PLUGIN_CONFIGURATION: "PLUGIN_CONFIGURATION";
    readonly PLUGIN_USER_INTERACTION: "PLUGIN_USER_INTERACTION";
};
/**
 * Client instance
 */
declare abstract class Service {
    /** Runtime instance */
    protected runtime: IAgentRuntime;
    constructor(runtime?: IAgentRuntime);
    abstract stop(): Promise<void>;
    /** Service type */
    static serviceType: string;
    /** Service name */
    abstract capabilityDescription: string;
    /** Service configuration */
    config?: Metadata;
    /** Start service connection */
    static start(_runtime: IAgentRuntime): Promise<Service>;
    /** Stop service connection */
    static stop(_runtime: IAgentRuntime): Promise<unknown>;
}
/**
 * Generic service interface that provides better type checking for services
 * @template ConfigType The configuration type for this service
 * @template ResultType The result type returned by the service operations
 */
interface TypedService<ConfigType extends Metadata = Metadata, ResultType = unknown> extends Service {
    /**
     * The configuration for this service instance
     */
    config?: ConfigType;
    /**
     * Process an input with this service
     * @param input The input to process
     * @returns A promise resolving to the result
     */
    process(input: unknown): Promise<ResultType>;
}
/**
 * Generic factory function to create a typed service instance
 * @param runtime The agent runtime
 * @param serviceType The type of service to get
 * @returns The service instance or null if not available
 */
declare function getTypedService<T extends TypedService<any, any>>(runtime: IAgentRuntime, serviceType: ServiceTypeName): T | null;
/**
 * Standardized service error type for consistent error handling
 */
interface ServiceError {
    code: string;
    message: string;
    details?: unknown;
    cause?: Error;
}
/**
 * Safely create a ServiceError from any caught error
 */
declare function createServiceError(error: unknown, code?: string): ServiceError;

/**
 * Represents a test case for evaluating agent or plugin functionality.
 * Each test case has a name and a function that contains the test logic.
 * The test function receives the `IAgentRuntime` instance, allowing it to interact with the agent's capabilities.
 * Test cases are typically grouped into `TestSuite`s.
 */
interface TestCase {
    /** A descriptive name for the test case, e.g., "should respond to greetings". */
    name: string;
    /**
     * The function that executes the test logic. It can be synchronous or asynchronous.
     * It receives the `IAgentRuntime` to interact with the agent and its services.
     * The function should typically contain assertions to verify expected outcomes.
     */
    fn: (runtime: IAgentRuntime) => Promise<void> | void;
}
/**
 * Represents a suite of related test cases for an agent or plugin.
 * This helps in organizing tests and running them collectively.
 * A `ProjectAgent` can define one or more `TestSuite`s.
 */
interface TestSuite {
    /** A descriptive name for the test suite, e.g., "Core Functionality Tests". */
    name: string;
    /** An array of `TestCase` objects that belong to this suite. */
    tests: TestCase[];
}

type Route = {
    type: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'STATIC';
    path: string;
    filePath?: string;
    public?: boolean;
    name?: string extends {
        public: true;
    } ? string : string | undefined;
    handler?: (req: any, res: any, runtime: IAgentRuntime) => Promise<void>;
    isMultipart?: boolean;
};
/**
 * Plugin for extending agent functionality
 */
type PluginEvents = {
    [K in keyof EventPayloadMap]?: EventHandler<K>[];
} & {
    [key: string]: ((params: any) => Promise<any>)[];
};
interface Plugin {
    name: string;
    description: string;
    init?: (config: Record<string, string>, runtime: IAgentRuntime) => Promise<void>;
    config?: {
        [key: string]: any;
    };
    services?: (typeof Service)[];
    componentTypes?: {
        name: string;
        schema: Record<string, unknown>;
        validator?: (data: any) => boolean;
    }[];
    actions?: Action[];
    providers?: Provider[];
    evaluators?: Evaluator[];
    adapter?: IDatabaseAdapter;
    models?: {
        [key: string]: (...args: any[]) => Promise<any>;
    };
    events?: PluginEvents;
    routes?: Route[];
    tests?: TestSuite[];
    dependencies?: string[];
    testDependencies?: string[];
    priority?: number;
    schema?: any;
}
interface ProjectAgent {
    character: Character;
    init?: (runtime: IAgentRuntime) => Promise<void>;
    plugins?: Plugin[];
    tests?: TestSuite | TestSuite[];
}
interface Project {
    agents: ProjectAgent[];
}

/**
 * Represents the core runtime environment for an agent.
 * Defines methods for database interaction, plugin management, event handling,
 * state composition, model usage, and task management.
 */
interface IAgentRuntime extends IDatabaseAdapter {
    agentId: UUID;
    character: Character;
    providers: Provider[];
    actions: Action[];
    evaluators: Evaluator[];
    plugins: Plugin[];
    services: Map<ServiceTypeName, Service>;
    events: Map<string, ((params: any) => Promise<void>)[]>;
    fetch?: typeof fetch | null;
    routes: Route[];
    registerPlugin(plugin: Plugin): Promise<void>;
    initialize(): Promise<void>;
    getConnection(): Promise<any>;
    getService<T extends Service>(service: ServiceTypeName | string): T | null;
    getAllServices(): Map<ServiceTypeName, Service>;
    registerService(service: typeof Service): Promise<void>;
    registerDatabaseAdapter(adapter: IDatabaseAdapter): void;
    setSetting(key: string, value: string | boolean | null | any, secret?: boolean): void;
    getSetting(key: string): string | boolean | null | any;
    getConversationLength(): number;
    processActions(message: Memory, responses: Memory[], state?: State, callback?: HandlerCallback): Promise<void>;
    evaluate(message: Memory, state?: State, didRespond?: boolean, callback?: HandlerCallback, responses?: Memory[]): Promise<Evaluator[] | null>;
    registerProvider(provider: Provider): void;
    registerAction(action: Action): void;
    registerEvaluator(evaluator: Evaluator): void;
    ensureConnections(entities: Entity[], rooms: Room[], source: string, world: World): Promise<void>;
    ensureConnection({ entityId, roomId, metadata, userName, worldName, name, source, channelId, serverId, type, worldId, userId, }: {
        entityId: UUID;
        roomId: UUID;
        userName?: string;
        name?: string;
        worldName?: string;
        source?: string;
        channelId?: string;
        serverId?: string;
        type: any;
        worldId: UUID;
        userId?: UUID;
        metadata?: Record<string, any>;
    }): Promise<void>;
    ensureParticipantInRoom(entityId: UUID, roomId: UUID): Promise<void>;
    ensureWorldExists(world: World): Promise<void>;
    ensureRoomExists(room: Room): Promise<void>;
    composeState(message: Memory, includeList?: string[], onlyInclude?: boolean, skipCache?: boolean): Promise<State>;
    useModel<T extends ModelTypeName, R = ModelResultMap[T]>(modelType: T, params: Omit<ModelParamsMap[T], 'runtime'> | any): Promise<R>;
    registerModel(modelType: ModelTypeName | string, handler: (params: any) => Promise<any>, provider: string, priority?: number): void;
    getModel(modelType: ModelTypeName | string): ((runtime: IAgentRuntime, params: any) => Promise<any>) | undefined;
    registerEvent(event: string, handler: (params: any) => Promise<void>): void;
    getEvent(event: string): ((params: any) => Promise<void>)[] | undefined;
    emitEvent(event: string | string[], params: any): Promise<void>;
    registerTaskWorker(taskHandler: TaskWorker): void;
    getTaskWorker(name: string): TaskWorker | undefined;
    stop(): Promise<void>;
    addEmbeddingToMemory(memory: Memory): Promise<Memory>;
    getAllMemories(): Promise<Memory[]>;
    clearAllAgentMemories(): Promise<void>;
    createRunId(): UUID;
    startRun(): UUID;
    endRun(): void;
    getCurrentRunId(): UUID;
    getEntityById(entityId: UUID): Promise<Entity | null>;
    getRoom(roomId: UUID): Promise<Room | null>;
    createEntity(entity: Entity): Promise<boolean>;
    createRoom({ id, name, source, type, channelId, serverId, worldId }: Room): Promise<UUID>;
    addParticipant(entityId: UUID, roomId: UUID): Promise<boolean>;
    getRooms(worldId: UUID): Promise<Room[]>;
    registerSendHandler(source: string, handler: SendHandlerFunction): void;
    sendMessageToTarget(target: TargetInfo, content: Content): Promise<void>;
}

/**
 * Example content with associated user for demonstration purposes
 */
interface ActionExample {
    /** User associated with the example */
    name: string;
    /** Content of the example */
    content: Content;
}
/**
 * Callback function type for handlers
 */
type HandlerCallback = (response: Content, files?: any) => Promise<Memory[]>;
/**
 * Handler function type for processing messages
 */
type Handler = (runtime: IAgentRuntime, message: Memory, state?: State, options?: {
    [key: string]: unknown;
}, callback?: HandlerCallback, responses?: Memory[]) => Promise<unknown>;
/**
 * Validator function type for actions/evaluators
 */
type Validator = (runtime: IAgentRuntime, message: Memory, state?: State) => Promise<boolean>;
/**
 * Represents an action the agent can perform
 */
interface Action {
    /** Similar action descriptions */
    similes?: string[];
    /** Detailed description */
    description: string;
    /** Example usages */
    examples?: ActionExample[][];
    /** Handler function */
    handler: Handler;
    /** Action name */
    name: string;
    /** Validation function */
    validate: Validator;
}
/**
 * Example for evaluating agent behavior
 */
interface EvaluationExample {
    /** Evaluation context */
    prompt: string;
    /** Example messages */
    messages: Array<ActionExample>;
    /** Expected outcome */
    outcome: string;
}
/**
 * Evaluator for assessing agent responses
 */
interface Evaluator {
    /** Whether to always run */
    alwaysRun?: boolean;
    /** Detailed description */
    description: string;
    /** Similar evaluator descriptions */
    similes?: string[];
    /** Example evaluations */
    examples: EvaluationExample[];
    /** Handler function */
    handler: Handler;
    /** Evaluator name */
    name: string;
    /** Validation function */
    validate: Validator;
}
interface ProviderResult {
    values?: {
        [key: string]: any;
    };
    data?: {
        [key: string]: any;
    };
    text?: string;
}
/**
 * Provider for external data/services
 */
interface Provider {
    /** Provider name */
    name: string;
    /** Description of the provider */
    description?: string;
    /** Whether the provider is dynamic */
    dynamic?: boolean;
    /** Position of the provider in the provider list, positive or negative */
    position?: number;
    /**
     * Whether the provider is private
     *
     * Private providers are not displayed in the regular provider list, they have to be called explicitly
     */
    private?: boolean;
    /** Data retrieval function */
    get: (runtime: IAgentRuntime, message: Memory, state: State) => Promise<ProviderResult>;
}

/**
 * Interface representing settings with string key-value pairs.
 */
interface RuntimeSettings {
    [key: string]: string | undefined;
}
interface Setting {
    name: string;
    description: string;
    usageDescription: string;
    value: string | boolean | null;
    required: boolean;
    public?: boolean;
    secret?: boolean;
    validation?: (value: any) => boolean;
    dependsOn?: string[];
    onSetAction?: (value: any) => string;
    visibleIf?: (settings: {
        [key: string]: Setting;
    }) => boolean;
}
interface WorldSettings {
    [key: string]: Setting;
}
interface OnboardingConfig {
    settings: {
        [key: string]: Omit<Setting, 'value'>;
    };
}

/**
 * Service builder class that provides type-safe service creation
 * with automatic type inference
 */
declare class ServiceBuilder$1<TService extends Service = Service> {
    protected serviceType: ServiceTypeName | string;
    protected startFn: (runtime: IAgentRuntime) => Promise<TService>;
    protected stopFn?: () => Promise<void>;
    protected description: string;
    constructor(serviceType: ServiceTypeName | string);
    /**
     * Set the service description
     */
    withDescription(description: string): this;
    /**
     * Set the start function for the service
     */
    withStart(startFn: (runtime: IAgentRuntime) => Promise<TService>): this;
    /**
     * Set the stop function for the service
     */
    withStop(stopFn: () => Promise<void>): this;
    /**
     * Build the service class with all configured properties
     */
    build(): new (runtime?: IAgentRuntime) => TService;
}
/**
 * Create a type-safe service builder
 * @param serviceType - The service type name
 * @returns A new ServiceBuilder instance
 */
declare function createService$1<TService extends Service = Service>(serviceType: ServiceTypeName | string): ServiceBuilder$1<TService>;
/**
 * Type-safe service definition helper
 */
interface ServiceDefinition$1<T extends Service = Service> {
    serviceType: ServiceTypeName;
    description: string;
    start: (runtime: IAgentRuntime) => Promise<T>;
    stop?: () => Promise<void>;
}
/**
 * Define a service with type safety
 */
declare function defineService$1<T extends Service = Service>(definition: ServiceDefinition$1<T>): new (runtime?: IAgentRuntime) => T;

/**
 * Compose a specified number of random action examples from the given actionsData.
 *
 * @param {Action[]} actionsData - The list of actions to generate examples from.
 * @param {number} count - The number of examples to compose.
 * @returns {string} The formatted action examples.
 */
declare const composeActionExamples: (actionsData: Action$1[], count: number) => string;
/**
 * Formats the names of the provided actions into a comma-separated string.
 * @param actions - An array of `Action` objects from which to extract names.
 * @returns A comma-separated string of action names.
 */
declare function formatActionNames(actions: Action$1[]): string;
/**
 * Formats the provided actions into a detailed string listing each action's name and description, separated by commas and newlines.
 * @param actions - An array of `Action` objects to format.
 * @returns A detailed string of actions, including names and descriptions.
 */
declare function formatActions(actions: Action$1[]): string;

/**
 * Database adapter class to be extended by individual database adapters.
 *
 * @template DB - The type of the database instance.
 * @abstract
 * @implements {IDatabaseAdapter}
 */
declare abstract class DatabaseAdapter<DB = unknown> implements IDatabaseAdapter$1 {
    /**
     * The database instance.
     */
    db: DB;
    /**
     * Creates a new DatabaseAdapter instance.
     * @param db The database instance to use.
     */
    constructor(db: DB);
    /**
     * Initialize the database adapter.
     * @returns A Promise that resolves when initialization is complete.
     */
    abstract init(): Promise<void>;
    /**
     * Optional close method for the database adapter.
     * @returns A Promise that resolves when closing is complete.
     */
    abstract close(): Promise<void>;
    /**
     * Retrieves a connection to the database.
     * @returns A Promise that resolves to the database connection.
     */
    abstract getConnection(): Promise<any>;
    /**
     * Retrieves an account by its ID.
     * @param entityIds The UUIDs of the user account to retrieve.
     * @returns A Promise that resolves to the Entity object or null if not found.
     */
    abstract getEntityByIds(entityIds: UUID$1[]): Promise<Entity$1[] | null>;
    abstract getEntitiesForRoom(roomId: UUID$1, includeComponents?: boolean): Promise<Entity$1[]>;
    /**
     * Creates a new entities in the database.
     * @param entities The entity objects to create.
     * @returns A Promise that resolves when the account creation is complete.
     */
    abstract createEntities(entities: Entity$1[]): Promise<boolean>;
    /**
     * Updates an existing entity in the database.
     * @param entity The entity object with updated properties.
     * @returns A Promise that resolves when the account update is complete.
     */
    abstract updateEntity(entity: Entity$1): Promise<void>;
    /**
     * Retrieves a single component by entity ID and type.
     * @param entityId The UUID of the entity the component belongs to
     * @param type The type identifier for the component
     * @param worldId Optional UUID of the world the component belongs to
     * @param sourceEntityId Optional UUID of the source entity
     * @returns Promise resolving to the Component if found, null otherwise
     */
    abstract getComponent(entityId: UUID$1, type: string, worldId?: UUID$1, sourceEntityId?: UUID$1): Promise<Component$1 | null>;
    /**
     * Retrieves all components for an entity.
     * @param entityId The UUID of the entity to get components for
     * @param worldId Optional UUID of the world to filter components by
     * @param sourceEntityId Optional UUID of the source entity to filter by
     * @returns Promise resolving to array of Component objects
     */
    abstract getComponents(entityId: UUID$1, worldId?: UUID$1, sourceEntityId?: UUID$1): Promise<Component$1[]>;
    /**
     * Creates a new component in the database.
     * @param component The component object to create
     * @returns Promise resolving to true if creation was successful
     */
    abstract createComponent(component: Component$1): Promise<boolean>;
    /**
     * Updates an existing component in the database.
     * @param component The component object with updated properties
     * @returns Promise that resolves when the update is complete
     */
    abstract updateComponent(component: Component$1): Promise<void>;
    /**
     * Deletes a component from the database.
     * @param componentId The UUID of the component to delete
     * @returns Promise that resolves when the deletion is complete
     */
    abstract deleteComponent(componentId: UUID$1): Promise<void>;
    /**
     * Retrieves memories based on the specified parameters.
     * @param params An object containing parameters for the memory retrieval.
     * @returns A Promise that resolves to an array of Memory objects.
     */
    abstract getMemories(params: {
        entityId?: UUID$1;
        agentId?: UUID$1;
        roomId?: UUID$1;
        count?: number;
        unique?: boolean;
        tableName: string;
        start?: number;
        end?: number;
    }): Promise<Memory$1[]>;
    abstract getMemoriesByRoomIds(params: {
        roomIds: UUID$1[];
        tableName: string;
        limit?: number;
    }): Promise<Memory$1[]>;
    abstract getMemoryById(id: UUID$1): Promise<Memory$1 | null>;
    /**
     * Retrieves multiple memories by their IDs
     * @param memoryIds Array of UUIDs of the memories to retrieve
     * @param tableName Optional table name to filter memories by type
     * @returns Promise resolving to array of Memory objects
     */
    abstract getMemoriesByIds(memoryIds: UUID$1[], tableName?: string): Promise<Memory$1[]>;
    /**
     * Retrieves cached embeddings based on the specified query parameters.
     * @param params An object containing parameters for the embedding retrieval.
     * @returns A Promise that resolves to an array of objects containing embeddings and levenshtein scores.
     */
    abstract getCachedEmbeddings({ query_table_name, query_threshold, query_input, query_field_name, query_field_sub_name, query_match_count, }: {
        query_table_name: string;
        query_threshold: number;
        query_input: string;
        query_field_name: string;
        query_field_sub_name: string;
        query_match_count: number;
    }): Promise<{
        embedding: number[];
        levenshtein_score: number;
    }[]>;
    /**
     * Logs an event or action with the specified details.
     * @param params An object containing parameters for the log entry.
     * @returns A Promise that resolves when the log entry has been saved.
     */
    abstract log(params: {
        body: {
            [key: string]: unknown;
        };
        entityId: UUID$1;
        roomId: UUID$1;
        type: string;
    }): Promise<void>;
    /**
     * Retrieves logs based on the specified parameters.
     * @param params An object containing parameters for the log retrieval.
     * @returns A Promise that resolves to an array of Log objects.
     */
    abstract getLogs(params: {
        entityId: UUID$1;
        roomId?: UUID$1;
        type?: string;
        count?: number;
        offset?: number;
    }): Promise<Log$1[]>;
    /**
     * Deletes a log from the database.
     * @param logId The UUID of the log to delete.
     * @returns A Promise that resolves when the log has been deleted.
     */
    abstract deleteLog(logId: UUID$1): Promise<void>;
    /**
     * Searches for memories based on embeddings and other specified parameters.
     * @param params An object containing parameters for the memory search.
     * @returns A Promise that resolves to an array of Memory objects.
     */
    abstract searchMemories(params: {
        tableName: string;
        roomId: UUID$1;
        embedding: number[];
        match_threshold: number;
        count: number;
        unique: boolean;
    }): Promise<Memory$1[]>;
    /**
     * Creates a new memory in the database.
     * @param memory The memory object to create.
     * @param tableName The table where the memory should be stored.
     * @param unique Indicates if the memory should be unique.
     * @returns A Promise that resolves when the memory has been created.
     */
    abstract createMemory(memory: Memory$1, tableName: string, unique?: boolean): Promise<UUID$1>;
    /**
     * Updates an existing memory in the database.
     * @param memory The memory object with updated content and optional embedding
     * @returns Promise resolving to boolean indicating success
     */
    abstract updateMemory(memory: Partial<Memory$1> & {
        id: UUID$1;
        metadata?: MemoryMetadata$1;
    }): Promise<boolean>;
    /**
     * Removes a specific memory from the database.
     * @param memoryId The UUID of the memory to remove.
     * @returns A Promise that resolves when the memory has been removed.
     */
    abstract deleteMemory(memoryId: UUID$1): Promise<void>;
    /**
     * Removes multiple memories from the database in a single batch operation.
     * @param memoryIds An array of UUIDs of the memories to remove.
     * @returns A Promise that resolves when all memories have been removed.
     */
    abstract deleteManyMemories(memoryIds: UUID$1[]): Promise<void>;
    /**
     * Removes all memories associated with a specific room.
     * @param roomId The UUID of the room whose memories should be removed.
     * @param tableName The table from which the memories should be removed.
     * @returns A Promise that resolves when all memories have been removed.
     */
    abstract deleteAllMemories(roomId: UUID$1, tableName: string): Promise<void>;
    /**
     * Counts the number of memories in a specific room.
     * @param roomId The UUID of the room for which to count memories.
     * @param unique Specifies whether to count only unique memories.
     * @param tableName Optional table name to count memories from.
     * @returns A Promise that resolves to the number of memories.
     */
    abstract countMemories(roomId: UUID$1, unique?: boolean, tableName?: string): Promise<number>;
    /**
     * Retrieves a world by its ID.
     * @param id The UUID of the world to retrieve.
     * @returns A Promise that resolves to the World object or null if not found.
     */
    abstract getWorld(id: UUID$1): Promise<World$1 | null>;
    /**
     * Retrieves all worlds for an agent.
     * @returns A Promise that resolves to an array of World objects.
     */
    abstract getAllWorlds(): Promise<World$1[]>;
    /**
     * Creates a new world in the database.
     * @param world The world object to create.
     * @returns A Promise that resolves to the UUID of the created world.
     */
    abstract createWorld(world: World$1): Promise<UUID$1>;
    /**
     * Updates an existing world in the database.
     * @param world The world object with updated properties.
     * @returns A Promise that resolves when the world has been updated.
     */
    abstract updateWorld(world: World$1): Promise<void>;
    /**
     * Removes a specific world from the database.
     * @param id The UUID of the world to remove.
     * @returns A Promise that resolves when the world has been removed.
     */
    abstract removeWorld(id: UUID$1): Promise<void>;
    /**
     * Retrieves the room ID for a given room, if it exists.
     * @param roomId The UUID of the room to retrieve.
     * @returns A Promise that resolves to the room ID or null if not found.
     */
    abstract getRoomsByIds(roomIds: UUID$1[]): Promise<Room$1[] | null>;
    /**
     * Retrieves all rooms for a given world.
     * @param worldId The UUID of the world to retrieve rooms for.
     * @returns A Promise that resolves to an array of Room objects.
     */
    abstract getRoomsByWorld(worldId: UUID$1): Promise<Room$1[]>;
    /**
     * Creates a new rooms with an optional specified ID.
     * @param roomId Optional UUID to assign to the new room.
     * @returns A Promise that resolves to the UUID of the created rooms.
     */
    abstract createRooms(rooms: Room$1[]): Promise<UUID$1[]>;
    /**
     * Updates a specific room in the database.
     * @param room The room object with updated properties.
     * @returns A Promise that resolves when the room has been updated.
     */
    abstract updateRoom(room: Room$1): Promise<void>;
    /**
     * Removes a specific room from the database.
     * @param roomId The UUID of the room to remove.
     * @returns A Promise that resolves when the room has been removed.
     */
    abstract deleteRoom(roomId: UUID$1): Promise<void>;
    /**
     * Retrieves room IDs for which a specific user is a participant.
     * @param entityId The UUID of the user.
     * @returns A Promise that resolves to an array of room IDs.
     */
    abstract getRoomsForParticipant(entityId: UUID$1): Promise<UUID$1[]>;
    /**
     * Retrieves room IDs for which specific users are participants.
     * @param userIds An array of UUIDs of the users.
     * @returns A Promise that resolves to an array of room IDs.
     */
    abstract getRoomsForParticipants(userIds: UUID$1[]): Promise<UUID$1[]>;
    /**
     * Adds users as a participant to a specific room.
     * @param entityIds The UUIDs of the users to add as a participant.
     * @param roomId The UUID of the room to which the user will be added.
     * @returns A Promise that resolves to a boolean indicating success or failure.
     */
    abstract addParticipantsRoom(entityIds: UUID$1[], roomId: UUID$1): Promise<boolean>;
    /**
     * Removes a user as a participant from a specific room.
     * @param entityId The UUID of the user to remove as a participant.
     * @param roomId The UUID of the room from which the user will be removed.
     * @returns A Promise that resolves to a boolean indicating success or failure.
     */
    abstract removeParticipant(entityId: UUID$1, roomId: UUID$1): Promise<boolean>;
    /**
     * Retrieves participants associated with a specific account.
     * @param entityId The UUID of the account.
     * @returns A Promise that resolves to an array of Participant objects.
     */
    abstract getParticipantsForEntity(entityId: UUID$1): Promise<Participant$1[]>;
    /**
     * Retrieves participants for a specific room.
     * @param roomId The UUID of the room for which to retrieve participants.
     * @returns A Promise that resolves to an array of UUIDs representing the participants.
     */
    abstract getParticipantsForRoom(roomId: UUID$1): Promise<UUID$1[]>;
    abstract getParticipantUserState(roomId: UUID$1, entityId: UUID$1): Promise<'FOLLOWED' | 'MUTED' | null>;
    abstract setParticipantUserState(roomId: UUID$1, entityId: UUID$1, state: 'FOLLOWED' | 'MUTED' | null): Promise<void>;
    /**
     * Creates a new relationship between two users.
     * @param params Object containing the relationship details including entity IDs, agent ID, optional tags and metadata
     * @returns A Promise that resolves to a boolean indicating success or failure of the creation.
     */
    abstract createRelationship(params: {
        sourceEntityId: UUID$1;
        targetEntityId: UUID$1;
        tags?: string[];
        metadata?: Record<string, unknown>;
    }): Promise<boolean>;
    /**
     * Retrieves a relationship between two users if it exists.
     * @param params Object containing the entity IDs and agent ID
     * @returns A Promise that resolves to the Relationship object or null if not found.
     */
    abstract getRelationship(params: {
        sourceEntityId: UUID$1;
        targetEntityId: UUID$1;
    }): Promise<Relationship$1 | null>;
    /**
     * Retrieves all relationships for a specific user.
     * @param params Object containing the user ID, agent ID and optional tags to filter by
     * @returns A Promise that resolves to an array of Relationship objects.
     */
    abstract getRelationships(params: {
        entityId: UUID$1;
        tags?: string[];
    }): Promise<Relationship$1[]>;
    /**
     * Updates an existing relationship between two users.
     * @param params Object containing the relationship details to update including entity IDs, agent ID, optional tags and metadata
     * @returns A Promise that resolves to a boolean indicating success or failure of the update.
     */
    abstract updateRelationship(params: {
        sourceEntityId: UUID$1;
        targetEntityId: UUID$1;
        tags?: string[];
        metadata?: Record<string, unknown>;
    }): Promise<void>;
    /**
     * Retrieves an agent by its ID.
     * @param agentId The UUID of the agent to retrieve.
     * @returns A Promise that resolves to the Agent object or null if not found.
     */
    abstract getAgent(agentId: UUID$1): Promise<Agent$1 | null>;
    /**
     * Retrieves all agents from the database.
     * @returns A Promise that resolves to an array of Agent objects.
     */
    abstract getAgents(): Promise<Agent$1[]>;
    /**
     * Creates a new agent in the database.
     * @param agent The agent object to create.
     * @returns A Promise that resolves to a boolean indicating success or failure of the creation.
     */
    abstract createAgent(agent: Partial<Agent$1>): Promise<boolean>;
    /**
     * Updates an existing agent in the database.
     * @param agentId The UUID of the agent to update.
     * @param agent The agent object with updated properties.
     * @returns A Promise that resolves to a boolean indicating success or failure of the update.
     */
    abstract updateAgent(agentId: UUID$1, agent: Partial<Agent$1>): Promise<boolean>;
    /**
     * Deletes an agent from the database.
     * @param agentId The UUID of the agent to delete.
     * @returns A Promise that resolves to a boolean indicating success or failure of the deletion.
     */
    abstract deleteAgent(agentId: UUID$1): Promise<boolean>;
    /**
     * Ensures an embedding dimension exists in the database.
     * @param dimension The dimension to ensure exists.
     * @returns A Promise that resolves when the embedding dimension has been ensured to exist.
     */
    abstract ensureEmbeddingDimension(dimension: number): Promise<void>;
    /**
     * Retrieves a cached value by key from the database.
     * @param key The key to look up in the cache
     * @returns Promise resolving to the cached string value
     */
    abstract getCache<T>(key: string): Promise<T | undefined>;
    /**
     * Sets a value in the cache with the given key.
     * @param params Object containing the cache key and value
     * @param key The key to store the value under
     * @param value The string value to cache
     * @returns Promise resolving to true if the cache was set successfully
     */
    abstract setCache<T>(key: string, value: T): Promise<boolean>;
    /**
     * Deletes a value from the cache by key.
     * @param key The key to delete from the cache
     * @returns Promise resolving to true if the value was successfully deleted
     */
    abstract deleteCache(key: string): Promise<boolean>;
    /**
     * Creates a new task instance in the database.
     * @param task The task object to create
     * @returns Promise resolving to the UUID of the created task
     */
    abstract createTask(task: Task$1): Promise<UUID$1>;
    /**
     * Retrieves tasks based on specified parameters.
     * @param params Object containing optional roomId and tags to filter tasks
     * @returns Promise resolving to an array of Task objects
     */
    abstract getTasks(params: {
        roomId?: UUID$1;
        tags?: string[];
    }): Promise<Task$1[]>;
    /**
     * Retrieves a specific task by its ID.
     * @param id The UUID of the task to retrieve
     * @returns Promise resolving to the Task object if found, null otherwise
     */
    abstract getTask(id: UUID$1): Promise<Task$1 | null>;
    /**
     * Retrieves a specific task by its name.
     * @param name The name of the task to retrieve
     * @returns Promise resolving to the Task object if found, null otherwise
     */
    abstract getTasksByName(name: string): Promise<Task$1[]>;
    /**
     * Updates an existing task in the database.
     * @param id The UUID of the task to update
     * @param task Partial Task object containing the fields to update
     * @returns Promise resolving when the update is complete
     */
    abstract updateTask(id: UUID$1, task: Partial<Task$1>): Promise<void>;
    /**
     * Deletes a task from the database.
     * @param id The UUID of the task to delete
     * @returns Promise resolving when the deletion is complete
     */
    abstract deleteTask(id: UUID$1): Promise<void>;
    abstract getMemoriesByWorldId(params: {
        worldId: UUID$1;
        count?: number;
        tableName?: string;
    }): Promise<Memory$1[]>;
    abstract deleteRoomsByWorldId(worldId: UUID$1): Promise<void>;
}

/**
 * Finds an entity by name in the given runtime environment.
 *
 * @param {IAgentRuntime} runtime - The agent runtime environment.
 * @param {Memory} message - The memory message containing relevant information.
 * @param {State} state - The current state of the system.
 * @returns {Promise<Entity | null>} A promise that resolves to the found entity or null if not found.
 */
declare function findEntityByName(runtime: IAgentRuntime$1, message: Memory$1, state: State): Promise<Entity$1 | null>;
/**
 * Function to create a unique UUID based on the runtime and base user ID.
 *
 * @param {RuntimeContext} runtime - The runtime context object.
 * @param {UUID|string} baseUserId - The base user ID to use in generating the UUID.
 * @returns {UUID} - The unique UUID generated based on the runtime and base user ID.
 */
declare const createUniqueUuid: (runtime: IAgentRuntime$1, baseUserId: UUID | string) => UUID;
/**
 * Retrieves entity details for a specific room from the database.
 *
 * @param {Object} params - The input parameters
 * @param {IAgentRuntime} params.runtime - The Agent Runtime instance
 * @param {UUID} params.roomId - The ID of the room to retrieve entity details for
 * @returns {Promise<Array>} - A promise that resolves to an array of unique entity details
 */
declare function getEntityDetails({ runtime, roomId, }: {
    runtime: IAgentRuntime$1;
    roomId: UUID;
}): Promise<any[]>;
/**
 * Format the given entities into a string representation.
 *
 * @param {Object} options - The options object.
 * @param {Entity[]} options.entities - The list of entities to format.
 * @returns {string} A formatted string representing the entities.
 */
declare function formatEntities({ entities }: {
    entities: Entity$1[];
}): string;

/**
 * Type definition for logger methods
 */
type LogMethod = (...args: any[]) => void;
declare const logger: Record<'trace' | 'debug' | 'success' | 'progress' | 'log' | 'info' | 'warn' | 'error' | 'fatal' | 'clear', LogMethod>;
declare const elizaLogger: Record<"debug" | "fatal" | "error" | "warn" | "info" | "log" | "progress" | "success" | "trace" | "clear", LogMethod>;

declare const shouldRespondTemplate: string;
declare const messageHandlerTemplate: string;
declare const postCreationTemplate: string;
declare const booleanFooter: string;
declare const imageDescriptionTemplate: string;

/**
 * Interface representing the ownership state of servers.
 * @property {Object.<string, World>} servers - The servers and their corresponding worlds, where the key is the server ID and the value is the World object.
 */
interface ServerOwnershipState {
    servers: {
        [serverId: string]: World$1;
    };
}
/**
 * Retrieve the server role of a specified user entity within a given server.
 *
 * @param {IAgentRuntime} runtime - The runtime object containing necessary configurations and services.
 * @param {string} entityId - The unique identifier of the user entity.
 * @param {string} serverId - The unique identifier of the server.
 * @returns {Promise<Role>} The role of the user entity within the server, resolved as a Promise.
 */
declare function getUserServerRole(runtime: IAgentRuntime$1, entityId: string, serverId: string): Promise<Role$1>;
/**
 * Finds a server where the given user is the owner
 */
declare function findWorldsForOwner(runtime: IAgentRuntime$1, entityId: string): Promise<World$1[] | null>;

declare class Semaphore {
    private _semphonre;
    constructor(count: number);
    acquire(): Promise<void>;
    release(): void;
}
/**
 * Represents the runtime environment for an agent.
 * @class
 * @implements { IAgentRuntime }
 * @property { number } #conversationLength - The maximum length of a conversation.
 * @property { UUID } agentId - The unique identifier for the agent.
 * @property { Character } character - The character associated with the agent.
 * @property { IDatabaseAdapter } adapter - The adapter for interacting with the database.
 * @property {Action[]} actions - The list of actions available to the agent.
 * @property {Evaluator[]} evaluators - The list of evaluators for decision making.
 * @property {Provider[]} providers - The list of providers for external services.
 * @property {Plugin[]} plugins - The list of plugins to extend functionality.
 */
declare class AgentRuntime implements IAgentRuntime$1 {
    private _runtime;
    get services(): Map<ServiceTypeName$1, Service$1>;
    get events(): Map<string, ((params: any) => Promise<void>)[]>;
    get routes(): Route$1[];
    get agentId(): UUID$1;
    get character(): Character$1;
    get providers(): Provider$1[];
    get actions(): Action$1[];
    get evaluators(): Evaluator$1[];
    get plugins(): Plugin$1[];
    get adapter(): IDatabaseAdapter$1;
    constructor(opts: {
        conversationLength?: number;
        agentId?: UUID$1;
        character?: Character$1;
        plugins?: Plugin$1[];
        fetch?: typeof fetch;
        adapter?: IDatabaseAdapter$1;
        settings?: RuntimeSettings$1;
        events?: {
            [key: string]: ((params: any) => void)[];
        };
    });
    /**
     * Registers a plugin with the runtime and initializes its components
     * @param plugin The plugin to register
     */
    registerPlugin(plugin: Plugin$1): Promise<void>;
    getAllServices(): Map<ServiceTypeName$1, Service$1>;
    stop(): Promise<any>;
    initialize(): Promise<any>;
    getConnection(): Promise<any>;
    setSetting(key: string, value: string | boolean | null | any, secret?: boolean): any;
    getSetting(key: string): string | boolean | null | any;
    /**
     * Get the number of messages that are kept in the conversation buffer.
     * @returns The number of recent messages to be kept in memory.
     */
    getConversationLength(): any;
    registerDatabaseAdapter(adapter: IDatabaseAdapter$1): any;
    /**
     * Register a provider for the agent to use.
     * @param provider The provider to register.
     */
    registerProvider(provider: Provider$1): any;
    /**
     * Register an action for the agent to perform.
     * @param action The action to register.
     */
    registerAction(action: Action$1): any;
    /**
     * Register an evaluator to assess and guide the agent's responses.
     * @param evaluator The evaluator to register.
     */
    registerEvaluator(evaluator: Evaluator$1): any;
    /**
     * Process the actions of a message.
     * @param message The message to process.
     * @param responses The array of response memories to process actions from.
     * @param state Optional state object for the action processing.
     * @param callback Optional callback handler for action results.
     */
    processActions(message: Memory$1, responses: Memory$1[], state?: State$1, callback?: HandlerCallback$1): Promise<void>;
    /**
     * Evaluate the message and state using the registered evaluators.
     * @param message The message to evaluate.
     * @param state The state of the agent.
     * @param didRespond Whether the agent responded to the message.~
     * @param callback The handler callback
     * @returns The results of the evaluation.
     */
    evaluate(message: Memory$1, state: State$1, didRespond?: boolean, callback?: HandlerCallback$1, responses?: Memory$1[]): Promise<any>;
    ensureConnection({ entityId, roomId, userName, name, source, type, channelId, serverId, worldId, userId, }: {
        entityId: UUID$1;
        roomId: UUID$1;
        userName?: string;
        name?: string;
        source?: string;
        type?: ChannelType;
        channelId?: string;
        serverId?: string;
        worldId?: UUID$1;
        userId?: UUID$1;
    }): Promise<any>;
    /**
     * Ensures a participant is added to a room, checking that the entity exists first
     */
    ensureParticipantInRoom(entityId: UUID$1, roomId: UUID$1): Promise<any>;
    removeParticipant(entityId: UUID$1, roomId: UUID$1): Promise<boolean>;
    getParticipantsForEntity(entityId: UUID$1): Promise<Participant$1[]>;
    getParticipantsForRoom(roomId: UUID$1): Promise<UUID$1[]>;
    addParticipant(entityId: UUID$1, roomId: UUID$1): Promise<boolean>;
    addParticipantsRoom(entityIds: UUID$1[], roomId: UUID$1): Promise<boolean>;
    /**
     * Ensure the existence of a world.
     */
    ensureWorldExists({ id, name, serverId, metadata, agentId }: World$1): Promise<any>;
    /**
     * Ensure the existence of a room between the agent and a user. If no room exists, a new room is created and the user
     * and agent are added as participants. The room ID is returned.
     * @param entityId - The user ID to create a room with.
     * @returns The room ID of the room between the agent and the user.
     * @throws An error if the room cannot be created.
     */
    ensureRoomExists({ id, name, source, type, channelId, serverId, worldId, metadata }: Room$1): Promise<any>;
    /**
     * Composes the agent's state by gathering data from enabled providers.
     * @param message - The message to use as context for state composition
     * @param includeList - Optional list of provider names to include, filtering out all others
     * @param onlyInclude - Whether to only include the specified providers
     * @param skipCache - Whether to skip the cache
     * @returns A State object containing provider data, values, and text
     */
    composeState(message: Memory$1, includeList?: string[] | null, onlyInclude?: boolean, skipCache?: boolean): Promise<State$1>;
    getService<T extends Service$1>(service: ServiceTypeName$1): T | null;
    registerService(service: typeof Service$1): Promise<void>;
    registerModel(modelType: ModelTypeName$1, handler: (runtime: IAgentRuntime$1, params: any) => Promise<any>, provider?: string): any;
    getModel(modelType: ModelTypeName$1): ((runtime: IAgentRuntime$1, params: any) => Promise<any>) | undefined;
    /**
     * Use a model with strongly typed parameters and return values based on model type
     * @template T - The model type to use
     * @template R - The expected return type, defaults to the type defined in ModelResultMap[T]
     * @param {T} modelType - The type of model to use
     * @param {ModelParamsMap[T] | any} params - The parameters for the model, typed based on model type
     * @returns {Promise<R>} - The model result, typed based on the provided generic type parameter
     */
    useModel<T extends ModelTypeName$1, R = ModelResultMap$1[T]>(modelType: T, params: Omit<ModelParamsMap$1[T], 'runtime'> | any): Promise<R>;
    registerEvent(event: string, handler: (params: any) => Promise<void>): any;
    getEvent(event: string): ((params: any) => Promise<void>)[] | undefined;
    emitEvent(event: string | string[], params: any): Promise<any>;
    ensureEmbeddingDimension(): Promise<any>;
    registerTaskWorker(taskHandler: TaskWorker$1): void;
    /**
     * Get a task worker by name
     */
    getTaskWorker(name: string): TaskWorker$1 | undefined;
    get db(): any;
    init(): Promise<void>;
    close(): Promise<void>;
    getAgent(agentId: UUID$1): Promise<Agent$1 | null>;
    getAgents(): Promise<Agent$1[]>;
    createAgent(agent: Partial<Agent$1>): Promise<boolean>;
    updateAgent(agentId: UUID$1, agent: Partial<Agent$1>): Promise<boolean>;
    deleteAgent(agentId: UUID$1): Promise<boolean>;
    ensureAgentExists(agent: Partial<Agent$1>): Promise<Agent$1>;
    getEntityById(entityId: UUID$1): Promise<Entity$1 | null>;
    getEntityByIds(entityIds: UUID$1[]): Promise<Entity$1[] | null>;
    getEntitiesForRoom(roomId: UUID$1, includeComponents?: boolean): Promise<Entity$1[]>;
    createEntity(entity: Entity$1): Promise<boolean>;
    createEntities(entities: Entity$1[]): Promise<boolean>;
    updateEntity(entity: Entity$1): Promise<void>;
    getComponent(entityId: UUID$1, type: string, worldId?: UUID$1, sourceEntityId?: UUID$1): Promise<Component$1 | null>;
    getComponents(entityId: UUID$1, worldId?: UUID$1, sourceEntityId?: UUID$1): Promise<Component$1[]>;
    createComponent(component: Component$1): Promise<boolean>;
    updateComponent(component: Component$1): Promise<void>;
    deleteComponent(componentId: UUID$1): Promise<void>;
    addEmbeddingToMemory(memory: Memory$1): Promise<Memory$1>;
    getAllMemories(): Promise<Memory$1[]>;
    clearAllAgentMemories(): Promise<void>;
    getMemories(params: {
        entityId?: UUID$1;
        agentId?: UUID$1;
        roomId?: UUID$1;
        count?: number;
        unique?: boolean;
        tableName: string;
        start?: number;
        end?: number;
    }): Promise<Memory$1[]>;
    getMemoryById(id: UUID$1): Promise<Memory$1 | null>;
    getMemoriesByIds(ids: UUID$1[], tableName?: string): Promise<Memory$1[]>;
    getMemoriesByRoomIds(params: {
        tableName: string;
        roomIds: UUID$1[];
        limit?: number;
    }): Promise<Memory$1[]>;
    getCachedEmbeddings(params: {
        query_table_name: string;
        query_threshold: number;
        query_input: string;
        query_field_name: string;
        query_field_sub_name: string;
        query_match_count: number;
    }): Promise<{
        embedding: number[];
        levenshtein_score: number;
    }[]>;
    log(params: {
        body: {
            [key: string]: unknown;
        };
        entityId: UUID$1;
        roomId: UUID$1;
        type: string;
    }): Promise<void>;
    searchMemories(params: {
        embedding: number[];
        match_threshold?: number;
        count?: number;
        roomId?: UUID$1;
        unique?: boolean;
        tableName: string;
    }): Promise<Memory$1[]>;
    createMemory(memory: Memory$1, tableName: string, unique?: boolean): Promise<UUID$1>;
    updateMemory(memory: Partial<Memory$1> & {
        id: UUID$1;
        metadata?: MemoryMetadata$1;
    }): Promise<boolean>;
    deleteMemory(memoryId: UUID$1): Promise<void>;
    deleteManyMemories(memoryIds: UUID$1[]): Promise<void>;
    deleteAllMemories(roomId: UUID$1, tableName: string): Promise<void>;
    countMemories(roomId: UUID$1, unique?: boolean, tableName?: string): Promise<number>;
    getLogs(params: {
        entityId: UUID$1;
        roomId?: UUID$1;
        type?: string;
        count?: number;
        offset?: number;
    }): Promise<Log$1[]>;
    deleteLog(logId: UUID$1): Promise<void>;
    createWorld(world: World$1): Promise<UUID$1>;
    getWorld(id: UUID$1): Promise<World$1 | null>;
    removeWorld(worldId: UUID$1): Promise<void>;
    getAllWorlds(): Promise<World$1[]>;
    updateWorld(world: World$1): Promise<void>;
    getRoom(roomId: UUID$1): Promise<Room$1 | null>;
    getRoomsByIds(roomIds: UUID$1[]): Promise<Room$1[] | null>;
    createRoom({ id, name, source, type, channelId, serverId, worldId }: Room$1): Promise<UUID$1>;
    createRooms(rooms: Room$1[]): Promise<UUID$1[]>;
    deleteRoom(roomId: UUID$1): Promise<void>;
    deleteRoomsByWorldId(worldId: UUID$1): Promise<void>;
    updateRoom(room: Room$1): Promise<void>;
    getRoomsForParticipant(entityId: UUID$1): Promise<UUID$1[]>;
    getRoomsForParticipants(userIds: UUID$1[]): Promise<UUID$1[]>;
    getRooms(worldId: UUID$1): Promise<Room$1[]>;
    getRoomsByWorld(worldId: UUID$1): Promise<Room$1[]>;
    getParticipantUserState(roomId: UUID$1, entityId: UUID$1): Promise<'FOLLOWED' | 'MUTED' | null>;
    setParticipantUserState(roomId: UUID$1, entityId: UUID$1, state: 'FOLLOWED' | 'MUTED' | null): Promise<void>;
    createRelationship(params: {
        sourceEntityId: UUID$1;
        targetEntityId: UUID$1;
        tags?: string[];
        metadata?: {
            [key: string]: any;
        };
    }): Promise<boolean>;
    updateRelationship(relationship: Relationship$1): Promise<void>;
    getRelationship(params: {
        sourceEntityId: UUID$1;
        targetEntityId: UUID$1;
    }): Promise<Relationship$1 | null>;
    getRelationships(params: {
        entityId: UUID$1;
        tags?: string[];
    }): Promise<Relationship$1[]>;
    getCache<T>(key: string): Promise<T | undefined>;
    setCache<T>(key: string, value: T): Promise<boolean>;
    deleteCache(key: string): Promise<boolean>;
    createTask(task: Task$1): Promise<UUID$1>;
    getTasks(params: {
        roomId?: UUID$1;
        tags?: string[];
    }): Promise<Task$1[]>;
    getTask(id: UUID$1): Promise<Task$1 | null>;
    getTasksByName(name: string): Promise<Task$1[]>;
    updateTask(id: UUID$1, task: Partial<Task$1>): Promise<void>;
    deleteTask(id: UUID$1): Promise<void>;
    on(event: string, callback: (data: any) => void): void;
    off(event: string, callback: (data: any) => void): void;
    emit(event: string, data: any): void;
    sendControlMessage(params: {
        roomId: UUID$1;
        action: 'enable_input' | 'disable_input';
        target?: string;
    }): Promise<void>;
    /**
     * Register a message send handler for a specific source
     * @param source - The source identifier (e.g., 'discord', 'telegram')
     * @param handler - The handler function to send messages
     */
    registerSendHandler(source: string, handler: SendHandlerFunction$1): void;
    /**
     * Send a message to a specific target
     * @param target - The target information including source and channel/user ID
     * @param content - The message content to send
     */
    sendMessageToTarget(target: TargetInfo$1, content: Content$1): Promise<void>;
    getMemoriesByWorldId(params: {
        worldId: UUID$1;
        count?: number;
        tableName?: string;
    }): Promise<Memory$1[]>;
    createRunId(): UUID$1;
    startRun(): UUID$1;
    endRun(): void;
    getCurrentRunId(): UUID$1;
}

/**
 * Creates a Setting object from a configSetting object by omitting the 'value' property.
 *
 * @param {Omit<Setting, 'value'>} configSetting - The configSetting object to create the Setting from.
 * @returns {Setting} A new Setting object created from the provided configSetting object.
 */
declare function createSettingFromConfig(configSetting: Omit<Setting, 'value'>): Setting;
/**
 * Retrieves the salt based on env variable SECRET_SALT
 *
 * @returns {string} The salt for the agent.
 */
declare function getSalt(): string;
/**
 * Common encryption function for string values
 * @param {string} value - The string value to encrypt
 * @param {string} salt - The salt to use for encryption
 * @returns {string} - The encrypted value in 'iv:encrypted' format
 */
declare function encryptStringValue(value: string, salt: string): string;
/**
 * Common decryption function for string values
 * @param {string} value - The encrypted value in 'iv:encrypted' format
 * @param {string} salt - The salt to use for decryption
 * @returns {string} - The decrypted string value
 */
declare function decryptStringValue(value: string, salt: string): string;
/**
 * Applies salt to the value of a setting
 * Only applies to secret settings with string values
 */
declare function saltSettingValue(setting: Setting, salt: string): Setting;
/**
 * Removes salt from the value of a setting
 * Only applies to secret settings with string values
 */
declare function unsaltSettingValue(setting: Setting, salt: string): Setting;
/**
 * Applies salt to all settings in a WorldSettings object
 */
declare function saltWorldSettings(worldSettings: WorldSettings, salt: string): WorldSettings;
/**
 * Removes salt from all settings in a WorldSettings object
 */
declare function unsaltWorldSettings(worldSettings: WorldSettings, salt: string): WorldSettings;
/**
 * Updates settings state in world metadata
 */
declare function updateWorldSettings(runtime: IAgentRuntime, serverId: string, worldSettings: WorldSettings): Promise<boolean>;
/**
 * Gets settings state from world metadata
 */
declare function getWorldSettings(runtime: IAgentRuntime, serverId: string): Promise<WorldSettings | null>;
/**
 * Initializes settings configuration for a server
 */
declare function initializeOnboarding(runtime: IAgentRuntime, world: World, config: OnboardingConfig): Promise<WorldSettings | null>;
/**
 * Encrypts sensitive data in a Character object
 * @param {Character} character - The character object to encrypt secrets for
 * @param {IAgentRuntime} runtime - The runtime information needed for salt generation
 * @returns {Character} - A copy of the character with encrypted secrets
 */
declare function encryptedCharacter(character: Character): Character;
/**
 * Decrypts sensitive data in a Character object
 * @param {Character} character - The character object with encrypted secrets
 * @param {IAgentRuntime} runtime - The runtime information needed for salt generation
 * @returns {Character} - A copy of the character with decrypted secrets
 */
declare function decryptedCharacter(character: Character, runtime: IAgentRuntime): Character;
/**
 * Helper function to encrypt all string values in an object
 * @param {Record<string, any>} obj - Object with values to encrypt
 * @param {string} salt - The salt to use for encryption
 * @returns {Record<string, any>} - Object with encrypted values
 */
declare function encryptObjectValues(obj: Record<string, any>, salt: string): Record<string, any>;
/**
 * Helper function to decrypt all string values in an object
 * @param {Record<string, any>} obj - Object with encrypted values
 * @param {string} salt - The salt to use for decryption
 * @returns {Record<string, any>} - Object with decrypted values
 */
declare function decryptObjectValues(obj: Record<string, any>, salt: string): Record<string, any>;

/**
 * Convert all double-brace bindings in a Handlebars template
 * to triple-brace bindings, so the output is NOT HTML-escaped.
 *
 * - Ignores block/partial/comment tags that start with # / ! >.
 * - Ignores the else keyword.
 * - Ignores bindings that are already triple-braced.
 *
 * @param  tpl  Handlebars template source
 * @return      Transformed template
 */
/**
 * Function to compose a prompt using a provided template and state.
 * It compiles the template (upgrading double braces to triple braces for non-HTML escaping)
 * and then populates it with values from the state. Additionally, it processes the
 * resulting string with `composeRandomUser` to replace placeholders like `{{nameX}}`.
 *
 * @param {Object} options - Object containing state and template information.
 * @param {State} options.state - The state object containing values to fill the template.
 * @param {TemplateType} options.template - The template string or function to be used for composing the prompt.
 * @returns {string} The composed prompt output, with state values and random user names populated.
 */
declare const composePrompt: ({ state, template, }: {
    state: {
        [key: string]: string;
    };
    template: TemplateType$1;
}) => string;
/**
 * Function to compose a prompt using a provided template and state.
 *
 * @param {Object} options - Object containing state and template information.
 * @param {State} options.state - The state object containing values to fill the template.
 * @param {TemplateType} options.template - The template to be used for composing the prompt.
 * @returns {string} The composed prompt output.
 */
declare const composePromptFromState: ({ state, template, }: {
    state: State$1;
    template: TemplateType$1;
}) => string;
/**
 * Adds a header to a body of text.
 *
 * This function takes a header string and a body string and returns a new string with the header prepended to the body.
 * If the body string is empty, the header is returned as is.
 *
 * @param {string} header - The header to add to the body.
 * @param {string} body - The body to which to add the header.
 * @returns {string} The body with the header prepended.
 *
 * @example
 * // Given a header and a body
 * const header = "Header";
 * const body = "Body";
 *
 * // Adding the header to the body will result in:
 * // "Header\nBody"
 * const text = addHeader(header, body);
 */
declare const addHeader: (header: string, body: string) => string;
declare const formatPosts: ({ messages, entities, conversationHeader, }: {
    messages: Memory$1[];
    entities: Entity$1[];
    conversationHeader?: boolean;
}) => string;
/**
 * Format messages into a string
 * @param {Object} params - The formatting parameters
 * @param {Memory[]} params.messages - List of messages to format
 * @param {Entity[]} params.entities - List of entities for name resolution
 * @returns {string} Formatted message string with timestamps and user information
 */
declare const formatMessages: ({ messages, entities, }: {
    messages: Memory$1[];
    entities: Entity$1[];
}) => string;
declare const formatTimestamp: (messageDate: number) => string;
/**
 * Validates a UUID value.
 *
 * @param {unknown} value - The value to validate.
 * @returns {UUID | null} Returns the validated UUID value or null if validation fails.
 */
declare function validateUuid(value: unknown): UUID$1 | null;
/**
 * Converts a string or number to a UUID.
 *
 * @param {string | number} target - The string or number to convert to a UUID.
 * @returns {UUID} The UUID generated from the input target.
 * @throws {TypeError} Throws an error if the input target is not a string.
 */
declare function stringToUuid(target: string | number): UUID$1;
declare function truncateToCompleteSentence(text: string, maxLength: number): string;
declare function parseKeyValueXml(text: string): Record<string, any> | null;
declare function parseJSONObjectFromText(text: string): Record<string, any> | null;
declare function parseBooleanFromText(text: string): boolean | null;
declare function safeReplacer(): (key: string, value: any) => any;
declare function trimTokens(text: string, maxTokens: number, runtime: IAgentRuntime): Promise<string>;

/**
 * Service builder class that provides type-safe service creation
 * with automatic type inference
 */
declare class ServiceBuilder<TService extends Service$1 = Service$1> extends ServiceBuilder$1 {
    constructor(serviceType: ServiceTypeName$1 | string);
}
/**
 * Create a type-safe service builder
 * @param serviceType - The service type name
 * @returns A new ServiceBuilder instance
 */
declare function createService<TService extends Service = Service>(serviceType: ServiceTypeName$1 | string): ServiceBuilder$1<TService>;
/**
 * Type-safe service definition helper
 */
interface ServiceDefinition<T extends Service$1 = Service$1> {
    serviceType: ServiceTypeName$1;
    description: string;
    start: (runtime: IAgentRuntime$1) => Promise<T>;
    stop?: () => Promise<void>;
}
/**
 * Define a service with type safety
 */
declare function defineService<T extends Service = Service>(definition: ServiceDefinition$1<T>): new (runtime?: IAgentRuntime) => T;

type v2_AgentRuntime = AgentRuntime;
declare const v2_AgentRuntime: typeof AgentRuntime;
declare const v2_ComponentData: typeof ComponentData;
type v2_DatabaseAdapter<DB = unknown> = DatabaseAdapter<DB>;
declare const v2_DatabaseAdapter: typeof DatabaseAdapter;
declare const v2_DeriveKeyAttestationData: typeof DeriveKeyAttestationData;
declare const v2_EventDataObject: typeof EventDataObject;
declare const v2_MetadataObject: typeof MetadataObject;
declare const v2_RemoteAttestationMessage: typeof RemoteAttestationMessage;
declare const v2_RemoteAttestationQuote: typeof RemoteAttestationQuote;
type v2_Semaphore = Semaphore;
declare const v2_Semaphore: typeof Semaphore;
type v2_ServerOwnershipState = ServerOwnershipState;
type v2_ServiceBuilder<TService extends Service$1 = Service$1> = ServiceBuilder<TService>;
declare const v2_ServiceBuilder: typeof ServiceBuilder;
declare const v2_ServiceConfig: typeof ServiceConfig;
type v2_ServiceDefinition<T extends Service$1 = Service$1> = ServiceDefinition<T>;
declare const v2_TEEMode: typeof TEEMode;
declare const v2_TeeAgent: typeof TeeAgent;
declare const v2_TeePluginConfig: typeof TeePluginConfig;
declare const v2_TeeType: typeof TeeType;
declare const v2_TeeVendorConfig: typeof TeeVendorConfig;
declare const v2_addHeader: typeof addHeader;
declare const v2_booleanFooter: typeof booleanFooter;
declare const v2_composeActionExamples: typeof composeActionExamples;
declare const v2_composePrompt: typeof composePrompt;
declare const v2_composePromptFromState: typeof composePromptFromState;
declare const v2_createService: typeof createService;
declare const v2_createSettingFromConfig: typeof createSettingFromConfig;
declare const v2_createUniqueUuid: typeof createUniqueUuid;
declare const v2_decryptObjectValues: typeof decryptObjectValues;
declare const v2_decryptStringValue: typeof decryptStringValue;
declare const v2_decryptedCharacter: typeof decryptedCharacter;
declare const v2_defineService: typeof defineService;
declare const v2_elizaLogger: typeof elizaLogger;
declare const v2_encryptObjectValues: typeof encryptObjectValues;
declare const v2_encryptStringValue: typeof encryptStringValue;
declare const v2_encryptedCharacter: typeof encryptedCharacter;
declare const v2_findEntityByName: typeof findEntityByName;
declare const v2_findWorldsForOwner: typeof findWorldsForOwner;
declare const v2_formatActionNames: typeof formatActionNames;
declare const v2_formatActions: typeof formatActions;
declare const v2_formatEntities: typeof formatEntities;
declare const v2_formatMessages: typeof formatMessages;
declare const v2_formatPosts: typeof formatPosts;
declare const v2_formatTimestamp: typeof formatTimestamp;
declare const v2_getEntityDetails: typeof getEntityDetails;
declare const v2_getSalt: typeof getSalt;
declare const v2_getUserServerRole: typeof getUserServerRole;
declare const v2_getWorldSettings: typeof getWorldSettings;
declare const v2_imageDescriptionTemplate: typeof imageDescriptionTemplate;
declare const v2_initializeOnboarding: typeof initializeOnboarding;
declare const v2_logger: typeof logger;
declare const v2_messageHandlerTemplate: typeof messageHandlerTemplate;
declare const v2_parseBooleanFromText: typeof parseBooleanFromText;
declare const v2_parseJSONObjectFromText: typeof parseJSONObjectFromText;
declare const v2_parseKeyValueXml: typeof parseKeyValueXml;
declare const v2_postCreationTemplate: typeof postCreationTemplate;
declare const v2_safeReplacer: typeof safeReplacer;
declare const v2_saltSettingValue: typeof saltSettingValue;
declare const v2_saltWorldSettings: typeof saltWorldSettings;
declare const v2_shouldRespondTemplate: typeof shouldRespondTemplate;
declare const v2_stringToUuid: typeof stringToUuid;
declare const v2_trimTokens: typeof trimTokens;
declare const v2_truncateToCompleteSentence: typeof truncateToCompleteSentence;
declare const v2_unsaltSettingValue: typeof unsaltSettingValue;
declare const v2_unsaltWorldSettings: typeof unsaltWorldSettings;
declare const v2_updateWorldSettings: typeof updateWorldSettings;
declare const v2_validateUuid: typeof validateUuid;
declare namespace v2 {
  export { Action$1 as Action, ActionEventPayload$1 as ActionEventPayload, ActionExample$1 as ActionExample, Agent$1 as Agent, v2_AgentRuntime as AgentRuntime, AgentStatus$1 as AgentStatus, AudioProcessingParams$1 as AudioProcessingParams, BaseMetadata$1 as BaseMetadata, BaseModelParams$1 as BaseModelParams, CacheKeyPrefix$1 as CacheKeyPrefix, ChannelClearedPayload$1 as ChannelClearedPayload, ChannelType$1 as ChannelType, Character$1 as Character, ChunkRow$1 as ChunkRow, Component$1 as Component, v2_ComponentData as ComponentData, Content$1 as Content, ContentType$1 as ContentType, ControlMessage$1 as ControlMessage, CustomMetadata$1 as CustomMetadata, v2_DatabaseAdapter as DatabaseAdapter, DbConnection$1 as DbConnection, v2_DeriveKeyAttestationData as DeriveKeyAttestationData, DescriptionMetadata$1 as DescriptionMetadata, DetokenizeTextParams$1 as DetokenizeTextParams, DirectoryItem$1 as DirectoryItem, DocumentMetadata$1 as DocumentMetadata, EmbeddingSearchResult$1 as EmbeddingSearchResult, EnhancedState$1 as EnhancedState, Entity$1 as Entity, EntityPayload$1 as EntityPayload, EvaluationExample$1 as EvaluationExample, Evaluator$1 as Evaluator, EvaluatorEventPayload$1 as EvaluatorEventPayload, v2_EventDataObject as EventDataObject, EventHandler$1 as EventHandler, EventPayload$1 as EventPayload, EventPayloadMap$1 as EventPayloadMap, EventType$1 as EventType, FragmentMetadata$1 as FragmentMetadata, GenerateTextParams$1 as GenerateTextParams, Handler$1 as Handler, HandlerCallback$1 as HandlerCallback, IAgentRuntime$1 as IAgentRuntime, IDatabaseAdapter$1 as IDatabaseAdapter, ImageDescriptionParams$1 as ImageDescriptionParams, ImageGenerationParams$1 as ImageGenerationParams, InvokePayload$1 as InvokePayload, IsValidServiceType$1 as IsValidServiceType, JSONSchema$1 as JSONSchema, KnowledgeItem$1 as KnowledgeItem, KnowledgeScope$1 as KnowledgeScope, Log$1 as Log, Media$1 as Media, Memory$1 as Memory, MemoryMetadata$1 as MemoryMetadata, MemoryRetrievalOptions$1 as MemoryRetrievalOptions, MemoryScope$1 as MemoryScope, MemorySearchOptions$1 as MemorySearchOptions, MemoryType$1 as MemoryType, MemoryTypeAlias$1 as MemoryTypeAlias, MessageExample$1 as MessageExample, MessageMemory$1 as MessageMemory, MessageMetadata$1 as MessageMetadata, MessagePayload$1 as MessagePayload, MessageReceivedHandlerParams$1 as MessageReceivedHandlerParams, v2_MetadataObject as MetadataObject, ModelEventPayload$1 as ModelEventPayload, ModelHandler$1 as ModelHandler, ModelParamsMap$1 as ModelParamsMap, ModelResultMap$1 as ModelResultMap, ModelType$1 as ModelType, ModelTypeName$1 as ModelTypeName, MultiRoomMemoryOptions$1 as MultiRoomMemoryOptions, ObjectGenerationParams$1 as ObjectGenerationParams, OnboardingConfig$1 as OnboardingConfig, Participant$1 as Participant, PlatformPrefix$1 as PlatformPrefix, Plugin$1 as Plugin, PluginEvents$1 as PluginEvents, Project$1 as Project, ProjectAgent$1 as ProjectAgent, Provider$1 as Provider, ProviderResult$1 as ProviderResult, Relationship$1 as Relationship, v2_RemoteAttestationMessage as RemoteAttestationMessage, v2_RemoteAttestationQuote as RemoteAttestationQuote, Role$1 as Role, Room$1 as Room, RoomMetadata$1 as RoomMetadata, Route$1 as Route, RunEventPayload$1 as RunEventPayload, RuntimeSettings$1 as RuntimeSettings, SOCKET_MESSAGE_TYPE$1 as SOCKET_MESSAGE_TYPE, v2_Semaphore as Semaphore, SendHandlerFunction$1 as SendHandlerFunction, type v2_ServerOwnershipState as ServerOwnershipState, Service$1 as Service, v2_ServiceBuilder as ServiceBuilder, ServiceClassMap$1 as ServiceClassMap, v2_ServiceConfig as ServiceConfig, type v2_ServiceDefinition as ServiceDefinition, ServiceError$1 as ServiceError, ServiceInstance$1 as ServiceInstance, ServiceRegistry$1 as ServiceRegistry, ServiceType$1 as ServiceType, ServiceTypeName$1 as ServiceTypeName, ServiceTypeRegistry$1 as ServiceTypeRegistry, ServiceTypeValue$1 as ServiceTypeValue, Setting$1 as Setting, State$1 as State, StateArray$1 as StateArray, StateObject$1 as StateObject, StateValue$1 as StateValue, v2_TEEMode as TEEMode, TargetInfo$1 as TargetInfo, Task$1 as Task, TaskMetadata$1 as TaskMetadata, TaskWorker$1 as TaskWorker, v2_TeeAgent as TeeAgent, v2_TeePluginConfig as TeePluginConfig, v2_TeeType as TeeType, v2_TeeVendorConfig as TeeVendorConfig, TemplateType$1 as TemplateType, TestCase$1 as TestCase, TestSuite$1 as TestSuite, TextEmbeddingParams$1 as TextEmbeddingParams, TextGenerationParams$1 as TextGenerationParams, TextToSpeechParams$1 as TextToSpeechParams, TokenizeTextParams$1 as TokenizeTextParams, TranscriptionParams$1 as TranscriptionParams, TypedEventHandler$1 as TypedEventHandler, TypedService$1 as TypedService, TypedServiceClass$1 as TypedServiceClass, UUID$1 as UUID, UnifiedMemoryOptions$1 as UnifiedMemoryOptions, UnifiedSearchOptions$1 as UnifiedSearchOptions, VECTOR_DIMS$1 as VECTOR_DIMS, Validator$1 as Validator, VideoProcessingParams$1 as VideoProcessingParams, World$1 as World, WorldPayload$1 as WorldPayload, WorldSettings$1 as WorldSettings, v2_addHeader as addHeader, asUUID$1 as asUUID, v2_booleanFooter as booleanFooter, v2_composeActionExamples as composeActionExamples, v2_composePrompt as composePrompt, v2_composePromptFromState as composePromptFromState, createMessageMemory$1 as createMessageMemory, v2_createService as createService, createServiceError$1 as createServiceError, v2_createSettingFromConfig as createSettingFromConfig, v2_createUniqueUuid as createUniqueUuid, v2_decryptObjectValues as decryptObjectValues, decryptStringValue as decryptSecret, v2_decryptStringValue as decryptStringValue, v2_decryptedCharacter as decryptedCharacter, v2_defineService as defineService, v2_elizaLogger as elizaLogger, v2_encryptObjectValues as encryptObjectValues, v2_encryptStringValue as encryptStringValue, v2_encryptedCharacter as encryptedCharacter, v2_findEntityByName as findEntityByName, v2_findWorldsForOwner as findWorldsForOwner, v2_formatActionNames as formatActionNames, v2_formatActions as formatActions, v2_formatEntities as formatEntities, v2_formatMessages as formatMessages, v2_formatPosts as formatPosts, v2_formatTimestamp as formatTimestamp, v2_getEntityDetails as getEntityDetails, getMemoryText$1 as getMemoryText, v2_getSalt as getSalt, getTypedService$1 as getTypedService, v2_getUserServerRole as getUserServerRole, v2_getWorldSettings as getWorldSettings, v2_imageDescriptionTemplate as imageDescriptionTemplate, v2_initializeOnboarding as initializeOnboarding, isCustomMetadata$1 as isCustomMetadata, isDescriptionMetadata$1 as isDescriptionMetadata, isDocumentMemory$1 as isDocumentMemory, isDocumentMetadata$1 as isDocumentMetadata, isFragmentMemory$1 as isFragmentMemory, isFragmentMetadata$1 as isFragmentMetadata, isMessageMetadata$1 as isMessageMetadata, v2_logger as logger, v2_messageHandlerTemplate as messageHandlerTemplate, v2_parseBooleanFromText as parseBooleanFromText, v2_parseJSONObjectFromText as parseJSONObjectFromText, v2_parseKeyValueXml as parseKeyValueXml, v2_postCreationTemplate as postCreationTemplate, v2_safeReplacer as safeReplacer, v2_saltSettingValue as saltSettingValue, v2_saltWorldSettings as saltWorldSettings, v2_shouldRespondTemplate as shouldRespondTemplate, v2_stringToUuid as stringToUuid, v2_trimTokens as trimTokens, v2_truncateToCompleteSentence as truncateToCompleteSentence, v2_unsaltSettingValue as unsaltSettingValue, v2_unsaltWorldSettings as unsaltWorldSettings, v2_updateWorldSettings as updateWorldSettings, v2_validateUuid as validateUuid };
}

export { type FragmentMetadata as $, type Action as A, type WorldSettings as B, ContentType as C, v2 as D, type Entity as E, asUUID as F, type Media as G, type HandlerCallback as H, type IAgentRuntime as I, type StateValue as J, type StateObject as K, type Log as L, type Metadata as M, type StateArray as N, type OnboardingConfig as O, type Participant as P, type EnhancedState as Q, type Room as R, Service as S, type TemplateType as T, type UUID as U, type MemoryTypeAlias as V, type World as W, MemoryType as X, type MemoryScope as Y, type BaseMetadata as Z, type DocumentMetadata as _, type State as a, VECTOR_DIMS as a$, type MessageMetadata as a0, type DescriptionMetadata as a1, type CustomMetadata as a2, type MessageMemory as a3, createMessageMemory as a4, isDocumentMetadata as a5, isFragmentMetadata as a6, isMessageMetadata as a7, isDescriptionMetadata as a8, isCustomMetadata as a9, ServiceType as aA, type TypedService as aB, getTypedService as aC, type ServiceError as aD, createServiceError as aE, ModelType as aF, type GenerateTextParams as aG, type DetokenizeTextParams as aH, type BaseModelParams as aI, type TextGenerationParams as aJ, type TextEmbeddingParams as aK, type TokenizeTextParams as aL, type ImageGenerationParams as aM, type ImageDescriptionParams as aN, type TranscriptionParams as aO, type TextToSpeechParams as aP, type AudioProcessingParams as aQ, type VideoProcessingParams as aR, type JSONSchema as aS, type ObjectGenerationParams as aT, type EmbeddingSearchResult as aU, type MemoryRetrievalOptions as aV, type MemorySearchOptions as aW, type MultiRoomMemoryOptions as aX, type UnifiedMemoryOptions as aY, type UnifiedSearchOptions as aZ, type DbConnection as a_, isDocumentMemory as aa, isFragmentMemory as ab, getMemoryText as ac, type KnowledgeItem as ad, KnowledgeScope as ae, CacheKeyPrefix as af, type DirectoryItem as ag, type ChunkRow as ah, type RoomMetadata as ai, type MessageExample as aj, AgentStatus as ak, type ActionExample as al, type Handler as am, type Validator as an, type EvaluationExample as ao, type ProviderResult as ap, type PluginEvents as aq, type ProjectAgent as ar, type Project as as, type ServiceTypeRegistry as at, type ServiceTypeValue as au, type IsValidServiceType as av, type TypedServiceClass as aw, type ServiceClassMap as ax, type ServiceInstance as ay, type ServiceRegistry as az, type Memory as b, formatPosts as b$, EventType as b0, PlatformPrefix as b1, type EventPayload as b2, type WorldPayload as b3, type EntityPayload as b4, type MessagePayload as b5, type ChannelClearedPayload as b6, type InvokePayload as b7, type RunEventPayload as b8, type ActionEventPayload as b9, messageHandlerTemplate as bA, postCreationTemplate as bB, booleanFooter as bC, imageDescriptionTemplate as bD, type ServerOwnershipState as bE, getUserServerRole as bF, findWorldsForOwner as bG, Semaphore as bH, AgentRuntime as bI, decryptStringValue as bJ, createSettingFromConfig as bK, getSalt as bL, encryptStringValue as bM, saltSettingValue as bN, unsaltSettingValue as bO, saltWorldSettings as bP, unsaltWorldSettings as bQ, updateWorldSettings as bR, getWorldSettings as bS, initializeOnboarding as bT, encryptedCharacter as bU, decryptedCharacter as bV, encryptObjectValues as bW, decryptObjectValues as bX, composePrompt as bY, composePromptFromState as bZ, addHeader as b_, type EvaluatorEventPayload as ba, type ModelEventPayload as bb, type MessageReceivedHandlerParams as bc, type EventPayloadMap as bd, type EventHandler as be, type TypedEventHandler as bf, type TaskMetadata as bg, SOCKET_MESSAGE_TYPE as bh, type ControlMessage as bi, type TestCase as bj, type TestSuite as bk, ServiceBuilder$1 as bl, createService$1 as bm, type ServiceDefinition$1 as bn, defineService$1 as bo, composeActionExamples as bp, formatActionNames as bq, formatActions as br, DatabaseAdapter as bs, findEntityByName as bt, createUniqueUuid as bu, getEntityDetails as bv, formatEntities as bw, logger as bx, elizaLogger as by, shouldRespondTemplate as bz, type Character as c, formatMessages as c0, formatTimestamp as c1, validateUuid as c2, stringToUuid as c3, truncateToCompleteSentence as c4, parseKeyValueXml as c5, parseJSONObjectFromText as c6, parseBooleanFromText as c7, safeReplacer as c8, trimTokens as c9, ServiceBuilder as ca, createService as cb, type ServiceDefinition as cc, defineService as cd, type IDatabaseAdapter as d, type Component as e, type MemoryMetadata as f, type Relationship as g, type Agent as h, type Task as i, Role as j, type Evaluator as k, type Provider as l, type Plugin as m, type ServiceTypeName as n, type ModelHandler as o, type Route as p, type RuntimeSettings as q, ChannelType as r, type ModelTypeName as s, type ModelResultMap as t, type ModelParamsMap as u, type TaskWorker as v, type SendHandlerFunction as w, type TargetInfo as x, type Content as y, type Setting as z };
