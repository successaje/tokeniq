import {
  createTemplateFunction,
  getTemplateValues,
  processTemplate
} from "./chunk-2HSL25IJ.js";
import {
  ActionTimelineType,
  CacheKeyPrefix,
  CacheStore,
  GoalStatus,
  IrysDataType,
  IrysMessageType,
  KnowledgeScope,
  LoggingLevel,
  ModelClass,
  ModelProviderName,
  Service,
  ServiceType,
  TokenizerType,
  TranscriptionProvider
} from "./chunk-WO7Z3GE6.js";
import {
  convertContentToV1,
  convertContentToV2,
  fromV2ActionExample,
  toV2ActionExample
} from "./chunk-U2ADTLZY.js";
import {
  fromV2Provider,
  toV2Provider
} from "./chunk-JX2SRFHQ.js";
import {
  fromV2State,
  toV2State
} from "./chunk-YIBXLDIR.js";
import {
  __export,
  __require
} from "./chunk-R5U7XKVJ.js";

// src/specs/v2/index.ts
var v2_exports = {};
__export(v2_exports, {
  AgentRuntime: () => AgentRuntime2,
  AgentStatus: () => AgentStatus,
  CacheKeyPrefix: () => CacheKeyPrefix2,
  ChannelType: () => ChannelType,
  ContentType: () => ContentType,
  DatabaseAdapter: () => DatabaseAdapter,
  EventType: () => EventType,
  KnowledgeScope: () => KnowledgeScope2,
  MemoryType: () => MemoryType,
  ModelType: () => ModelType,
  PlatformPrefix: () => PlatformPrefix,
  Role: () => Role,
  SOCKET_MESSAGE_TYPE: () => SOCKET_MESSAGE_TYPE,
  Semaphore: () => Semaphore2,
  Service: () => Service2,
  ServiceBuilder: () => ServiceBuilder2,
  ServiceType: () => ServiceType2,
  TEEMode: () => TEEMode,
  TeeType: () => TeeType,
  VECTOR_DIMS: () => VECTOR_DIMS,
  addHeader: () => addHeader2,
  asUUID: () => asUUID,
  booleanFooter: () => booleanFooter2,
  composeActionExamples: () => composeActionExamples,
  composePrompt: () => composePrompt2,
  composePromptFromState: () => composePromptFromState2,
  createMessageMemory: () => createMessageMemory,
  createService: () => createService2,
  createServiceError: () => createServiceError,
  createSettingFromConfig: () => createSettingFromConfig2,
  createUniqueUuid: () => createUniqueUuid2,
  decryptObjectValues: () => decryptObjectValues2,
  decryptSecret: () => decryptStringValue2,
  decryptStringValue: () => decryptStringValue2,
  decryptedCharacter: () => decryptedCharacter2,
  defineService: () => defineService2,
  elizaLogger: () => elizaLogger2,
  encryptObjectValues: () => encryptObjectValues2,
  encryptStringValue: () => encryptStringValue2,
  encryptedCharacter: () => encryptedCharacter2,
  findEntityByName: () => findEntityByName2,
  findWorldsForOwner: () => findWorldsForOwner2,
  formatActionNames: () => formatActionNames,
  formatActions: () => formatActions,
  formatEntities: () => formatEntities2,
  formatMessages: () => formatMessages2,
  formatPosts: () => formatPosts2,
  formatTimestamp: () => formatTimestamp2,
  getEntityDetails: () => getEntityDetails2,
  getMemoryText: () => getMemoryText,
  getSalt: () => getSalt2,
  getTypedService: () => getTypedService,
  getUserServerRole: () => getUserServerRole2,
  getWorldSettings: () => getWorldSettings2,
  imageDescriptionTemplate: () => imageDescriptionTemplate2,
  initializeOnboarding: () => initializeOnboarding2,
  isCustomMetadata: () => isCustomMetadata,
  isDescriptionMetadata: () => isDescriptionMetadata,
  isDocumentMemory: () => isDocumentMemory,
  isDocumentMetadata: () => isDocumentMetadata,
  isFragmentMemory: () => isFragmentMemory,
  isFragmentMetadata: () => isFragmentMetadata,
  isMessageMetadata: () => isMessageMetadata,
  logger: () => logger2,
  messageHandlerTemplate: () => messageHandlerTemplate2,
  parseBooleanFromText: () => parseBooleanFromText3,
  parseJSONObjectFromText: () => parseJSONObjectFromText2,
  parseKeyValueXml: () => parseKeyValueXml2,
  postCreationTemplate: () => postCreationTemplate2,
  safeReplacer: () => safeReplacer2,
  saltSettingValue: () => saltSettingValue2,
  saltWorldSettings: () => saltWorldSettings2,
  shouldRespondTemplate: () => shouldRespondTemplate2,
  stringToUuid: () => stringToUuid2,
  trimTokens: () => trimTokens2,
  truncateToCompleteSentence: () => truncateToCompleteSentence2,
  unsaltSettingValue: () => unsaltSettingValue2,
  unsaltWorldSettings: () => unsaltWorldSettings2,
  updateWorldSettings: () => updateWorldSettings2,
  validateUuid: () => validateUuid2
});

// src/specs/v2/types.ts
function asUUID(id) {
  if (!id || !/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(id)) {
    throw new Error(`Invalid UUID format: ${id}`);
  }
  return id;
}
var ModelType = {
  SMALL: "TEXT_SMALL",
  // kept for backwards compatibility
  MEDIUM: "TEXT_LARGE",
  // kept for backwards compatibility
  LARGE: "TEXT_LARGE",
  // kept for backwards compatibility
  TEXT_SMALL: "TEXT_SMALL",
  TEXT_LARGE: "TEXT_LARGE",
  TEXT_EMBEDDING: "TEXT_EMBEDDING",
  TEXT_TOKENIZER_ENCODE: "TEXT_TOKENIZER_ENCODE",
  TEXT_TOKENIZER_DECODE: "TEXT_TOKENIZER_DECODE",
  TEXT_REASONING_SMALL: "REASONING_SMALL",
  TEXT_REASONING_LARGE: "REASONING_LARGE",
  TEXT_COMPLETION: "TEXT_COMPLETION",
  IMAGE: "IMAGE",
  IMAGE_DESCRIPTION: "IMAGE_DESCRIPTION",
  TRANSCRIPTION: "TRANSCRIPTION",
  TEXT_TO_SPEECH: "TEXT_TO_SPEECH",
  AUDIO: "AUDIO",
  VIDEO: "VIDEO",
  OBJECT_SMALL: "OBJECT_SMALL",
  OBJECT_LARGE: "OBJECT_LARGE"
};
var ServiceType2 = {
  TRANSCRIPTION: "transcription",
  VIDEO: "video",
  BROWSER: "browser",
  PDF: "pdf",
  REMOTE_FILES: "aws_s3",
  WEB_SEARCH: "web_search",
  EMAIL: "email",
  TEE: "tee",
  TASK: "task"
};
var MemoryType = /* @__PURE__ */ ((MemoryType3) => {
  MemoryType3["DOCUMENT"] = "document";
  MemoryType3["FRAGMENT"] = "fragment";
  MemoryType3["MESSAGE"] = "message";
  MemoryType3["DESCRIPTION"] = "description";
  MemoryType3["CUSTOM"] = "custom";
  return MemoryType3;
})(MemoryType || {});
var ContentType = /* @__PURE__ */ ((ContentType3) => {
  ContentType3["IMAGE"] = "image";
  ContentType3["VIDEO"] = "video";
  ContentType3["AUDIO"] = "audio";
  ContentType3["DOCUMENT"] = "document";
  ContentType3["LINK"] = "link";
  return ContentType3;
})(ContentType || {});
var ChannelType = /* @__PURE__ */ ((ChannelType4) => {
  ChannelType4["SELF"] = "SELF";
  ChannelType4["DM"] = "DM";
  ChannelType4["GROUP"] = "GROUP";
  ChannelType4["VOICE_DM"] = "VOICE_DM";
  ChannelType4["VOICE_GROUP"] = "VOICE_GROUP";
  ChannelType4["FEED"] = "FEED";
  ChannelType4["THREAD"] = "THREAD";
  ChannelType4["WORLD"] = "WORLD";
  ChannelType4["FORUM"] = "FORUM";
  ChannelType4["API"] = "API";
  return ChannelType4;
})(ChannelType || {});
var AgentStatus = /* @__PURE__ */ ((AgentStatus3) => {
  AgentStatus3["ACTIVE"] = "active";
  AgentStatus3["INACTIVE"] = "inactive";
  return AgentStatus3;
})(AgentStatus || {});
var KnowledgeScope2 = /* @__PURE__ */ ((KnowledgeScope4) => {
  KnowledgeScope4["SHARED"] = "shared";
  KnowledgeScope4["PRIVATE"] = "private";
  return KnowledgeScope4;
})(KnowledgeScope2 || {});
var CacheKeyPrefix2 = /* @__PURE__ */ ((CacheKeyPrefix4) => {
  CacheKeyPrefix4["KNOWLEDGE"] = "knowledge";
  return CacheKeyPrefix4;
})(CacheKeyPrefix2 || {});
var TEEMode = /* @__PURE__ */ ((TEEMode3) => {
  TEEMode3["OFF"] = "OFF";
  TEEMode3["LOCAL"] = "LOCAL";
  TEEMode3["DOCKER"] = "DOCKER";
  TEEMode3["PRODUCTION"] = "PRODUCTION";
  return TEEMode3;
})(TEEMode || {});
var TeeType = /* @__PURE__ */ ((TeeType3) => {
  TeeType3["TDX_DSTACK"] = "tdx_dstack";
  return TeeType3;
})(TeeType || {});
var Role = /* @__PURE__ */ ((Role3) => {
  Role3["OWNER"] = "OWNER";
  Role3["ADMIN"] = "ADMIN";
  Role3["NONE"] = "NONE";
  return Role3;
})(Role || {});
var EventType = /* @__PURE__ */ ((EventType3) => {
  EventType3["WORLD_JOINED"] = "WORLD_JOINED";
  EventType3["WORLD_CONNECTED"] = "WORLD_CONNECTED";
  EventType3["WORLD_LEFT"] = "WORLD_LEFT";
  EventType3["ENTITY_JOINED"] = "ENTITY_JOINED";
  EventType3["ENTITY_LEFT"] = "ENTITY_LEFT";
  EventType3["ENTITY_UPDATED"] = "ENTITY_UPDATED";
  EventType3["ROOM_JOINED"] = "ROOM_JOINED";
  EventType3["ROOM_LEFT"] = "ROOM_LEFT";
  EventType3["MESSAGE_RECEIVED"] = "MESSAGE_RECEIVED";
  EventType3["MESSAGE_SENT"] = "MESSAGE_SENT";
  EventType3["MESSAGE_DELETED"] = "MESSAGE_DELETED";
  EventType3["CHANNEL_CLEARED"] = "CHANNEL_CLEARED";
  EventType3["VOICE_MESSAGE_RECEIVED"] = "VOICE_MESSAGE_RECEIVED";
  EventType3["VOICE_MESSAGE_SENT"] = "VOICE_MESSAGE_SENT";
  EventType3["REACTION_RECEIVED"] = "REACTION_RECEIVED";
  EventType3["POST_GENERATED"] = "POST_GENERATED";
  EventType3["INTERACTION_RECEIVED"] = "INTERACTION_RECEIVED";
  EventType3["RUN_STARTED"] = "RUN_STARTED";
  EventType3["RUN_ENDED"] = "RUN_ENDED";
  EventType3["RUN_TIMEOUT"] = "RUN_TIMEOUT";
  EventType3["ACTION_STARTED"] = "ACTION_STARTED";
  EventType3["ACTION_COMPLETED"] = "ACTION_COMPLETED";
  EventType3["EVALUATOR_STARTED"] = "EVALUATOR_STARTED";
  EventType3["EVALUATOR_COMPLETED"] = "EVALUATOR_COMPLETED";
  EventType3["MODEL_USED"] = "MODEL_USED";
  return EventType3;
})(EventType || {});
var PlatformPrefix = /* @__PURE__ */ ((PlatformPrefix3) => {
  PlatformPrefix3["DISCORD"] = "DISCORD";
  PlatformPrefix3["TELEGRAM"] = "TELEGRAM";
  PlatformPrefix3["TWITTER"] = "TWITTER";
  return PlatformPrefix3;
})(PlatformPrefix || {});
var SOCKET_MESSAGE_TYPE = /* @__PURE__ */ ((SOCKET_MESSAGE_TYPE3) => {
  SOCKET_MESSAGE_TYPE3[SOCKET_MESSAGE_TYPE3["ROOM_JOINING"] = 1] = "ROOM_JOINING";
  SOCKET_MESSAGE_TYPE3[SOCKET_MESSAGE_TYPE3["SEND_MESSAGE"] = 2] = "SEND_MESSAGE";
  SOCKET_MESSAGE_TYPE3[SOCKET_MESSAGE_TYPE3["MESSAGE"] = 3] = "MESSAGE";
  SOCKET_MESSAGE_TYPE3[SOCKET_MESSAGE_TYPE3["ACK"] = 4] = "ACK";
  SOCKET_MESSAGE_TYPE3[SOCKET_MESSAGE_TYPE3["THINKING"] = 5] = "THINKING";
  SOCKET_MESSAGE_TYPE3[SOCKET_MESSAGE_TYPE3["CONTROL"] = 6] = "CONTROL";
  return SOCKET_MESSAGE_TYPE3;
})(SOCKET_MESSAGE_TYPE || {});
function createMessageMemory(params) {
  return {
    ...params,
    createdAt: Date.now(),
    metadata: {
      type: "message" /* MESSAGE */,
      timestamp: Date.now(),
      scope: params.agentId ? "private" : "shared"
    }
  };
}
function getTypedService(runtime, serviceType) {
  return runtime.getService(serviceType);
}
function isDocumentMetadata(metadata) {
  return metadata.type === "document" /* DOCUMENT */;
}
function isFragmentMetadata(metadata) {
  return metadata.type === "fragment" /* FRAGMENT */;
}
function isMessageMetadata(metadata) {
  return metadata.type === "message" /* MESSAGE */;
}
function isDescriptionMetadata(metadata) {
  return metadata.type === "description" /* DESCRIPTION */;
}
function isCustomMetadata(metadata) {
  return metadata.type !== "document" /* DOCUMENT */ && metadata.type !== "fragment" /* FRAGMENT */ && metadata.type !== "message" /* MESSAGE */ && metadata.type !== "description" /* DESCRIPTION */;
}
function isDocumentMemory(memory) {
  return memory.metadata?.type === "document" /* DOCUMENT */;
}
function isFragmentMemory(memory) {
  return memory.metadata?.type === "fragment" /* FRAGMENT */;
}
function getMemoryText(memory, defaultValue = "") {
  return memory.content.text ?? defaultValue;
}
function createServiceError(error, code = "UNKNOWN_ERROR") {
  if (error instanceof Error) {
    return {
      code,
      message: error.message,
      cause: error
    };
  }
  return {
    code,
    message: String(error)
  };
}
var VECTOR_DIMS = {
  SMALL: 384,
  MEDIUM: 512,
  LARGE: 768,
  XL: 1024,
  XXL: 1536,
  XXXL: 3072
};
var Service2 = class {
  constructor(runtime) {
    if (runtime) {
      this.runtime = runtime;
    }
  }
  /** Start service connection */
  static async start(_runtime) {
    throw new Error("Not implemented");
  }
  /** Stop service connection */
  static async stop(_runtime) {
    throw new Error("Not implemented");
  }
};

// src/specs/v2/actions.ts
var composeActionExamples = (actionsData, count) => {
  const actionExamples = [];
  const names3 = ["Alice", "Bob", "Charlie", "David", "Eve", "Frank", "Grace", "Heidi"];
  const usedNames = /* @__PURE__ */ new Set();
  const getRandomName = () => {
    const availableNames = names3.filter((name2) => !usedNames.has(name2));
    if (availableNames.length === 0) {
      usedNames.clear();
      return names3[Math.floor(Math.random() * names3.length)];
    }
    const name = availableNames[Math.floor(Math.random() * availableNames.length)];
    usedNames.add(name);
    return name;
  };
  const allExamples = [];
  for (const action of actionsData) {
    if (action.examples) {
      for (const example of action.examples) {
        allExamples.push({ action, example });
      }
    }
  }
  for (let i = 0; i < count && allExamples.length > 0; i++) {
    const randomIndex = Math.floor(Math.random() * allExamples.length);
    const { example } = allExamples[randomIndex];
    const randomNames = Array.from({ length: 5 }, () => getRandomName());
    const formattedExample = example.map((msg) => {
      let text = msg.content.text || "";
      for (let j = 0; j < randomNames.length; j++) {
        text = text.replace(new RegExp(`{{name${j + 1}}}`, "g"), randomNames[j]);
      }
      return `${msg.name}: ${text}`;
    }).join("\n");
    actionExamples.push(formattedExample);
  }
  return actionExamples.join("\n\n");
};
function formatActionNames(actions) {
  return actions.map((action) => action.name).join(", ");
}
function formatActions(actions) {
  return actions.map((action) => `${action.name}: ${action.description}`).join(",\n");
}

// src/specs/v2/database.ts
var DatabaseAdapter = class {
  /**
   * Creates a new DatabaseAdapter instance.
   * @param db The database instance to use.
   */
  constructor(db) {
    this.db = db;
  }
};

// src/types/primitives.ts
function asUUID2(id) {
  if (!id || !/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(id)) {
    throw new Error(`Invalid UUID format: ${id}`);
  }
  return id;
}
var ContentType2 = /* @__PURE__ */ ((ContentType3) => {
  ContentType3["IMAGE"] = "image";
  ContentType3["VIDEO"] = "video";
  ContentType3["AUDIO"] = "audio";
  ContentType3["DOCUMENT"] = "document";
  ContentType3["LINK"] = "link";
  return ContentType3;
})(ContentType2 || {});

// src/types/memory.ts
var MemoryType2 = /* @__PURE__ */ ((MemoryType3) => {
  MemoryType3["DOCUMENT"] = "document";
  MemoryType3["FRAGMENT"] = "fragment";
  MemoryType3["MESSAGE"] = "message";
  MemoryType3["DESCRIPTION"] = "description";
  MemoryType3["CUSTOM"] = "custom";
  return MemoryType3;
})(MemoryType2 || {});
function createMessageMemory2(params) {
  return {
    ...params,
    createdAt: Date.now(),
    metadata: {
      type: "message" /* MESSAGE */,
      timestamp: Date.now(),
      scope: params.agentId ? "private" : "shared"
    }
  };
}
function isDocumentMetadata2(metadata) {
  return metadata.type === "document" /* DOCUMENT */;
}
function isFragmentMetadata2(metadata) {
  return metadata.type === "fragment" /* FRAGMENT */;
}
function isMessageMetadata2(metadata) {
  return metadata.type === "message" /* MESSAGE */;
}
function isDescriptionMetadata2(metadata) {
  return metadata.type === "description" /* DESCRIPTION */;
}
function isCustomMetadata2(metadata) {
  return metadata.type !== "document" /* DOCUMENT */ && metadata.type !== "fragment" /* FRAGMENT */ && metadata.type !== "message" /* MESSAGE */ && metadata.type !== "description" /* DESCRIPTION */;
}
function isDocumentMemory2(memory) {
  return memory.metadata?.type === "document" /* DOCUMENT */;
}
function isFragmentMemory2(memory) {
  return memory.metadata?.type === "fragment" /* FRAGMENT */;
}
function getMemoryText2(memory, defaultValue = "") {
  return memory.content.text ?? defaultValue;
}

// src/types/knowledge.ts
var KnowledgeScope3 = /* @__PURE__ */ ((KnowledgeScope4) => {
  KnowledgeScope4["SHARED"] = "shared";
  KnowledgeScope4["PRIVATE"] = "private";
  return KnowledgeScope4;
})(KnowledgeScope3 || {});
var CacheKeyPrefix3 = /* @__PURE__ */ ((CacheKeyPrefix4) => {
  CacheKeyPrefix4["KNOWLEDGE"] = "knowledge";
  return CacheKeyPrefix4;
})(CacheKeyPrefix3 || {});

// src/types/environment.ts
var Role2 = /* @__PURE__ */ ((Role3) => {
  Role3["OWNER"] = "OWNER";
  Role3["ADMIN"] = "ADMIN";
  Role3["NONE"] = "NONE";
  return Role3;
})(Role2 || {});
var ChannelType2 = /* @__PURE__ */ ((ChannelType4) => {
  ChannelType4["SELF"] = "SELF";
  ChannelType4["DM"] = "DM";
  ChannelType4["GROUP"] = "GROUP";
  ChannelType4["VOICE_DM"] = "VOICE_DM";
  ChannelType4["VOICE_GROUP"] = "VOICE_GROUP";
  ChannelType4["FEED"] = "FEED";
  ChannelType4["THREAD"] = "THREAD";
  ChannelType4["WORLD"] = "WORLD";
  ChannelType4["FORUM"] = "FORUM";
  ChannelType4["API"] = "API";
  return ChannelType4;
})(ChannelType2 || {});

// src/types/agent.ts
var AgentStatus2 = /* @__PURE__ */ ((AgentStatus3) => {
  AgentStatus3["ACTIVE"] = "active";
  AgentStatus3["INACTIVE"] = "inactive";
  return AgentStatus3;
})(AgentStatus2 || {});

// src/types/service.ts
var ServiceType3 = {
  TRANSCRIPTION: "transcription",
  VIDEO: "video",
  BROWSER: "browser",
  PDF: "pdf",
  REMOTE_FILES: "aws_s3",
  WEB_SEARCH: "web_search",
  EMAIL: "email",
  TEE: "tee",
  TASK: "task",
  WALLET: "wallet",
  LP_POOL: "lp_pool",
  TOKEN_DATA: "token_data",
  DATABASE_MIGRATION: "database_migration",
  PLUGIN_MANAGER: "PLUGIN_MANAGER",
  PLUGIN_CONFIGURATION: "PLUGIN_CONFIGURATION",
  PLUGIN_USER_INTERACTION: "PLUGIN_USER_INTERACTION"
};
var Service3 = class {
  constructor(runtime) {
    if (runtime) {
      this.runtime = runtime;
    }
  }
  /** Start service connection */
  static async start(_runtime) {
    throw new Error("Not implemented");
  }
  /** Stop service connection */
  static async stop(_runtime) {
    throw new Error("Not implemented");
  }
};
function getTypedService2(runtime, serviceType) {
  return runtime.getService(serviceType);
}
function createServiceError2(error, code = "UNKNOWN_ERROR") {
  if (error instanceof Error) {
    return {
      code,
      message: error.message,
      cause: error
    };
  }
  return {
    code,
    message: String(error)
  };
}

// src/types/model.ts
var ModelType2 = {
  SMALL: "TEXT_SMALL",
  // kept for backwards compatibility
  MEDIUM: "TEXT_LARGE",
  // kept for backwards compatibility
  LARGE: "TEXT_LARGE",
  // kept for backwards compatibility
  TEXT_SMALL: "TEXT_SMALL",
  TEXT_LARGE: "TEXT_LARGE",
  TEXT_EMBEDDING: "TEXT_EMBEDDING",
  TEXT_TOKENIZER_ENCODE: "TEXT_TOKENIZER_ENCODE",
  TEXT_TOKENIZER_DECODE: "TEXT_TOKENIZER_DECODE",
  TEXT_REASONING_SMALL: "REASONING_SMALL",
  TEXT_REASONING_LARGE: "REASONING_LARGE",
  TEXT_COMPLETION: "TEXT_COMPLETION",
  IMAGE: "IMAGE",
  IMAGE_DESCRIPTION: "IMAGE_DESCRIPTION",
  TRANSCRIPTION: "TRANSCRIPTION",
  TEXT_TO_SPEECH: "TEXT_TO_SPEECH",
  AUDIO: "AUDIO",
  VIDEO: "VIDEO",
  OBJECT_SMALL: "OBJECT_SMALL",
  OBJECT_LARGE: "OBJECT_LARGE"
};

// src/types/database.ts
var VECTOR_DIMS2 = {
  SMALL: 384,
  MEDIUM: 512,
  LARGE: 768,
  XL: 1024,
  XXL: 1536,
  XXXL: 3072
};

// src/types/events.ts
var EventType2 = /* @__PURE__ */ ((EventType3) => {
  EventType3["WORLD_JOINED"] = "WORLD_JOINED";
  EventType3["WORLD_CONNECTED"] = "WORLD_CONNECTED";
  EventType3["WORLD_LEFT"] = "WORLD_LEFT";
  EventType3["ENTITY_JOINED"] = "ENTITY_JOINED";
  EventType3["ENTITY_LEFT"] = "ENTITY_LEFT";
  EventType3["ENTITY_UPDATED"] = "ENTITY_UPDATED";
  EventType3["ROOM_JOINED"] = "ROOM_JOINED";
  EventType3["ROOM_LEFT"] = "ROOM_LEFT";
  EventType3["MESSAGE_RECEIVED"] = "MESSAGE_RECEIVED";
  EventType3["MESSAGE_SENT"] = "MESSAGE_SENT";
  EventType3["MESSAGE_DELETED"] = "MESSAGE_DELETED";
  EventType3["CHANNEL_CLEARED"] = "CHANNEL_CLEARED";
  EventType3["VOICE_MESSAGE_RECEIVED"] = "VOICE_MESSAGE_RECEIVED";
  EventType3["VOICE_MESSAGE_SENT"] = "VOICE_MESSAGE_SENT";
  EventType3["REACTION_RECEIVED"] = "REACTION_RECEIVED";
  EventType3["POST_GENERATED"] = "POST_GENERATED";
  EventType3["INTERACTION_RECEIVED"] = "INTERACTION_RECEIVED";
  EventType3["RUN_STARTED"] = "RUN_STARTED";
  EventType3["RUN_ENDED"] = "RUN_ENDED";
  EventType3["RUN_TIMEOUT"] = "RUN_TIMEOUT";
  EventType3["ACTION_STARTED"] = "ACTION_STARTED";
  EventType3["ACTION_COMPLETED"] = "ACTION_COMPLETED";
  EventType3["EVALUATOR_STARTED"] = "EVALUATOR_STARTED";
  EventType3["EVALUATOR_COMPLETED"] = "EVALUATOR_COMPLETED";
  EventType3["MODEL_USED"] = "MODEL_USED";
  return EventType3;
})(EventType2 || {});
var PlatformPrefix2 = /* @__PURE__ */ ((PlatformPrefix3) => {
  PlatformPrefix3["DISCORD"] = "DISCORD";
  PlatformPrefix3["TELEGRAM"] = "TELEGRAM";
  PlatformPrefix3["TWITTER"] = "TWITTER";
  return PlatformPrefix3;
})(PlatformPrefix2 || {});

// src/types/tee.ts
var TEEMode2 = /* @__PURE__ */ ((TEEMode3) => {
  TEEMode3["OFF"] = "OFF";
  TEEMode3["LOCAL"] = "LOCAL";
  TEEMode3["DOCKER"] = "DOCKER";
  TEEMode3["PRODUCTION"] = "PRODUCTION";
  return TEEMode3;
})(TEEMode2 || {});
var TeeType2 = /* @__PURE__ */ ((TeeType3) => {
  TeeType3["TDX_DSTACK"] = "tdx_dstack";
  return TeeType3;
})(TeeType2 || {});

// src/types/token.ts
var ITokenDataService = class extends Service3 {
  constructor() {
    super(...arguments);
    this.capabilityDescription = "Provides standardized access to token market data.";
  }
  static {
    this.serviceType = ServiceType3.TOKEN_DATA;
  }
  // Future potential methods:
  // getHistoricalPriceData(address: string, chain: string, timeFrame: string): Promise<any[]>;
  // getTokenMarketChart(address: string, chain: string, days: number): Promise<any[]>;
};

// src/types/messaging.ts
var SOCKET_MESSAGE_TYPE2 = /* @__PURE__ */ ((SOCKET_MESSAGE_TYPE3) => {
  SOCKET_MESSAGE_TYPE3[SOCKET_MESSAGE_TYPE3["ROOM_JOINING"] = 1] = "ROOM_JOINING";
  SOCKET_MESSAGE_TYPE3[SOCKET_MESSAGE_TYPE3["SEND_MESSAGE"] = 2] = "SEND_MESSAGE";
  SOCKET_MESSAGE_TYPE3[SOCKET_MESSAGE_TYPE3["MESSAGE"] = 3] = "MESSAGE";
  SOCKET_MESSAGE_TYPE3[SOCKET_MESSAGE_TYPE3["ACK"] = 4] = "ACK";
  SOCKET_MESSAGE_TYPE3[SOCKET_MESSAGE_TYPE3["THINKING"] = 5] = "THINKING";
  SOCKET_MESSAGE_TYPE3[SOCKET_MESSAGE_TYPE3["CONTROL"] = 6] = "CONTROL";
  return SOCKET_MESSAGE_TYPE3;
})(SOCKET_MESSAGE_TYPE2 || {});

// src/types/wallet.ts
var IWalletService = class extends Service3 {
  constructor() {
    super(...arguments);
    this.capabilityDescription = "Provides standardized access to wallet balances and portfolios.";
  }
  static {
    this.serviceType = ServiceType3.WALLET;
  }
};

// src/types/lp.ts
var ILpService = class extends Service3 {
  constructor() {
    super(...arguments);
    this.capabilityDescription = "Provides standardized access to DEX liquidity pools.";
  }
  static {
    this.serviceType = "lp";
  }
};

// src/utils.ts
import handlebars from "handlebars";
import { sha1 } from "js-sha1";
import { RecursiveCharacterTextSplitter } from "langchain/text_splitter";
import { names, uniqueNamesGenerator } from "unique-names-generator";
import { z } from "zod";

// src/logger.ts
import pino from "pino";

// src/sentry/instrument.ts
import * as Sentry from "@sentry/browser";
var dsn = process.env.SENTRY_DSN || "https://c20e2d51b66c14a783b0689d536f7e5c@o4509349865259008.ingest.us.sentry.io/4509352524120064";
if (process.env.SENTRY_LOGGING !== "false") {
  Sentry.onLoad(() => {
    Sentry.init({
      dsn,
      environment: process.env.SENTRY_ENVIRONMENT || process.env.NODE_ENV,
      tracesSampleRate: parseFloat(process.env.SENTRY_TRACES_SAMPLE_RATE ?? "") || 1,
      sendDefaultPii: process.env.SENTRY_SEND_DEFAULT_PII === "true"
    });
  });
}

// src/logger.ts
function parseBooleanFromText(value) {
  if (!value) return false;
  const normalized = value.toLowerCase().trim();
  return normalized === "true" || normalized === "1" || normalized === "yes" || normalized === "on";
}
var InMemoryDestination = class {
  /**
   * Constructor for creating a new instance of the class.
   * @param {DestinationStream|null} stream - The stream to assign to the instance. Can be null.
   */
  constructor(stream) {
    this.logs = [];
    this.maxLogs = 1e3;
    this.stream = stream;
  }
  /**
   * Writes a log entry to the memory buffer and forwards it to the pretty print stream if available.
   *
   * @param {string | LogEntry} data - The data to be written, which can be either a string or a LogEntry object.
   * @returns {void}
   */
  write(data) {
    let logEntry;
    let stringData;
    if (typeof data === "string") {
      stringData = data;
      try {
        logEntry = JSON.parse(data);
      } catch (e) {
        if (this.stream) {
          this.stream.write(data);
        }
        return;
      }
    } else {
      logEntry = data;
      stringData = JSON.stringify(data);
    }
    if (!logEntry.time) {
      logEntry.time = Date.now();
    }
    const isDebugMode2 = (process?.env?.LOG_LEVEL || "").toLowerCase() === "debug";
    const isLoggingDiagnostic = Boolean(process?.env?.LOG_DIAGNOSTIC);
    if (isLoggingDiagnostic) {
      logEntry.diagnostic = true;
    }
    if (!isDebugMode2) {
      if (logEntry.agentName && logEntry.agentId) {
        const msg = logEntry.msg || "";
        if (typeof msg === "string" && (msg.includes("registered successfully") || msg.includes("Registering") || msg.includes("Success:") || msg.includes("linked to") || msg.includes("Started"))) {
          if (isLoggingDiagnostic) {
            console.error("Filtered log:", stringData);
          }
          return;
        }
      }
    }
    this.logs.push(logEntry);
    if (this.logs.length > this.maxLogs) {
      this.logs.shift();
    }
    if (this.stream) {
      this.stream.write(stringData);
    }
  }
  /**
   * Retrieves the recent logs from the system.
   *
   * @returns {LogEntry[]} An array of LogEntry objects representing the recent logs.
   */
  recentLogs() {
    return this.logs;
  }
  /**
   * Clears all logs from memory.
   *
   * @returns {void}
   */
  clear() {
    this.logs = [];
  }
};
var customLevels = {
  fatal: 60,
  error: 50,
  warn: 40,
  info: 30,
  log: 29,
  progress: 28,
  success: 27,
  debug: 20,
  trace: 10
};
var raw = parseBooleanFromText(process?.env?.LOG_JSON_FORMAT) || false;
var isDebugMode = (process?.env?.LOG_LEVEL || "").toLowerCase() === "debug";
var effectiveLogLevel = isDebugMode ? "debug" : process?.env?.DEFAULT_LOG_LEVEL || "info";
var createPrettyConfig = () => ({
  colorize: true,
  translateTime: "yyyy-mm-dd HH:MM:ss",
  ignore: "pid,hostname",
  levelColors: {
    60: "red",
    // fatal
    50: "red",
    // error
    40: "yellow",
    // warn
    30: "blue",
    // info
    29: "green",
    // log
    28: "cyan",
    // progress
    27: "greenBright",
    // success
    20: "magenta",
    // debug
    10: "grey",
    // trace
    "*": "white"
    // default for any unspecified level
  },
  customPrettifiers: {
    level: (inputData) => {
      let level;
      if (typeof inputData === "object" && inputData !== null) {
        level = inputData.level || inputData.value;
      } else {
        level = inputData;
      }
      const levelNames = {
        10: "TRACE",
        20: "DEBUG",
        27: "SUCCESS",
        28: "PROGRESS",
        29: "LOG",
        30: "INFO",
        40: "WARN",
        50: "ERROR",
        60: "FATAL"
      };
      if (typeof level === "number") {
        return levelNames[level] || `LEVEL${level}`;
      }
      if (level === void 0 || level === null) {
        return "UNKNOWN";
      }
      return String(level).toUpperCase();
    },
    // Add a custom prettifier for error messages
    msg: (msg) => {
      return msg.replace(/ERROR \([^)]+\):/g, "ERROR:");
    }
  },
  messageFormat: "{msg}"
});
var createStream = async () => {
  if (raw) {
    return void 0;
  }
  const pretty = await import("pino-pretty");
  return pretty.default(createPrettyConfig());
};
var options = {
  level: effectiveLogLevel,
  // Use more restrictive level unless in debug mode
  customLevels,
  hooks: {
    logMethod(inputArgs, method) {
      const [arg1, ...rest] = inputArgs;
      if (process.env.SENTRY_LOGGING !== "false") {
        if (arg1 instanceof Error) {
          Sentry.captureException(arg1);
        } else {
          for (const item of rest) {
            if (item instanceof Error) {
              Sentry.captureException(item);
            }
          }
        }
      }
      const formatError = (err) => ({
        message: `(${err.name}) ${err.message}`,
        stack: err.stack?.split("\n").map((line) => line.trim())
      });
      if (typeof arg1 === "object") {
        if (arg1 instanceof Error) {
          method.apply(this, [
            {
              error: formatError(arg1)
            }
          ]);
        } else {
          const messageParts = rest.map(
            (arg) => typeof arg === "string" ? arg : JSON.stringify(arg)
          );
          const message = messageParts.join(" ");
          method.apply(this, [arg1, message]);
        }
      } else {
        const context = {};
        const messageParts = [arg1, ...rest].map((arg) => {
          if (arg instanceof Error) {
            return formatError(arg);
          }
          return typeof arg === "string" ? arg : arg;
        });
        const message = messageParts.filter((part) => typeof part === "string").join(" ");
        const jsonParts = messageParts.filter((part) => typeof part === "object");
        Object.assign(context, ...jsonParts);
        method.apply(this, [context, message]);
      }
    }
  }
};
var createLogger = (bindings = false) => {
  const opts = { ...options };
  if (bindings) {
    opts.base = bindings;
    opts.transport = {
      target: "pino-pretty",
      // this is just a string, not a dynamic import
      options: {
        colorize: true,
        translateTime: "SYS:standard",
        ignore: "pid,hostname"
      }
    };
  }
  const logger3 = pino(opts);
  return logger3;
};
var logger = pino(options);
if (typeof process !== "undefined") {
  let stream = null;
  if (!raw) {
    try {
      const pretty = __require("pino-pretty");
      stream = pretty.default ? pretty.default(createPrettyConfig()) : null;
    } catch (e) {
      createStream().then((prettyStream) => {
        const destination = new InMemoryDestination(prettyStream);
        logger = pino(options, destination);
        logger[Symbol.for("pino-destination")] = destination;
        logger.clear = () => {
          const destination2 = logger[Symbol.for("pino-destination")];
          if (destination2 instanceof InMemoryDestination) {
            destination2.clear();
          }
        };
      });
    }
  }
  if (stream !== null || raw) {
    const destination = new InMemoryDestination(stream);
    logger = pino(options, destination);
    logger[Symbol.for("pino-destination")] = destination;
    logger.clear = () => {
      const destination2 = logger[Symbol.for("pino-destination")];
      if (destination2 instanceof InMemoryDestination) {
        destination2.clear();
      }
    };
  }
}
var elizaLogger = logger;
var logger_default = logger;

// src/utils.ts
function upgradeDoubleToTriple(tpl) {
  return tpl.replace(
    // ────────╮ negative-LB: not already "{{{"
    //          │   {{     ─ opening braces
    //          │    ╰──── negative-LA: not {, #, /, !, >
    //          ▼
    /(?<!{){{(?![{#\/!>])([\s\S]*?)}}/g,
    (_match, inner) => {
      if (inner.trim() === "else") return `{{${inner}}}`;
      return `{{{${inner}}}}`;
    }
  );
}
var composePrompt = ({
  state,
  template
}) => {
  const templateStr = typeof template === "function" ? template({ state }) : template;
  const templateFunction = handlebars.compile(upgradeDoubleToTriple(templateStr));
  const output = composeRandomUser(templateFunction(state), 10);
  return output;
};
var composePromptFromState = ({
  state,
  template
}) => {
  const templateStr = typeof template === "function" ? template({ state }) : template;
  const templateFunction = handlebars.compile(upgradeDoubleToTriple(templateStr));
  const stateKeys = Object.keys(state);
  const filteredKeys = stateKeys.filter((key) => !["text", "values", "data"].includes(key));
  const filteredState = filteredKeys.reduce((acc, key) => {
    acc[key] = state[key];
    return acc;
  }, {});
  const output = composeRandomUser(templateFunction({ ...filteredState, ...state.values }), 10);
  return output;
};
var addHeader = (header, body) => {
  return body.length > 0 ? `${header ? `${header}
` : header}${body}
` : "";
};
var composeRandomUser = (template, length) => {
  const exampleNames = Array.from(
    { length },
    () => uniqueNamesGenerator({ dictionaries: [names] })
  );
  let result = template;
  for (let i = 0; i < exampleNames.length; i++) {
    result = result.replaceAll(`{{name${i + 1}}}`, exampleNames[i]);
  }
  return result;
};
var formatPosts = ({
  messages,
  entities,
  conversationHeader = true
}) => {
  const groupedMessages = {};
  messages.forEach((message) => {
    if (message.roomId) {
      if (!groupedMessages[message.roomId]) {
        groupedMessages[message.roomId] = [];
      }
      groupedMessages[message.roomId].push(message);
    }
  });
  Object.values(groupedMessages).forEach((roomMessages) => {
    roomMessages.sort((a, b) => a.createdAt - b.createdAt);
  });
  const sortedRooms = Object.entries(groupedMessages).sort(
    ([, messagesA], [, messagesB]) => messagesB[messagesB.length - 1].createdAt - messagesA[messagesA.length - 1].createdAt
  );
  const formattedPosts = sortedRooms.map(([roomId, roomMessages]) => {
    const messageStrings = roomMessages.filter((message) => message.entityId).map((message) => {
      const entity = entities.find((entity2) => entity2.id === message.entityId);
      if (!entity) {
        logger_default.warn("core::prompts:formatPosts - no entity for", message.entityId);
      }
      const userName = entity?.names[0] || "Unknown User";
      const displayName = entity?.names[0] || "unknown";
      return `Name: ${userName} (@${displayName} EntityID:${message.entityId})
MessageID: ${message.id}${message.content.inReplyTo ? `
In reply to: ${message.content.inReplyTo}` : ""}
Source: ${message.content.source}
Date: ${formatTimestamp(message.createdAt)}
Text:
${message.content.text}`;
    });
    const header = conversationHeader ? `Conversation: ${roomId.slice(-5)}
` : "";
    return `${header}${messageStrings.join("\n\n")}`;
  });
  return formattedPosts.join("\n\n");
};
var formatMessages = ({
  messages,
  entities
}) => {
  const messageStrings = messages.reverse().filter((message) => message.entityId).map((message) => {
    const messageText = message.content.text;
    const messageActions = message.content.actions;
    const messageThought = message.content.thought;
    const formattedName = entities.find((entity) => entity.id === message.entityId)?.names[0] || "Unknown User";
    const attachments = message.content.attachments;
    const attachmentString = attachments && attachments.length > 0 ? ` (Attachments: ${attachments.map((media) => {
      const lines = [`[${media.id} - ${media.title} (${media.url})]`];
      if (media.text) lines.push(`Text: ${media.text}`);
      if (media.description) lines.push(`Description: ${media.description}`);
      return lines.join("\n");
    }).join(
      // Use comma separator only if all attachments are single-line (no text/description)
      attachments.every((media) => !media.text && !media.description) ? ", " : "\n"
    )})` : null;
    const messageTime = new Date(message.createdAt);
    const hours = messageTime.getHours().toString().padStart(2, "0");
    const minutes = messageTime.getMinutes().toString().padStart(2, "0");
    const timeString = `${hours}:${minutes}`;
    const timestamp = formatTimestamp(message.createdAt);
    const thoughtString = messageThought ? `(${formattedName}'s internal thought: ${messageThought})` : null;
    const timestampString = `${timeString} (${timestamp}) [${message.entityId}]`;
    const textString = messageText ? `${timestampString} ${formattedName}: ${messageText}` : null;
    const actionString = messageActions && messageActions.length > 0 ? `${textString ? "" : timestampString} (${formattedName}'s actions: ${messageActions.join(", ")})` : null;
    const messageString = [textString, thoughtString, actionString, attachmentString].filter(Boolean).join("\n");
    return messageString;
  }).join("\n");
  return messageStrings;
};
var formatTimestamp = (messageDate) => {
  const now = /* @__PURE__ */ new Date();
  const diff = now.getTime() - messageDate;
  const absDiff = Math.abs(diff);
  const seconds = Math.floor(absDiff / 1e3);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  if (absDiff < 6e4) {
    return "just now";
  }
  if (minutes < 60) {
    return `${minutes} minute${minutes !== 1 ? "s" : ""} ago`;
  }
  if (hours < 24) {
    return `${hours} hour${hours !== 1 ? "s" : ""} ago`;
  }
  return `${days} day${days !== 1 ? "s" : ""} ago`;
};
var jsonBlockPattern = /```json\n([\s\S]*?)\n```/;
function parseKeyValueXml(text) {
  if (!text) return null;
  let xmlBlockMatch = text.match(/<response>([\s\S]*?)<\/response>/);
  let xmlContent;
  if (xmlBlockMatch) {
    xmlContent = xmlBlockMatch[1];
    logger_default.debug("Found response XML block");
  } else {
    const fallbackMatch = text.match(/<(\w+)>([\s\S]*?)<\/\1>/);
    if (!fallbackMatch) {
      logger_default.warn("Could not find XML block in text");
      logger_default.debug("Text content:", text.substring(0, 200) + "...");
      return null;
    }
    xmlContent = fallbackMatch[2];
    logger_default.debug(`Found XML block with tag: ${fallbackMatch[1]}`);
  }
  const result = {};
  const tagPattern = /<([\w-]+)>([\s\S]*?)<\/([\w-]+)>/g;
  let match;
  while ((match = tagPattern.exec(xmlContent)) !== null) {
    if (match[1] === match[3]) {
      const key = match[1];
      const value = match[2].replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&apos;/g, "'").trim();
      if (key === "actions" || key === "providers" || key === "evaluators") {
        result[key] = value ? value.split(",").map((s) => s.trim()) : [];
      } else if (key === "simple") {
        result[key] = value.toLowerCase() === "true";
      } else {
        result[key] = value;
      }
    } else {
      logger_default.warn(`Mismatched XML tags found: <${match[1]}> and </${match[3]}>`);
    }
  }
  if (Object.keys(result).length === 0) {
    logger_default.warn("No key-value pairs extracted from XML content");
    logger_default.debug("XML content was:", xmlContent.substring(0, 200) + "...");
    return null;
  }
  return result;
}
function parseJSONObjectFromText(text) {
  let jsonData = null;
  const jsonBlockMatch = text.match(jsonBlockPattern);
  try {
    if (jsonBlockMatch) {
      jsonData = JSON.parse(normalizeJsonString(jsonBlockMatch[1].trim()));
    } else {
      jsonData = JSON.parse(normalizeJsonString(text.trim()));
    }
  } catch (_e) {
    return null;
  }
  if (jsonData && typeof jsonData === "object" && !Array.isArray(jsonData)) {
    return jsonData;
  }
  return null;
}
var normalizeJsonString = (str) => {
  str = str.replace(/\{\s+/, "{").replace(/\s+\}/, "}").trim();
  str = str.replace(/("[\w\d_-]+")\s*: \s*(?!"|\[)([\s\S]+?)(?=(,\s*"|\}$))/g, '$1: "$2"');
  str = str.replace(/"([^"]+)"\s*:\s*'([^']*)'/g, (_, key, value) => `"${key}": "${value}"`);
  str = str.replace(/("[\w\d_-]+")\s*:\s*([A-Za-z_]+)(?!["\w])/g, '$1: "$2"');
  return str;
};
function truncateToCompleteSentence(text, maxLength) {
  if (text.length <= maxLength) {
    return text;
  }
  const lastPeriodIndex = text.lastIndexOf(".", maxLength - 1);
  if (lastPeriodIndex !== -1) {
    const truncatedAtPeriod = text.slice(0, lastPeriodIndex + 1).trim();
    if (truncatedAtPeriod.length > 0) {
      return truncatedAtPeriod;
    }
  }
  const lastSpaceIndex = text.lastIndexOf(" ", maxLength - 1);
  if (lastSpaceIndex !== -1) {
    const truncatedAtSpace = text.slice(0, lastSpaceIndex).trim();
    if (truncatedAtSpace.length > 0) {
      return `${truncatedAtSpace}...`;
    }
  }
  const hardTruncated = text.slice(0, maxLength - 3).trim();
  return `${hardTruncated}...`;
}
async function splitChunks(content, chunkSize = 512, bleed = 20) {
  logger_default.debug("[splitChunks] Starting text split");
  const characterstoTokens = 3.5;
  const textSplitter = new RecursiveCharacterTextSplitter({
    chunkSize: Number(Math.floor(chunkSize * characterstoTokens)),
    chunkOverlap: Number(Math.floor(bleed * characterstoTokens))
  });
  const chunks = await textSplitter.splitText(content);
  logger_default.debug("[splitChunks] Split complete:", {
    numberOfChunks: chunks.length,
    averageChunkSize: chunks.reduce((acc, chunk) => acc + chunk.length, 0) / chunks.length
  });
  return chunks;
}
async function trimTokens(prompt, maxTokens, runtime) {
  if (!prompt) throw new Error("Trim tokens received a null prompt");
  if (prompt.length < maxTokens / 5) return prompt;
  if (maxTokens <= 0) throw new Error("maxTokens must be positive");
  const tokens = await runtime.useModel(ModelType2.TEXT_TOKENIZER_ENCODE, {
    prompt
  });
  if (tokens.length <= maxTokens) {
    return prompt;
  }
  const truncatedTokens = tokens.slice(-maxTokens);
  return await runtime.useModel(ModelType2.TEXT_TOKENIZER_DECODE, {
    tokens: truncatedTokens
  });
}
function safeReplacer() {
  const seen = /* @__PURE__ */ new WeakSet();
  return function(_key, value) {
    if (typeof value === "object" && value !== null) {
      if (seen.has(value)) {
        return "[Circular]";
      }
      seen.add(value);
    }
    return value;
  };
}
function parseBooleanFromText2(value) {
  if (!value) return false;
  const affirmative = ["YES", "Y", "TRUE", "T", "1", "ON", "ENABLE"];
  const negative = ["NO", "N", "FALSE", "F", "0", "OFF", "DISABLE"];
  const normalizedText = value.trim().toUpperCase();
  if (affirmative.includes(normalizedText)) {
    return true;
  }
  if (negative.includes(normalizedText)) {
    return false;
  }
  return false;
}
var uuidSchema = z.string().uuid();
function validateUuid(value) {
  const result = uuidSchema.safeParse(value);
  return result.success ? result.data : null;
}
function stringToUuid(target) {
  if (typeof target === "number") {
    target = target.toString();
  }
  if (typeof target !== "string") {
    throw TypeError("Value must be string");
  }
  const _uint8ToHex = (ubyte) => {
    const first = ubyte >> 4;
    const second = ubyte - (first << 4);
    const HEX_DIGITS = "0123456789abcdef".split("");
    return HEX_DIGITS[first] + HEX_DIGITS[second];
  };
  const _uint8ArrayToHex = (buf) => {
    let out = "";
    for (let i = 0; i < buf.length; i++) {
      out += _uint8ToHex(buf[i]);
    }
    return out;
  };
  const escapedStr = encodeURIComponent(target);
  const buffer = new Uint8Array(escapedStr.length);
  for (let i = 0; i < escapedStr.length; i++) {
    buffer[i] = escapedStr[i].charCodeAt(0);
  }
  const hash = sha1(buffer);
  const hashBuffer = new Uint8Array(hash.length / 2);
  for (let i = 0; i < hash.length; i += 2) {
    hashBuffer[i / 2] = Number.parseInt(hash.slice(i, i + 2), 16);
  }
  return `${_uint8ArrayToHex(hashBuffer.slice(0, 4))}-${_uint8ArrayToHex(hashBuffer.slice(4, 6))}-${_uint8ToHex(hashBuffer[6] & 15)}${_uint8ToHex(hashBuffer[7])}-${_uint8ToHex(hashBuffer[8] & 63 | 128)}${_uint8ToHex(hashBuffer[9])}-${_uint8ArrayToHex(hashBuffer.slice(10, 16))}`;
}
var getContentTypeFromMimeType = (mimeType) => {
  if (mimeType.startsWith("image/")) return "image" /* IMAGE */;
  if (mimeType.startsWith("video/")) return "video" /* VIDEO */;
  if (mimeType.startsWith("audio/")) return "audio" /* AUDIO */;
  if (mimeType.includes("pdf") || mimeType.includes("document") || mimeType.startsWith("text/")) {
    return "document" /* DOCUMENT */;
  }
  return void 0;
};
function getLocalServerUrl(path) {
  const port = process.env.SERVER_PORT || "3000";
  return `http://localhost:${port}${path}`;
}

// src/schemas/character.ts
import { z as z2 } from "zod";
var uuidSchema2 = z2.string().regex(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i, "Invalid UUID format");
var contentSchema = z2.object({
  text: z2.string().optional(),
  thought: z2.string().optional(),
  actions: z2.array(z2.string()).optional(),
  providers: z2.array(z2.string()).optional(),
  source: z2.string().optional(),
  target: z2.string().optional(),
  url: z2.string().optional(),
  inReplyTo: uuidSchema2.optional(),
  attachments: z2.array(z2.any()).optional(),
  channelType: z2.string().optional()
}).passthrough();
var messageExampleSchema = z2.object({
  name: z2.string(),
  content: contentSchema
});
var directoryItemSchema = z2.object({
  directory: z2.string(),
  shared: z2.boolean().optional()
});
var knowledgeItemSchema = z2.union([
  z2.string(),
  z2.object({
    path: z2.string(),
    shared: z2.boolean().optional()
  }),
  directoryItemSchema
]);
var templateTypeSchema = z2.union([
  z2.string(),
  z2.function().optional()
  // Functions won't be in JSON but allowed in runtime
]);
var styleSchema = z2.object({
  all: z2.array(z2.string()).optional(),
  chat: z2.array(z2.string()).optional(),
  post: z2.array(z2.string()).optional()
}).optional();
var settingsSchema = z2.record(z2.union([z2.string(), z2.boolean(), z2.number(), z2.any()])).optional();
var secretsSchema = z2.record(z2.union([z2.string(), z2.boolean(), z2.number()])).optional();
var characterSchema = z2.object({
  id: uuidSchema2.optional(),
  name: z2.string().min(1, "Character name is required"),
  username: z2.string().optional(),
  system: z2.string().optional(),
  templates: z2.record(templateTypeSchema).optional(),
  bio: z2.union([z2.string(), z2.array(z2.string())]),
  messageExamples: z2.array(z2.array(messageExampleSchema)).optional(),
  postExamples: z2.array(z2.string()).optional(),
  topics: z2.array(z2.string()).optional(),
  adjectives: z2.array(z2.string()).optional(),
  knowledge: z2.array(knowledgeItemSchema).optional(),
  plugins: z2.array(z2.string()).optional(),
  settings: settingsSchema,
  secrets: secretsSchema,
  style: styleSchema
}).strict();
function validateCharacter(data) {
  const result = characterSchema.safeParse(data);
  if (result.success) {
    return {
      success: true,
      data: result.data
    };
  }
  return {
    success: false,
    error: {
      message: `Character validation failed: ${result.error.message}`,
      issues: result.error.issues
    }
  };
}
function parseAndValidateCharacter(jsonString) {
  try {
    const parsed = JSON.parse(jsonString);
    return validateCharacter(parsed);
  } catch (error) {
    return {
      success: false,
      error: {
        message: `Invalid JSON: ${error instanceof Error ? error.message : "Unknown JSON parsing error"}`
      }
    };
  }
}
function isValidCharacter(data) {
  return validateCharacter(data).success;
}

// src/actions.ts
import { names as names2, uniqueNamesGenerator as uniqueNamesGenerator2 } from "unique-names-generator";
var composeActionExamples2 = (actionsData, count) => {
  if (!actionsData.length || count <= 0) {
    return "";
  }
  const actionsWithExamples = actionsData.filter(
    (action) => action.examples && Array.isArray(action.examples) && action.examples.length > 0
  );
  if (!actionsWithExamples.length) {
    return "";
  }
  const examplesCopy = actionsWithExamples.map((action) => [
    ...action.examples
  ]);
  const selectedExamples = [];
  let availableActionIndices = examplesCopy.map((examples, index) => examples.length > 0 ? index : -1).filter((index) => index !== -1);
  while (selectedExamples.length < count && availableActionIndices.length > 0) {
    const randomIndex = Math.floor(Math.random() * availableActionIndices.length);
    const actionIndex = availableActionIndices[randomIndex];
    const examples = examplesCopy[actionIndex];
    const exampleIndex = Math.floor(Math.random() * examples.length);
    selectedExamples.push(examples.splice(exampleIndex, 1)[0]);
    if (examples.length === 0) {
      availableActionIndices.splice(randomIndex, 1);
    }
  }
  return formatSelectedExamples(selectedExamples);
};
var formatSelectedExamples = (examples) => {
  const MAX_NAME_PLACEHOLDERS = 5;
  return examples.map((example) => {
    const randomNames = Array.from(
      { length: MAX_NAME_PLACEHOLDERS },
      () => uniqueNamesGenerator2({ dictionaries: [names2] })
    );
    const conversation = example.map((message) => {
      let messageText = `${message.name}: ${message.content.text}`;
      for (let i = 0; i < randomNames.length; i++) {
        messageText = messageText.replaceAll(`{{name${i + 1}}}`, randomNames[i]);
      }
      return messageText;
    }).join("\n");
    return `
${conversation}`;
  }).join("\n");
};
function formatActionNames2(actions) {
  if (!actions?.length) return "";
  return [...actions].sort(() => Math.random() - 0.5).map((action) => action.name).join(", ");
}
function formatActions2(actions) {
  if (!actions?.length) return "";
  return [...actions].sort(() => Math.random() - 0.5).map((action) => `${action.name}: ${action.description}`).join(",\n");
}

// src/database.ts
var DatabaseAdapter2 = class {
};

// src/prompts.ts
var shouldRespondTemplate = `<task>Decide on behalf of {{agentName}} whether they should respond to the message, ignore it or stop the conversation.</task>

<providers>
{{providers}}
</providers>

<instructions>Decide if {{agentName}} should respond to or interact with the conversation.
If the message is directed at or relevant to {{agentName}}, respond with RESPOND action.
If a user asks {{agentName}} to be quiet, respond with STOP action.
If {{agentName}} should ignore the message, respond with IGNORE action.</instructions>

<output>
Do NOT include any thinking, reasoning, or <think> sections in your response. 
Go directly to the XML response format without any preamble or explanation.

Respond using XML format like this:
<response>
  <name>{{agentName}}</name>
  <reasoning>Your reasoning here</reasoning>
  <action>RESPOND | IGNORE | STOP</action>
</response>

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.
</output>`;
var messageHandlerTemplate = `<task>Generate dialog and actions for the character {{agentName}}.</task>

<providers>
{{providers}}
</providers>

These are the available valid actions:
<actionNames>
{{actionNames}}
</actionNames>

<instructions>
Write a thought and plan for {{agentName}} and decide what actions to take. Also include the providers that {{agentName}} will use to have the right context for responding and acting, if any.

IMPORTANT ACTION ORDERING RULES:
- Actions are executed in the ORDER you list them - the order MATTERS!
- REPLY should come FIRST to acknowledge the user's request before executing other actions
- Common patterns:
  - For requests requiring tool use: REPLY,CALL_MCP_TOOL (acknowledge first, then gather info)
  - For task execution: REPLY,SEND_MESSAGE or REPLY,EVM_SWAP_TOKENS (acknowledge first, then do the task)
  - For multi-step operations: REPLY,ACTION1,ACTION2 (acknowledge first, then complete all steps)
- REPLY is used to acknowledge and inform the user about what you're going to do
- Follow-up actions execute the actual tasks after acknowledgment
- Use IGNORE only when you should not respond at all

IMPORTANT PROVIDER SELECTION RULES:
- If the message mentions images, photos, pictures, attachments, or visual content, OR if you see "(Attachments:" in the conversation, you MUST include "ATTACHMENTS" in your providers list
- If the message asks about or references specific people, include "ENTITIES" in your providers list  
- If the message asks about relationships or connections between people, include "RELATIONSHIPS" in your providers list
- If the message asks about facts or specific information, include "FACTS" in your providers list
- If the message asks about the environment or world context, include "WORLD" in your providers list
- If you need external knowledge, information, or context beyond the current conversation to provide a helpful response, include "KNOWLEDGE" in your providers list

First, think about what you want to do next and plan your actions. Then, write the next message and include the actions you plan to take.
</instructions>

<keys>
"thought" should be a short description of what the agent is thinking about and planning.
"actions" should be a comma-separated list of the actions {{agentName}} plans to take based on the thought, IN THE ORDER THEY SHOULD BE EXECUTED (if none, use IGNORE, if simply responding with text, use REPLY)
"providers" should be a comma-separated list of the providers that {{agentName}} will use to have the right context for responding and acting (NEVER use "IGNORE" as a provider - use specific provider names like ATTACHMENTS, ENTITIES, FACTS, KNOWLEDGE, etc.)
"text" should be the text of the next message for {{agentName}} which they will send to the conversation.
</keys>

<output>
Do NOT include any thinking, reasoning, or <think> sections in your response. 
Go directly to the XML response format without any preamble or explanation.

Respond using XML format like this:
<response>
    <thought>Your thought here</thought>
    <actions>ACTION1,ACTION2</actions>
    <providers>PROVIDER1,PROVIDER2</providers>
    <text>Your response text here</text>
</response>

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.
</output>`;
var postCreationTemplate = `# Task: Create a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.

Example task outputs:
1. A post about the importance of AI in our lives
<response>
  <thought>I am thinking about writing a post about the importance of AI in our lives</thought>
  <post>AI is changing the world and it is important to understand how it works</post>
  <imagePrompt>A futuristic cityscape with flying cars and people using AI to do things</imagePrompt>
</response>

2. A post about dogs
<response>
  <thought>I am thinking about writing a post about dogs</thought>
  <post>Dogs are man's best friend and they are loyal and loving</post>
  <imagePrompt>A dog playing with a ball in a park</imagePrompt>
</response>

3. A post about finding a new job
<response>
  <thought>Getting a job is hard, I bet there's a good tweet in that</thought>
  <post>Just keep going!</post>
  <imagePrompt>A person looking at a computer screen with a job search website</imagePrompt>
</response>

{{providers}}

Write a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.
Your response should be 1, 2, or 3 sentences (choose the length at random).
Your response should not contain any questions. Brief, concise statements only. The total character count MUST be less than 280. No emojis. Use \\n\\n (double spaces) between statements if there are multiple statements in your response.

Your output should be formatted in XML like this:
<response>
  <thought>Your thought here</thought>
  <post>Your post text here</post>
  <imagePrompt>Optional image prompt here</imagePrompt>
</response>

The "post" field should be the post you want to send. Do not including any thinking or internal reflection in the "post" field.
The "imagePrompt" field is optional and should be a prompt for an image that is relevant to the post. It should be a single sentence that captures the essence of the post. ONLY USE THIS FIELD if it makes sense that the post would benefit from an image.
The "thought" field should be a short description of what the agent is thinking about before responding, inlcuding a brief justification for the response. Includate an explanation how the post is relevant to the topic but unique and different than other posts.

Do NOT include any thinking, reasoning, or <think> sections in your response. 
Go directly to the XML response format without any preamble or explanation.

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.`;
var booleanFooter = "Respond with only a YES or a NO.";
var imageDescriptionTemplate = `<task>Analyze the provided image and generate a comprehensive description with multiple levels of detail.</task>

<instructions>
Carefully examine the image and provide:
1. A concise, descriptive title that captures the main subject or scene
2. A brief summary description (1-2 sentences) highlighting the key elements
3. An extensive, detailed description that covers all visible elements, composition, lighting, colors, mood, and any other relevant details

Be objective and descriptive. Focus on what you can actually see in the image rather than making assumptions about context or meaning.
</instructions>

<output>
Do NOT include any thinking, reasoning, or <think> sections in your response. 
Go directly to the XML response format without any preamble or explanation.

Respond using XML format like this:
<response>
  <title>A concise, descriptive title for the image</title>
  <description>A brief 1-2 sentence summary of the key elements in the image</description>
  <text>An extensive, detailed description covering all visible elements, composition, lighting, colors, mood, setting, objects, people, activities, and any other relevant details you can observe in the image</text>
</response>

IMPORTANT: Your response must ONLY contain the <response></response> XML block above. Do not include any text, thinking, or reasoning before or after this XML block. Start your response immediately with <response> and end with </response>.
</output>`;

// src/roles.ts
async function getUserServerRole(runtime, entityId, serverId) {
  const worldId = createUniqueUuid(runtime, serverId);
  const world = await runtime.getWorld(worldId);
  if (!world || !world.metadata?.roles) {
    return "NONE" /* NONE */;
  }
  if (world.metadata.roles[entityId]) {
    return world.metadata.roles[entityId];
  }
  if (world.metadata.roles[entityId]) {
    return world.metadata.roles[entityId];
  }
  return "NONE" /* NONE */;
}
async function findWorldsForOwner(runtime, entityId) {
  if (!entityId) {
    logger.error("User ID is required to find server");
    return null;
  }
  const worlds = await runtime.getAllWorlds();
  if (!worlds || worlds.length === 0) {
    logger.info("No worlds found for this agent");
    return null;
  }
  const ownerWorlds = [];
  for (const world of worlds) {
    if (world.metadata?.ownership?.ownerId === entityId) {
      ownerWorlds.push(world);
    }
  }
  return ownerWorlds.length ? ownerWorlds : null;
}

// src/runtime.ts
import { v4 as uuidv4 } from "uuid";

// src/search.ts
var isV = (char) => {
  switch (char) {
    case 97:
    case 101:
    case 105:
    case 111:
    case 117:
    case 121:
      return true;
    default:
      return false;
  }
};
var isWxy = (char) => {
  switch (char) {
    case 97:
    case 101:
    case 105:
    case 111:
    case 117:
    case 121:
    case 119:
    case 120:
    case 89:
      return true;
    default:
      return false;
  }
};
var isValidLi = (char) => {
  switch (char) {
    case 99:
    case 100:
    case 101:
    case 103:
    case 104:
    case 107:
    case 109:
    case 110:
    case 114:
    case 116:
      return true;
    default:
      return false;
  }
};
var isDouble = (char) => {
  switch (char) {
    case 98:
    case 100:
    case 102:
    case 103:
    case 109:
    case 110:
    case 112:
    case 114:
    case 116:
      return true;
    default:
      return false;
  }
};
var isShortV = (w, len) => {
  return len >= 2 && isV(w[len - 2]) && (len === 2 && !isV(w[len - 1]) || len >= 3 && !isV(w[len - 3]) && !isWxy(w[len - 1]));
};
var stem = (word) => {
  if (word.length < 3) return word;
  if (word.length <= 6) {
    switch (word) {
      case "ski":
        return "ski";
      case "skies":
        return "sky";
      case "dying":
        return "die";
      case "lying":
        return "lie";
      case "tying":
        return "tie";
      // special -LY cases
      case "idly":
        return "idl";
      case "gently":
        return "gentl";
      case "ugly":
        return "ugli";
      case "early":
        return "earli";
      case "only":
        return "onli";
      case "singly":
        return "singl";
      // invariant forms
      case "sky":
      case "news":
      case "howe":
      // not plural forms
      case "atlas":
      case "cosmos":
      case "bias":
      case "andes":
        return word;
    }
  }
  const initialOffset = word.charCodeAt(0) === 39 ? 1 : 0;
  let l = word.length - initialOffset;
  const w = new Array(l);
  let yFound = false;
  for (let i = 0; i < l; ++i) {
    const ch = word.charCodeAt(i + initialOffset);
    if (ch === 121 && (i === 0 || isV(w[i - 1]))) {
      yFound = true;
      w[i] = 89;
      continue;
    }
    w[i] = ch;
  }
  if (w[l - 1] === 39) --l;
  if (l >= 2 && w[l - 2] === 39 && w[l - 1] === 115) l -= 2;
  let rv = 0;
  while (rv < l && !isV(w[rv])) ++rv;
  if (rv < l) ++rv;
  let r1 = rv;
  if (l >= 5 && (w[0] === 103 && w[1] === 101 && w[2] === 110 && w[3] === 101 && w[4] === 114 || // gener
  w[0] === 97 && w[1] === 114 && w[2] === 115 && w[3] === 101 && w[4] === 110))
    r1 = 5;
  else if (l >= 6 && w[0] === 99 && // c
  w[1] === 111 && // o
  w[2] === 109 && // m
  w[3] === 109 && // m
  w[4] === 117 && // u
  w[5] === 110)
    r1 = 6;
  else {
    while (r1 < l && isV(w[r1])) ++r1;
    if (r1 < l) ++r1;
  }
  let r2 = r1;
  while (r2 < l && !isV(w[r2])) ++r2;
  while (r2 < l && isV(w[r2])) ++r2;
  if (r2 < l) ++r2;
  if (l >= 3) {
    if (w[l - 1] === 115) {
      if (l >= 4 && w[l - 2] === 101 && w[l - 3] === 115 && w[l - 4] === 115)
        l -= 2;
      else if (w[l - 2] === 101 && w[l - 3] === 105)
        l -= l >= 5 ? 2 : 1;
      else if (w[l - 2] !== 117 && w[l - 2] !== 115 && rv < l - 1)
        l -= 1;
    } else if (w[l - 1] === 100 && w[l - 2] === 101 && w[l - 3] === 105) l -= l >= 5 ? 2 : 1;
  }
  if (l === 6 && (w[0] === 105 && // i
  w[1] === 110 && // n
  w[2] === 110 && // n
  w[3] === 105 && // i
  w[4] === 110 && // n
  w[5] === 103 || // g (inning)
  w[0] === 111 && // o
  w[1] === 117 && // u
  w[2] === 116 && // t
  w[3] === 105 && // i
  w[4] === 110 && // n
  w[5] === 103 || // g (outing)
  w[0] === 101 && // e
  w[1] === 120 && // x
  w[2] === 99 && // c
  w[3] === 101 && // e
  w[4] === 101 && // e
  w[5] === 100) || // d (exceed)
  l === 7 && (w[0] === 99 && // c
  w[1] === 97 && // a
  w[2] === 110 && // n
  w[3] === 110 && // n
  w[4] === 105 && // i
  w[5] === 110 && // n
  w[6] === 103 || // g (canning)
  w[0] === 104 && // h
  w[1] === 101 && // e
  w[2] === 114 && // r
  w[3] === 114 && // r
  w[4] === 105 && // i
  w[5] === 110 && // n
  w[6] === 103 || // g (herring)
  w[0] === 101 && // e
  w[1] === 97 && // a
  w[2] === 114 && // r
  w[3] === 114 && // r
  w[4] === 105 && // i
  w[5] === 110 && // n
  w[6] === 103 || // g (earring)
  w[0] === 112 && // p
  w[1] === 114 && // r
  w[2] === 111 && // o
  w[3] === 99 && // c
  w[4] === 101 && // e
  w[5] === 101 && // e
  w[6] === 100 || // d (proceed)
  w[0] === 115 && // s
  w[1] === 117 && // u
  w[2] === 99 && // c
  w[3] === 99 && // c
  w[4] === 101 && // e
  w[5] === 101 && // e
  w[6] === 100)) {
    let exp2Out = "";
    for (let i = 0; i < l; ++i) exp2Out += String.fromCharCode(w[i]);
    return exp2Out;
  }
  let ll = (
    // l (length) without the -ly ending
    l >= 2 && w[l - 1] === 121 && w[l - 2] === 108 ? l - 2 : l
  );
  if (ll >= 3) {
    if (w[ll - 3] === 101 && w[ll - 2] === 101 && w[ll - 1] === 100) {
      if (ll >= r1 + 3) l = ll - 1;
    } else {
      if (w[ll - 2] === 101 && w[ll - 1] === 100)
        ll -= 2;
      else if (w[ll - 3] === 105 && w[ll - 2] === 110 && w[ll - 1] === 103)
        ll -= 3;
      else ll = -1;
      if (ll >= 0 && rv <= ll) {
        l = ll;
        if (l >= 2) {
          if (w[l - 1] === 116 && w[l - 2] === 97 || // at
          w[l - 1] === 108 && w[l - 2] === 98 || // bl
          w[l - 1] === 122 && w[l - 2] === 105) {
            w[l] = 101;
            ++l;
          } else if (w[l - 2] === w[l - 1] && isDouble(w[l - 1])) {
            --l;
          } else if (r1 >= l && isShortV(w, l)) {
            w[l] = 101;
            ++l;
          }
        }
      }
    }
  }
  if (l >= 3 && (w[l - 1] === 89 || w[l - 1] === 121) && !isV(w[l - 2])) w[l - 1] = 105;
  if (l >= r1 + 2) {
    switch (w[l - 1]) {
      case 108:
        if (l >= r1 + 6 && w[l - 2] === 97 && // a
        w[l - 3] === 110 && // n
        w[l - 4] === 111 && // o
        w[l - 5] === 105 && // i
        w[l - 6] === 116) {
          if (l >= 7 && w[l - 7] === 97) {
            if (l >= r1 + 7) {
              l -= 4;
              w[l - 1] = 101;
            }
          } else {
            l -= 2;
          }
        }
        break;
      case 110:
        if (l >= r1 + 5 && w[l - 2] === 111 && // o
        w[l - 3] === 105 && // i
        w[l - 4] === 116 && // t
        w[l - 5] === 97) {
          if (l >= 7 && w[l - 6] === 122 && w[l - 7] === 105) {
            if (l >= r1 + 7) {
              l -= 4;
              w[l - 1] = 101;
            }
          } else {
            l -= 2;
            w[l - 1] = 101;
          }
        }
        break;
      case 114:
        if (l >= r1 + 4) {
          if (w[l - 2] === 101) {
            if (w[l - 3] === 122 && w[l - 4] === 105) --l;
          } else if (w[l - 2] === 111) {
            if (w[l - 3] === 116 && w[l - 4] === 97) {
              --l;
              w[l - 1] = 101;
            }
          }
        }
        break;
      case 115:
        if (l >= r1 + 7 && w[l - 2] === 115 && // s
        w[l - 3] === 101 && // e
        w[l - 4] === 110 && // n (ness)
        (w[l - 5] === 108 && w[l - 6] === 117 && w[l - 7] === 102 || // fulness
        w[l - 5] === 115 && w[l - 6] === 117 && w[l - 7] === 111 || // ousness
        w[l - 5] === 101 && w[l - 6] === 118 && w[l - 7] === 105)) {
          l -= 4;
        }
        break;
      case 109:
        if (l >= r1 + 5 && w[l - 2] === 115 && // s
        w[l - 3] === 105 && // i
        w[l - 4] === 108 && // l
        w[l - 5] === 97)
          l -= 3;
        break;
      case 105:
        if (w[l - 2] === 99) {
          if (l >= r1 + 4 && (w[l - 4] === 101 || w[l - 4] === 97) && w[l - 3] === 110) {
            w[l - 1] = 101;
          }
        } else if (w[l - 2] === 103) {
          if (l >= r1 + 3 && l >= 4 && w[l - 2] === 103 && w[l - 3] === 111 && w[l - 4] === 108)
            --l;
        } else if (w[l - 2] === 116) {
          if (l >= r1 + 5 && w[l - 3] === 105) {
            if (w[l - 4] === 108) {
              if (l >= 6 && w[l - 5] === 105 && w[l - 6] === 98) {
                if (l >= r1 + 6) {
                  l -= 3;
                  w[l - 2] = 108;
                  w[l - 1] = 101;
                }
              } else if (w[l - 4] === 108 && w[l - 5] === 97) {
                l -= 3;
              }
            } else if (w[l - 4] === 118 && w[l - 5] === 105) {
              l -= 2;
              w[l - 1] = 101;
            }
          }
        } else if (w[l - 2] === 108 && l >= 3) {
          if (w[l - 3] === 98) {
            if (l >= 4 && w[l - 4] === 97) {
              if (l >= r1 + 4) w[l - 1] = 101;
            } else if (l >= r1 + 3) {
              w[l - 1] = 101;
            }
          } else {
            if (w[l - 3] === 108) {
              if (l >= 5 && w[l - 4] === 117 && w[l - 5] === 102) {
                if (l >= r1 + 5) l -= 2;
              } else if (l >= r1 + 4 && w[l - 4] === 97) {
                l -= 2;
              }
            } else if (w[l - 3] === 115) {
              if (l >= 6 && w[l - 4] === 115 && w[l - 5] === 101 && w[l - 6] === 108) {
                if (l >= r1 + 6) l -= 2;
              } else if (l >= r1 + 5 && w[l - 4] === 117 && w[l - 5] === 111) {
                l -= 2;
              }
            } else if (l >= 5 && w[l - 3] === 116 && w[l - 4] === 110 && w[l - 5] === 101) {
              if (l >= r1 + 5) l -= 2;
            } else if (isValidLi(w[l - 3])) {
              l -= 2;
            }
          }
        }
    }
  }
  if (l >= r1 + 3) {
    switch (w[l - 1]) {
      case 108:
        if (w[l - 3] === 99) {
          if (l >= r1 + 4 && w[l - 4] === 105 && w[l - 2] === 97) l -= 2;
        } else if (w[l - 3] === 102) {
          if (w[l - 2] === 117) l -= 3;
        } else if (w[l - 3] === 110) {
          if (l >= r1 + 6 && w[l - 2] === 97 && // a
          w[l - 4] === 111 && // o
          w[l - 5] === 105 && // i
          w[l - 6] === 116) {
            if (l >= 7 && w[l - 7] === 97) {
              if (l >= r1 + 7) {
                l -= 4;
                w[l - 1] = 101;
              }
            } else {
              l -= 2;
            }
          }
        }
        break;
      case 101:
        if (w[l - 2] === 122) {
          if (l >= r1 + 5 && w[l - 3] === 105 && w[l - 4] === 108 && w[l - 5] === 97) l -= 3;
        } else if (w[l - 2] === 116) {
          if (l >= r1 + 5 && w[l - 3] === 97 && w[l - 4] === 99 && w[l - 5] === 105) l -= 3;
        } else if (w[l - 2] === 118) {
          if (l >= r2 + 5 && w[l - 3] === 105 && w[l - 4] === 116 && w[l - 5] === 97) l -= 5;
        }
        break;
      case 105:
        if (l >= r1 + 5 && w[l - 2] === 116 && // t
        w[l - 3] === 105 && // i
        w[l - 4] === 99 && // c
        w[l - 5] === 105)
          l -= 3;
        break;
      case 115:
        if (l >= r1 + 4 && w[l - 2] === 115 && w[l - 3] === 101 && w[l - 4] === 110) l -= 4;
    }
  }
  if (l >= r2 + 2) {
    switch (w[l - 1]) {
      case 110:
        if (l >= r2 + 3 && w[l - 2] === 111 && // o
        w[l - 3] === 105 && // i (ion)
        (w[l - 4] === 115 || w[l - 4] === 116))
          l -= 3;
        break;
      case 108:
        if (w[l - 2] === 97) l -= 2;
        break;
      case 114:
        if (w[l - 2] === 101) l -= 2;
        break;
      case 99:
        if (w[l - 2] === 105) l -= 2;
        break;
      case 109:
        if (l >= r2 + 3 && w[l - 2] === 115 && w[l - 3] === 105) l -= 3;
        break;
      case 105:
        if (l >= r2 + 3 && w[l - 2] === 116 && w[l - 3] === 105) l -= 3;
        break;
      case 115:
        if (l >= r2 + 3 && w[l - 2] === 117 && w[l - 3] === 111) l -= 3;
        break;
      case 116:
        if (l >= r2 + 3 && w[l - 2] === 110) {
          if (w[l - 3] === 97) {
            l -= 3;
          } else if (w[l - 3] === 101) {
            if (l >= 4 && w[l - 4] === 109) {
              if (l >= 5 && w[l - 5] === 101) {
                if (l >= r2 + 5) l -= 5;
              } else if (l >= r2 + 4) {
                l -= 4;
              }
            } else {
              l -= 3;
            }
          }
        }
        break;
      case 101:
        if (w[l - 2] === 99) {
          if (l >= r2 + 4 && w[l - 3] === 110 && (w[l - 4] === 97 || w[l - 4] === 101)) l -= 4;
        } else if (w[l - 2] === 108) {
          if (l >= r2 + 4 && w[l - 3] === 98 && (w[l - 4] === 97 || w[l - 4] === 105)) l -= 4;
        } else if (w[l - 2] === 116) {
          if (l >= r2 + 3 && w[l - 3] === 97) l -= 3;
        } else if (l >= r2 + 3 && (w[l - 2] === 118 || w[l - 2] === 122) && w[l - 3] === 105) {
          l -= 3;
        }
    }
  }
  if (l >= r1 + 1 && // r1 is >= 1
  (l >= r2 + 1 && w[l - 1] === 108 && w[l - 2] === 108 || // ll
  w[l - 1] === 101 && (l >= r2 + 1 || !isShortV(w, l - 1))))
    --l;
  let out = "";
  if (yFound) {
    for (let i = 0; i < l; ++i) {
      out += String.fromCharCode(w[i] === 89 ? 121 : w[i]);
    }
  } else {
    for (let i = 0; i < l; ++i) out += String.fromCharCode(w[i]);
  }
  return out;
};
var DEFAULT_OPTIONS = {
  k1: 1.2,
  b: 0.75,
  minLength: 2,
  stopWords: /* @__PURE__ */ new Set([
    "a",
    "an",
    "and",
    "are",
    "as",
    "at",
    "be",
    "by",
    "for",
    "from",
    "has",
    "he",
    "in",
    "is",
    "it",
    "its",
    "of",
    "on",
    "that",
    "the",
    "to",
    "was",
    "were",
    "will",
    "with"
  ]),
  stemming: false,
  stemWords: (word) => word
};
var Tokenizer = class _Tokenizer {
  static {
    /** Default options for the Tokenizer. */
    this.DEFAULT_OPTIONS = {
      stopWords: /* @__PURE__ */ new Set(),
      minLength: 2,
      stemming: false,
      stemmingRules: []
    };
  }
  /**
   * Creates a new tokenizer instance.
   * @param options - Tokenization options including stop words, min length, stemming, and custom rules.
   */
  constructor(options2 = {}) {
    const mergedOptions = { ..._Tokenizer.DEFAULT_OPTIONS, ...options2 };
    this.stopWords = mergedOptions.stopWords;
    this.minLength = mergedOptions.minLength;
    this.stemming = mergedOptions.stemming;
    this.stemmingRules = mergedOptions.stemmingRules.map((rule) => ({
      ...rule,
      pattern: typeof rule.pattern === "string" ? new RegExp(rule.pattern) : rule.pattern
    }));
  }
  /**
   * Tokenizes input text into an array of processed terms.
   * Steps:
   * 1. Cleans the text (lowercase, normalize, remove punctuation/symbols).
   * 2. Splits the text into potential tokens.
   * 3. Filters tokens based on `minLength` and `stopWords`.
   * 4. Applies stemming if `stemming` is true (custom rules first, then Porter2).
   * 5. Optionally calculates statistics.
   *
   * @param text - The input text string to tokenize.
   * @param includeStats - If true, returns tokenization statistics along with tokens. Defaults to false.
   * @returns A `TokenizationResult` object containing the array of tokens and optional stats.
   * @throws {Error} If the input text is null, undefined, or empty.
   */
  tokenize(text, includeStats = false) {
    if (!text) {
      throw new Error("Input text cannot be null or empty");
    }
    const startTime = Date.now();
    const originalWords = text.split(/\s+/).filter((word) => word.length > 0);
    const cleaned = this.cleanText(text);
    const tokens = cleaned.split(/\s+/).filter((token) => this.isValidToken(token)).map((token) => this.stemming ? this.stemWord(token) : token);
    const stats = includeStats ? {
      originalWordCount: originalWords.length,
      stopWordsRemoved: originalWords.length - tokens.length,
      // This might be incorrect if stemming changes token count
      stemmedWords: this.stemming ? tokens.length : 0,
      processingTimeMs: Date.now() - startTime
    } : {
      originalWordCount: 0,
      stopWordsRemoved: 0,
      stemmedWords: 0,
      processingTimeMs: 0
    };
    return { tokens, stats };
  }
  /**
   * Cleans and normalizes text for tokenization.
   * - Converts to lowercase.
   * - Normalizes Unicode characters (NFKD).
   * - Removes control characters and zero-width spaces.
   * - Removes diacritical marks (accents).
   * - Removes emojis and pictographs.
   * - Removes common symbols (™, ®, ©, ℠, ‼).
   * - Replaces Unicode punctuation with spaces.
   * - Removes characters not matching basic Latin, CJK, Hangul, or whitespace.
   * - Collapses multiple spaces into single spaces.
   * - Trims leading/trailing whitespace.
   *
   * @param text - Input text to clean.
   * @returns Cleaned and normalized text, ready for splitting into tokens.
   *
   * @example
   * cleanText("Hello, World™!") // "hello world"
   * cleanText("héllo 👋") // "hello"
   * cleanText("Hello 世界!") // "hello 世界"
   * cleanText("I'm don't") // "i'm don't" (apostrophes kept by replacing punctuation with space)
   * cleanText("test©2023") // "test 2023"
   */
  cleanText(text) {
    return text.toLowerCase().normalize("NFKD").replace(/[\u0000-\u001F\u007F-\u009F\u200B-\u200D\uFEFF]/g, "").replace(/[\u0300-\u036f]/g, "").replace(/[\p{Emoji_Presentation}\p{Extended_Pictographic}]/gu, "").replace(/[™®©℠‼]/g, "").replace(/[\p{P}]/gu, " ").replace(/[^a-z0-9\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uAC00-\uD7AF\s]/gu, " ").replace(/\s+/g, " ").trim();
  }
  /**
   * Checks if a token is valid (meets `minLength` criteria and is not a stop word).
   * Numeric tokens are always considered valid regardless of length.
   * @param token - The token string to validate.
   * @returns `true` if the token is valid, `false` otherwise.
   */
  isValidToken(token) {
    const isNumeric = /^\d+$/.test(token);
    return (token.length >= this.minLength || isNumeric) && !this.stopWords.has(token);
  }
  /**
   * Applies stemming to a single word.
   * First, tries to apply custom stemming rules defined in `stemmingRules`.
   * If no custom rule matches, applies the default Porter2 stemming algorithm.
   * Words shorter than 3 characters are not stemmed.
   * @param word - The word to stem.
   * @returns The stemmed word.
   */
  stemWord(word) {
    if (word.length < 3) return word;
    let customRuleApplied = false;
    let stemmed = word;
    for (const rule of this.stemmingRules) {
      const match = stemmed.match(rule.pattern);
      if (match) {
        if (!rule.minMeasure || this.measure(stemmed.substring(0, match.index)) >= rule.minMeasure) {
          if (typeof rule.replacement === "string") {
            stemmed = stemmed.replace(rule.pattern, rule.replacement);
          } else {
            stemmed = stemmed.replace(
              rule.pattern,
              (...args) => rule.replacement(...args)
            );
          }
          customRuleApplied = true;
        }
      }
    }
    if (customRuleApplied && stemmed !== word) return stemmed;
    return stem(stemmed);
  }
  /**
   * Checks if the character at a given index in a word is a consonant.
   * Treats 'y' as a consonant if it's the first letter or follows a consonant.
   * @param word - The word string.
   * @param i - The index of the character to check.
   * @returns `true` if the character is a consonant, `false` otherwise.
   */
  isConsonant(word, i) {
    const char = word[i];
    if ("aeiou".includes(char)) return false;
    return char !== "y" || (i === 0 ? true : !this.isConsonant(word, i - 1));
  }
  /**
   * Calculates the "measure" of a word stem (approximates syllable count).
   * The measure (m) is the number of times a sequence of vowels is followed by a
   * sequence of consonants (VC). Used in some stemming rules.
   * Example: measure("tree") = 0, measure("trouble") = 1, measure("private") = 2
   * @param word - The word (or stem) to measure.
   * @returns The measure (m) of the word.
   */
  measure(word) {
    let m = 0;
    let vowelSeen = false;
    for (let i = 0; i < word.length; i++) {
      if (this.isConsonant(word, i)) {
        if (vowelSeen) {
          m++;
          vowelSeen = false;
        }
      } else {
        vowelSeen = true;
      }
    }
    return m;
  }
};
var BM25 = class {
  // Consider using a generic <T>
  /**
   * Creates a new BM25 search instance.
   * @param docs - Optional array of initial documents (objects with string fields) to index.
   * @param options - Configuration options for BM25 parameters (k1, b), tokenizer (stopWords, stemming, minLength), and field boosts.
   */
  constructor(docs, options2 = {}) {
    const opts = { ...DEFAULT_OPTIONS, ...options2 };
    this.termFrequencySaturation = opts.k1;
    this.lengthNormalizationFactor = opts.b;
    this.tokenizer = new Tokenizer(opts);
    this.fieldBoosts = opts.fieldBoosts || {};
    this.documents = [];
    this.documentLengths = new Uint32Array(0);
    this.termToIndex = /* @__PURE__ */ new Map();
    this.documentFrequency = new Uint32Array(0);
    this.averageDocLength = 0;
    this.termFrequencies = /* @__PURE__ */ new Map();
    if (docs && docs.length > 0) {
      this.documents = [...docs];
      const { documentLengths, termToIndex, documentFrequency, averageDocLength, termFrequencies } = this.processDocuments(docs);
      this.documentLengths = documentLengths;
      this.termToIndex = termToIndex;
      this.documentFrequency = documentFrequency;
      this.averageDocLength = averageDocLength;
      this.termFrequencies = termFrequencies;
    }
  }
  /**
   * Processes an array of documents to build the initial index structures.
   * Calculates document lengths, term frequencies, document frequencies, and average document length.
   * @param docs - Array of documents to process.
   * @returns An object containing the calculated index data.
   * @internal
   */
  processDocuments(docs) {
    const numDocs = docs.length;
    const documentLengths = new Uint32Array(numDocs);
    const termToIndex = /* @__PURE__ */ new Map();
    const termDocs = /* @__PURE__ */ new Map();
    const termFrequencies = /* @__PURE__ */ new Map();
    let totalDocLength = 0;
    let nextTermIndex = 0;
    docs.forEach((doc, docIndex) => {
      let currentDocLength = 0;
      const docTermFrequencies = /* @__PURE__ */ new Map();
      Object.entries(doc).forEach(([field, content]) => {
        if (typeof content !== "string") return;
        const fieldBoost = this.fieldBoosts[field] || 1;
        const { tokens } = this.tokenizer.tokenize(content);
        const fieldLength = tokens.length * fieldBoost;
        currentDocLength += fieldLength;
        tokens.forEach((term) => {
          if (!termToIndex.has(term)) {
            termToIndex.set(term, nextTermIndex++);
          }
          const termIndexVal = termToIndex.get(term);
          if (!termDocs.has(term)) {
            termDocs.set(term, /* @__PURE__ */ new Set());
          }
          termDocs.get(term).add(docIndex);
          const currentFreq = docTermFrequencies.get(termIndexVal) || 0;
          docTermFrequencies.set(termIndexVal, currentFreq + fieldBoost);
        });
      });
      documentLengths[docIndex] = currentDocLength;
      totalDocLength += currentDocLength;
      docTermFrequencies.forEach((freq, termIndexVal) => {
        if (!termFrequencies.has(termIndexVal)) {
          termFrequencies.set(termIndexVal, /* @__PURE__ */ new Map());
        }
        termFrequencies.get(termIndexVal).set(docIndex, freq);
      });
    });
    const documentFrequency = new Uint32Array(termToIndex.size);
    termDocs.forEach((docsSet, term) => {
      const termIndexVal = termToIndex.get(term);
      documentFrequency[termIndexVal] = docsSet.size;
    });
    return {
      documentLengths,
      termToIndex,
      documentFrequency,
      averageDocLength: numDocs > 0 ? totalDocLength / numDocs : 0,
      termFrequencies
    };
  }
  /**
   * Recalculates the average document length based on the current `documentLengths`.
   * @internal
   */
  recalculateAverageLength() {
    if (this.documentLengths.length === 0) {
      this.averageDocLength = 0;
      return;
    }
    const totalLength = Array.prototype.reduce.call(
      this.documentLengths,
      (sum, len) => sum + len,
      0
    );
    this.averageDocLength = totalLength / this.documentLengths.length;
  }
  /**
   * Searches the indexed documents for a given query string using the BM25 ranking formula.
   *
   * @param query - The search query text.
   * @param topK - The maximum number of top-scoring results to return. Defaults to 10.
   * @returns An array of `SearchResult` objects, sorted by descending BM25 score.
   */
  search(query, topK = 10) {
    const { tokens: queryTokens } = this.tokenizer.tokenize(query);
    const scores = new Float32Array(this.documentLengths.length).fill(0);
    queryTokens.forEach((term) => {
      const termIndex = this.termToIndex.get(term);
      if (termIndex === void 0) return;
      const idf = this.calculateIdf(termIndex);
      if (idf <= 0) return;
      const termFreqsInDocs = this.termFrequencies.get(termIndex);
      if (!termFreqsInDocs) return;
      termFreqsInDocs.forEach((tf, docIndex) => {
        const docLength = this.documentLengths[docIndex];
        const numerator = tf * (this.termFrequencySaturation + 1);
        const denominator = tf + this.termFrequencySaturation * (1 - this.lengthNormalizationFactor + this.lengthNormalizationFactor * docLength / this.averageDocLength);
        scores[docIndex] += idf * (numerator / denominator);
      });
    });
    return Array.from({ length: scores.length }, (_, i) => ({
      index: i,
      score: scores[i]
      // Optionally add: doc: this.getDocument(i) // If you want the full doc in results
    })).filter((result) => result.score > 0).sort((a, b) => b.score - a.score).slice(0, topK);
  }
  /**
   * Searches for an exact phrase within the indexed documents.
   * Ranks documents containing the exact sequence of tokens higher.
   * Note: This is a basic implementation. More sophisticated phrase search might consider proximity.
   *
   * @param phrase - The exact phrase to search for.
   * @param topK - The maximum number of results to return. Defaults to 10.
   * @returns An array of `SearchResult` objects, sorted by score, for documents containing the phrase.
   */
  searchPhrase(phrase, topK = 10) {
    const { tokens: phraseTokens } = this.tokenizer.tokenize(phrase);
    if (phraseTokens.length === 0) return [];
    let candidateDocs = null;
    for (const term of phraseTokens) {
      const termIndex = this.termToIndex.get(term);
      if (termIndex === void 0) return [];
      const docsContainingTermIter = this.termFrequencies.get(termIndex)?.keys();
      if (!docsContainingTermIter) return [];
      const currentTermDocs = new Set(docsContainingTermIter);
      if (candidateDocs === null) {
        candidateDocs = currentTermDocs;
      } else {
        candidateDocs = new Set([...candidateDocs].filter((docIdx) => currentTermDocs.has(docIdx)));
      }
      if (candidateDocs.size === 0) return [];
    }
    if (candidateDocs === null || candidateDocs.size === 0) return [];
    const scores = /* @__PURE__ */ new Map();
    candidateDocs.forEach((docIndex) => {
      const doc = this.getDocument(docIndex);
      let phraseFoundInDoc = false;
      Object.entries(doc).forEach(([field, content]) => {
        if (typeof content !== "string" || phraseFoundInDoc) return;
        const fieldBoost = this.fieldBoosts[field] || 1;
        const { tokens: docTokens } = this.tokenizer.tokenize(content);
        for (let i = 0; i <= docTokens.length - phraseTokens.length; i++) {
          let match = true;
          for (let j = 0; j < phraseTokens.length; j++) {
            if (docTokens[i + j] !== phraseTokens[j]) {
              match = false;
              break;
            }
          }
          if (match) {
            const phraseScoreVal = this.calculatePhraseScore(phraseTokens, docIndex) * fieldBoost;
            scores.set(docIndex, (scores.get(docIndex) || 0) + phraseScoreVal);
            phraseFoundInDoc = true;
            break;
          }
        }
      });
    });
    return Array.from(scores.entries()).map(([index, score]) => ({ index, score })).sort((a, b) => b.score - a.score).slice(0, topK);
  }
  /**
   * Calculates a BM25-like score for a sequence of phrase tokens within a specific document.
   * Sums the individual BM25 scores of the terms in the phrase for that document.
   * @param phraseTokens - The tokenized phrase.
   * @param docIndex - The index of the document to score against.
   * @returns The calculated phrase score for the document.
   * @internal
   */
  calculatePhraseScore(phraseTokens, docIndex) {
    return phraseTokens.reduce((currentScore, term) => {
      const termIndex = this.termToIndex.get(term);
      if (termIndex === void 0) return currentScore;
      const idf = this.calculateIdf(termIndex);
      const tf = this.termFrequencies.get(termIndex)?.get(docIndex) || 0;
      const docLength = this.documentLengths[docIndex];
      const numerator = tf * (this.termFrequencySaturation + 1);
      const denominator = tf + this.termFrequencySaturation * (1 - this.lengthNormalizationFactor + this.lengthNormalizationFactor * docLength / this.averageDocLength);
      return currentScore + idf * (numerator / denominator);
    }, 0);
  }
  /**
   * Adds a single new document to the index.
   * Updates all internal index structures incrementally.
   * Note: For adding many documents, `addDocumentsParallel` is generally more efficient.
   *
   * @param doc - The document object (with string fields) to add.
   * @throws {Error} If the document is null or undefined.
   */
  async addDocument(doc) {
    if (!doc) throw new Error("Document cannot be null");
    const docIndex = this.documentLengths.length;
    this.documents.push(doc);
    const newDocLengths = new Uint32Array(docIndex + 1);
    newDocLengths.set(this.documentLengths, 0);
    this.documentLengths = newDocLengths;
    let currentDocLength = 0;
    const docTermFrequencies = /* @__PURE__ */ new Map();
    Object.entries(doc).forEach(([field, content]) => {
      if (typeof content !== "string") return;
      const fieldBoost = this.fieldBoosts[field] || 1;
      const { tokens } = this.tokenizer.tokenize(content);
      currentDocLength += tokens.length * fieldBoost;
      tokens.forEach((term) => {
        let termIndexVal;
        if (!this.termToIndex.has(term)) {
          termIndexVal = this.termToIndex.size;
          this.termToIndex.set(term, termIndexVal);
          if (this.documentFrequency.length <= termIndexVal) {
            const oldDf = this.documentFrequency;
            const newSize = Math.max(termIndexVal + 1, oldDf.length * 2 || 1);
            this.documentFrequency = new Uint32Array(newSize);
            this.documentFrequency.set(oldDf, 0);
          }
          this.documentFrequency[termIndexVal] = 0;
        } else {
          termIndexVal = this.termToIndex.get(term);
        }
        const currentFreq = docTermFrequencies.get(termIndexVal) || 0;
        docTermFrequencies.set(termIndexVal, currentFreq + fieldBoost);
      });
    });
    this.documentLengths[docIndex] = currentDocLength;
    docTermFrequencies.forEach((freq, termIndexVal) => {
      if (!this.termFrequencies.has(termIndexVal)) {
        this.termFrequencies.set(termIndexVal, /* @__PURE__ */ new Map());
      }
      this.termFrequencies.get(termIndexVal).set(docIndex, freq);
      if (termIndexVal < this.documentFrequency.length) {
        this.documentFrequency[termIndexVal]++;
      } else {
        console.error(
          `Error: termIndexVal ${termIndexVal} is out of bounds for documentFrequency (length ${this.documentFrequency.length}). This indicates an issue with array resizing or term indexing.`
        );
      }
    });
    this.recalculateAverageLength();
  }
  /**
   * Calculates the Inverse Document Frequency (IDF) for a given term index.
   * Uses the BM25 IDF formula: log(1 + (N - n + 0.5) / (n + 0.5))
   * where N is the total number of documents and n is the number of documents
   * containing the term. The +1 smooths the logarithm.
   *
   * @param termIndex - The integer index of the term.
   * @returns The IDF score for the term. Returns 0 if the term is not found or has 0 DF.
   */
  calculateIdf(termIndex) {
    if (termIndex < 0 || termIndex >= this.documentFrequency.length) {
      return 0;
    }
    const docFreq = this.documentFrequency[termIndex];
    if (docFreq <= 0 || docFreq > this.documentLengths.length) {
      return 0;
    }
    const N = this.documentLengths.length;
    const numerator = N - docFreq + 0.5;
    const denominator = docFreq + 0.5;
    return Math.log(1 + numerator / denominator);
  }
  /**
   * Retrieves the term frequency (TF) for a specific term in a specific document.
   * @param termIndex - The integer index of the term.
   * @param docIndex - The index of the document.
   * @returns The term frequency, or 0 if the term is not in the document or indices are invalid.
   */
  getTermFrequency(termIndex, docIndex) {
    return this.termFrequencies.get(termIndex)?.get(docIndex) || 0;
  }
  /**
   * Retrieves the original document object stored at a given index.
   * @param index - The index of the document to retrieve.
   * @returns The document object.
   * @throws {Error} If the index is out of bounds.
   */
  getDocument(index) {
    if (index < 0 || index >= this.documents.length) {
      throw new Error(`Document index ${index} out of bounds (0-${this.documents.length - 1})`);
    }
    return this.documents[index];
  }
  /**
   * Clears all indexed documents and resets the BM25 instance to its initial state.
   */
  clearDocuments() {
    this.documents = [];
    this.documentLengths = new Uint32Array(0);
    this.termToIndex.clear();
    this.documentFrequency = new Uint32Array(0);
    this.averageDocLength = 0;
    this.termFrequencies.clear();
  }
  /**
   * Gets the total number of documents currently indexed.
   * @returns The document count.
   */
  getDocumentCount() {
    return this.documents.length;
  }
  /**
   * Adds multiple documents sequentially by calling `addDocument` for each.
   * This method processes documents sequentially in the main thread.
   * @param docs - An array of documents to add.
   */
  async addDocuments(docs) {
    return Promise.all(docs.map((doc) => this.addDocument(doc)));
  }
};

// src/runtime.ts
var environmentSettings = {};
var Semaphore = class {
  constructor(count) {
    this.waiting = [];
    this.permits = count;
  }
  async acquire() {
    if (this.permits > 0) {
      this.permits -= 1;
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      this.waiting.push(resolve);
    });
  }
  release() {
    this.permits += 1;
    const nextResolve = this.waiting.shift();
    if (nextResolve && this.permits > 0) {
      this.permits -= 1;
      nextResolve();
    }
  }
};
var AgentRuntime = class {
  constructor(opts) {
    this.#conversationLength = 32;
    this.actions = [];
    this.evaluators = [];
    this.providers = [];
    this.plugins = [];
    this.isInitialized = false;
    this.events = /* @__PURE__ */ new Map();
    this.stateCache = /* @__PURE__ */ new Map();
    this.fetch = fetch;
    this.services = /* @__PURE__ */ new Map();
    this.serviceTypes = /* @__PURE__ */ new Map();
    this.models = /* @__PURE__ */ new Map();
    this.routes = [];
    this.taskWorkers = /* @__PURE__ */ new Map();
    this.sendHandlers = /* @__PURE__ */ new Map();
    this.eventHandlers = /* @__PURE__ */ new Map();
    // A map of all plugins available to the runtime, keyed by name, for dependency resolution.
    this.allAvailablePlugins = /* @__PURE__ */ new Map();
    // The initial list of plugins specified by the character configuration.
    this.characterPlugins = [];
    this.servicesInitQueue = /* @__PURE__ */ new Set();
    this.agentId = opts.character?.id ?? opts?.agentId ?? stringToUuid(opts.character?.name ?? uuidv4() + opts.character?.username);
    this.character = opts.character;
    const logLevel = process.env.LOG_LEVEL || "info";
    this.logger = createLogger({
      agentName: this.character?.name,
      logLevel
    });
    this.#conversationLength = opts.conversationLength ?? this.#conversationLength;
    if (opts.adapter) {
      this.registerDatabaseAdapter(opts.adapter);
    }
    this.fetch = opts.fetch ?? this.fetch;
    this.settings = opts.settings ?? environmentSettings;
    this.plugins = [];
    this.characterPlugins = opts?.plugins ?? [];
    if (opts.allAvailablePlugins) {
      for (const plugin of opts.allAvailablePlugins) {
        if (plugin?.name) {
          this.allAvailablePlugins.set(plugin.name, plugin);
        }
      }
    }
    this.logger.debug(`Success: Agent ID: ${this.agentId}`);
    this.currentRunId = void 0;
  }
  #conversationLength;
  /**
   * Create a new run ID for tracking a sequence of model calls
   */
  createRunId() {
    return uuidv4();
  }
  /**
   * Start a new run for tracking prompts
   */
  startRun() {
    this.currentRunId = this.createRunId();
    return this.currentRunId;
  }
  /**
   * End the current run
   */
  endRun() {
    this.currentRunId = void 0;
  }
  /**
   * Get the current run ID (creates one if it doesn't exist)
   */
  getCurrentRunId() {
    if (!this.currentRunId) {
      this.currentRunId = this.createRunId();
    }
    return this.currentRunId;
  }
  async registerPlugin(plugin) {
    if (!plugin?.name) {
      const errorMsg = "Plugin or plugin name is undefined";
      this.logger.error(`*** registerPlugin: ${errorMsg}`);
      throw new Error(`*** registerPlugin: ${errorMsg}`);
    }
    const existingPlugin = this.plugins.find((p) => p.name === plugin.name);
    if (existingPlugin) {
      this.logger.warn(
        `${this.character.name}(${this.agentId}) - Plugin ${plugin.name} is already registered. Skipping re-registration.`
      );
      return;
    }
    this.plugins.push(plugin);
    this.logger.debug(
      `Success: Plugin ${plugin.name} added to active plugins for ${this.character.name}(${this.agentId}).`
    );
    if (plugin.init) {
      try {
        await plugin.init(plugin.config || {}, this);
        this.logger.debug(`Success: Plugin ${plugin.name} initialized successfully`);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage.includes("API key") || errorMessage.includes("environment variables") || errorMessage.includes("Invalid plugin configuration")) {
          console.warn(`Plugin ${plugin.name} requires configuration. ${errorMessage}`);
          console.warn(
            "Please check your environment variables and ensure all required API keys are set."
          );
          console.warn("You can set these in your .env file.");
        } else {
          throw error;
        }
      }
    }
    if (plugin.adapter) {
      this.logger.debug(`Registering database adapter for plugin ${plugin.name}`);
      this.registerDatabaseAdapter(plugin.adapter);
    }
    if (plugin.actions) {
      for (const action of plugin.actions) {
        this.registerAction(action);
      }
    }
    if (plugin.evaluators) {
      for (const evaluator of plugin.evaluators) {
        this.registerEvaluator(evaluator);
      }
    }
    if (plugin.providers) {
      for (const provider of plugin.providers) {
        this.registerProvider(provider);
      }
    }
    if (plugin.models) {
      for (const [modelType, handler] of Object.entries(plugin.models)) {
        this.registerModel(
          modelType,
          handler,
          plugin.name,
          plugin?.priority
        );
      }
    }
    if (plugin.routes) {
      for (const route of plugin.routes) {
        this.routes.push(route);
      }
    }
    if (plugin.events) {
      for (const [eventName, eventHandlers] of Object.entries(plugin.events)) {
        for (const eventHandler of eventHandlers) {
          this.registerEvent(eventName, eventHandler);
        }
      }
    }
    if (plugin.services) {
      for (const service of plugin.services) {
        if (this.isInitialized) {
          await this.registerService(service);
        } else {
          this.servicesInitQueue.add(service);
        }
      }
    }
  }
  getAllServices() {
    return this.services;
  }
  async stop() {
    this.logger.debug(`runtime::stop - character ${this.character.name}`);
    for (const [serviceName, service] of this.services) {
      this.logger.debug(`runtime::stop - requesting service stop for ${serviceName}`);
      await service.stop();
    }
  }
  async initialize() {
    if (this.isInitialized) {
      this.logger.warn("Agent already initialized");
      return;
    }
    const pluginRegistrationPromises = [];
    const pluginsToLoad = this.characterPlugins;
    for (const plugin of pluginsToLoad) {
      if (plugin) {
        pluginRegistrationPromises.push(this.registerPlugin(plugin));
      }
    }
    await Promise.all(pluginRegistrationPromises);
    if (!this.adapter) {
      this.logger.error(
        "Database adapter not initialized. Make sure @elizaos/plugin-sql is included in your plugins."
      );
      throw new Error(
        "Database adapter not initialized. The SQL plugin (@elizaos/plugin-sql) is required for agent initialization. Please ensure it is included in your character configuration."
      );
    }
    try {
      await this.adapter.init();
      this.logger.info("Running plugin migrations...");
      await this.runPluginMigrations();
      this.logger.info("Plugin migrations completed.");
      const existingAgent = await this.ensureAgentExists(this.character);
      if (!existingAgent) {
        const errorMsg = `Agent ${this.character.name} does not exist in database after ensureAgentExists call`;
        throw new Error(errorMsg);
      }
      let agentEntity = await this.getEntityById(this.agentId);
      if (!agentEntity) {
        const created = await this.createEntity({
          id: this.agentId,
          names: [this.character.name],
          metadata: {},
          agentId: existingAgent.id
        });
        if (!created) {
          const errorMsg = `Failed to create entity for agent ${this.agentId}`;
          throw new Error(errorMsg);
        }
        agentEntity = await this.getEntityById(this.agentId);
        if (!agentEntity) throw new Error(`Agent entity not found for ${this.agentId}`);
        this.logger.debug(`Success: Agent entity created successfully for ${this.character.name}`);
      }
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      this.logger.error(`Failed to create agent entity: ${errorMsg}`);
      throw error;
    }
    try {
      const room = await this.getRoom(this.agentId);
      if (!room) {
        await this.createRoom({
          id: this.agentId,
          name: this.character.name,
          source: "elizaos",
          type: "SELF" /* SELF */,
          channelId: this.agentId,
          serverId: this.agentId,
          worldId: this.agentId
        });
      }
      const participants = await this.adapter.getParticipantsForRoom(this.agentId);
      if (!participants.includes(this.agentId)) {
        const added = await this.addParticipant(this.agentId, this.agentId);
        if (!added) {
          const errorMsg = `Failed to add agent ${this.agentId} as participant to its own room`;
          throw new Error(errorMsg);
        }
        this.logger.debug(`Agent ${this.character.name} linked to its own room successfully`);
      }
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      this.logger.error(`Failed to add agent as participant: ${errorMsg}`);
      throw error;
    }
    const embeddingModel = this.getModel(ModelType2.TEXT_EMBEDDING);
    if (!embeddingModel) {
      this.logger.warn(
        `[AgentRuntime][${this.character.name}] No TEXT_EMBEDDING model registered. Skipping embedding dimension setup.`
      );
    } else {
      await this.ensureEmbeddingDimension();
    }
    for (const service of this.servicesInitQueue) {
      await this.registerService(service);
    }
    this.isInitialized = true;
  }
  async runPluginMigrations() {
    const drizzle = this.adapter?.db;
    if (!drizzle) {
      this.logger.warn("Drizzle instance not found on adapter, skipping plugin migrations.");
      return;
    }
    const pluginsWithSchemas = this.plugins.filter((p) => p.schema);
    this.logger.info(`Found ${pluginsWithSchemas.length} plugins with schemas to migrate.`);
    for (const p of pluginsWithSchemas) {
      if (p.schema) {
        this.logger.info(`Running migrations for plugin: ${p.name}`);
        try {
          if (this.adapter && "runMigrations" in this.adapter) {
            await this.adapter.runMigrations(p.schema, p.name);
            this.logger.info(`Successfully migrated plugin: ${p.name}`);
          }
        } catch (error) {
          this.logger.error(`Failed to migrate plugin ${p.name}:`, error);
        }
      }
    }
  }
  async getConnection() {
    if (!this.adapter) {
      throw new Error("Database adapter not registered");
    }
    return this.adapter.getConnection();
  }
  setSetting(key, value, secret = false) {
    if (secret) {
      if (!this.character.secrets) {
        this.character.secrets = {};
      }
      this.character.secrets[key] = value;
    } else {
      if (!this.character.settings) {
        this.character.settings = {};
      }
      this.character.settings[key] = value;
    }
  }
  getSetting(key) {
    const value = this.character.secrets?.[key] || this.character.settings?.[key] || this.character.settings?.secrets?.[key] || this.settings[key];
    const decryptedValue = decryptStringValue(value, getSalt());
    if (decryptedValue === "true") return true;
    if (decryptedValue === "false") return false;
    return decryptedValue || null;
  }
  getConversationLength() {
    return this.#conversationLength;
  }
  registerDatabaseAdapter(adapter) {
    if (this.adapter) {
      this.logger.warn(
        "Database adapter already registered. Additional adapters will be ignored. This may lead to unexpected behavior."
      );
    } else {
      this.adapter = adapter;
      this.logger.debug("Success: Database adapter registered successfully.");
    }
  }
  registerProvider(provider) {
    this.providers.push(provider);
    this.logger.debug(`Success: Provider ${provider.name} registered successfully.`);
  }
  registerAction(action) {
    this.logger.debug(
      `${this.character.name}(${this.agentId}) - Registering action: ${action.name}`
    );
    if (this.actions.find((a) => a.name === action.name)) {
      this.logger.warn(
        `${this.character.name}(${this.agentId}) - Action ${action.name} already exists. Skipping registration.`
      );
    } else {
      this.actions.push(action);
      this.logger.debug(
        `${this.character.name}(${this.agentId}) - Action ${action.name} registered successfully.`
      );
    }
  }
  registerEvaluator(evaluator) {
    this.evaluators.push(evaluator);
  }
  async processActions(message, responses, state, callback) {
    for (const response of responses) {
      let normalizeAction = function(actionString) {
        return actionString.toLowerCase().replace("_", "");
      };
      if (!response.content?.actions || response.content.actions.length === 0) {
        this.logger.warn("No action found in the response content.");
        continue;
      }
      const actions = response.content.actions;
      this.logger.debug(`Found actions: ${this.actions.map((a) => normalizeAction(a.name))}`);
      for (const responseAction of actions) {
        state = await this.composeState(message, ["RECENT_MESSAGES"]);
        this.logger.debug(`Success: Calling action: ${responseAction}`);
        const normalizedResponseAction = normalizeAction(responseAction);
        let action = this.actions.find(
          (a) => normalizeAction(a.name) === normalizedResponseAction
        );
        if (!action) {
          action = this.actions.find(
            (a) => normalizeAction(a.name).includes(normalizedResponseAction) || normalizedResponseAction.includes(normalizeAction(a.name))
          );
        }
        if (action) {
          this.logger.debug(`Success: Found action: ${action?.name}`);
        } else {
          this.logger.debug("Attempting to find action in similes.");
          for (const _action of this.actions) {
            const simileAction = _action.similes?.find(
              (simile) => simile.toLowerCase().replace("_", "").includes(normalizedResponseAction) || normalizedResponseAction.includes(simile.toLowerCase().replace("_", ""))
            );
            if (simileAction) {
              action = _action;
              this.logger.debug(`Success: Action found in similes: ${action.name}`);
              break;
            }
          }
        }
        if (!action) {
          const errorMsg = `No action found for: ${responseAction}`;
          this.logger.error(errorMsg);
          const actionMemory = {
            id: uuidv4(),
            entityId: message.entityId,
            roomId: message.roomId,
            worldId: message.worldId,
            content: {
              thought: errorMsg,
              source: "auto"
            }
          };
          await this.createMemory(actionMemory, "messages");
          continue;
        }
        if (!action.handler) {
          this.logger.error(`Action ${action.name} has no handler.`);
          continue;
        }
        try {
          this.logger.debug(`Executing handler for action: ${action.name}`);
          const actionId = uuidv4();
          this.currentActionContext = {
            actionName: action.name,
            actionId,
            prompts: []
          };
          await action.handler(this, message, state, {}, callback, responses);
          this.logger.debug(`Success: Action ${action.name} executed successfully.`);
          this.adapter.log({
            entityId: message.entityId,
            roomId: message.roomId,
            type: "action",
            body: {
              action: action.name,
              actionId,
              message: message.content.text,
              messageId: message.id,
              state,
              responses,
              prompts: this.currentActionContext?.prompts || [],
              promptCount: this.currentActionContext?.prompts.length || 0
            }
          });
          this.currentActionContext = void 0;
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          this.logger.error(error);
          this.currentActionContext = void 0;
          const actionMemory = {
            id: uuidv4(),
            content: {
              thought: errorMessage,
              source: "auto"
            },
            entityId: message.entityId,
            roomId: message.roomId,
            worldId: message.worldId
          };
          await this.createMemory(actionMemory, "messages");
          throw error;
        }
      }
    }
  }
  async evaluate(message, state, didRespond, callback, responses) {
    const evaluatorPromises = this.evaluators.map(async (evaluator) => {
      if (!evaluator.handler) {
        return null;
      }
      if (!didRespond && !evaluator.alwaysRun) {
        return null;
      }
      const result = await evaluator.validate(this, message, state);
      if (result) {
        return evaluator;
      }
      return null;
    });
    const evaluators = (await Promise.all(evaluatorPromises)).filter(Boolean);
    if (evaluators.length === 0) {
      return [];
    }
    state = await this.composeState(message, ["RECENT_MESSAGES", "EVALUATORS"]);
    await Promise.all(
      evaluators.map(async (evaluator) => {
        if (evaluator.handler) {
          await evaluator.handler(this, message, state, {}, callback, responses);
          this.adapter.log({
            entityId: message.entityId,
            roomId: message.roomId,
            type: "evaluator",
            body: {
              evaluator: evaluator.name,
              messageId: message.id,
              message: message.content.text,
              state
            }
          });
        }
      })
    );
    return evaluators;
  }
  // highly SQL optimized queries
  async ensureConnections(entities, rooms, source, world) {
    if (!entities) {
      console.trace();
      this.logger.error("ensureConnections - no entities");
      return;
    }
    if (!rooms || rooms.length === 0) {
      console.trace();
      this.logger.error("ensureConnections - no rooms");
      return;
    }
    await this.ensureWorldExists({ ...world, agentId: this.agentId });
    const firstRoom = rooms[0];
    const chunkArray = (arr, size) => arr.reduce((chunks, item, i) => {
      if (i % size === 0) chunks.push([]);
      chunks[chunks.length - 1].push(item);
      return chunks;
    }, []);
    const roomIds = rooms.map((r2) => r2.id);
    const roomExistsCheck = await this.getRoomsByIds(roomIds);
    const roomsIdExists = roomExistsCheck.map((r2) => r2.id);
    const roomsToCreate = roomIds.filter((id) => !roomsIdExists.includes(id));
    const rf = {
      worldId: world.id,
      serverId: world.serverId,
      source,
      agentId: this.agentId
    };
    if (roomsToCreate.length) {
      this.logger.debug(
        "runtime/ensureConnections - create",
        roomsToCreate.length.toLocaleString(),
        "rooms"
      );
      const roomObjsToCreate = rooms.filter((r2) => roomsToCreate.includes(r2.id)).map((r2) => ({ ...r2, ...rf }));
      await this.createRooms(roomObjsToCreate);
    }
    const entityIds = entities.map((e) => e.id);
    const entityExistsCheck = await this.adapter.getEntityByIds(entityIds);
    const entitiesToUpdate = entityExistsCheck.map((e) => e.id);
    const entitiesToCreate = entities.filter((e) => !entitiesToUpdate.includes(e.id));
    const r = {
      roomId: firstRoom.id,
      channelId: firstRoom.channelId,
      type: firstRoom.type
    };
    const wf = {
      worldId: world.id,
      serverId: world.serverId
    };
    if (entitiesToCreate.length) {
      this.logger.debug(
        "runtime/ensureConnections - creating",
        entitiesToCreate.length.toLocaleString(),
        "entities..."
      );
      const ef = {
        ...r,
        ...wf,
        source,
        agentId: this.agentId
      };
      const entitiesToCreateWFields = entitiesToCreate.map((e) => ({ ...e, ...ef }));
      const batches = chunkArray(entitiesToCreateWFields, 5e3);
      for (const batch of batches) {
        await this.createEntities(batch);
      }
    }
    await this.ensureParticipantInRoom(this.agentId, firstRoom.id);
    const entityIdsInFirstRoom = await this.getParticipantsForRoom(firstRoom.id);
    const entityIdsInFirstRoomFiltered = entityIdsInFirstRoom.filter(Boolean);
    const missingIdsInRoom = entityIds.filter((id) => !entityIdsInFirstRoomFiltered.includes(id));
    if (missingIdsInRoom.length) {
      this.logger.debug(
        "runtime/ensureConnections - Missing",
        missingIdsInRoom.length.toLocaleString(),
        "connections in",
        firstRoom.id
      );
      await this.addParticipantsRoom(missingIdsInRoom, firstRoom.id);
    }
    this.logger.success(`Success: Successfully connected world`);
  }
  async ensureConnection({
    entityId,
    roomId,
    worldId,
    worldName,
    userName,
    name,
    source,
    type,
    channelId,
    serverId,
    userId,
    metadata
  }) {
    if (!worldId && serverId) {
      worldId = createUniqueUuid(this.agentId + serverId, serverId);
    }
    const names3 = [name, userName].filter(Boolean);
    const entityMetadata = {
      [source]: {
        id: userId,
        name,
        userName
      }
    };
    try {
      const entity = await this.getEntityById(entityId);
      if (!entity) {
        try {
          const success = await this.createEntity({
            id: entityId,
            names: names3,
            metadata: entityMetadata,
            agentId: this.agentId
          });
          if (success) {
            this.logger.debug(
              `Created new entity ${entityId} for user ${name || userName || "unknown"}`
            );
          } else {
            throw new Error(`Failed to create entity ${entityId}`);
          }
        } catch (error) {
          if (error.message?.includes("duplicate key") || error.code === "23505") {
            this.logger.debug(
              `Entity ${entityId} exists in database but not for this agent. This is normal in multi-agent setups.`
            );
          } else {
            throw error;
          }
        }
      } else {
        await this.adapter.updateEntity({
          id: entityId,
          names: [.../* @__PURE__ */ new Set([...entity.names || [], ...names3])].filter(Boolean),
          metadata: {
            ...entity.metadata,
            [source]: {
              ...entity.metadata?.[source],
              id: userId,
              name,
              userName
            }
          },
          agentId: this.agentId
        });
      }
      await this.ensureWorldExists({
        id: worldId,
        name: worldName || serverId ? `World for server ${serverId}` : `World for room ${roomId}`,
        agentId: this.agentId,
        serverId: serverId || "default",
        metadata
      });
      await this.ensureRoomExists({
        id: roomId,
        name,
        source,
        type,
        channelId,
        serverId,
        worldId
      });
      try {
        await this.ensureParticipantInRoom(entityId, roomId);
      } catch (error) {
        if (error.message?.includes("not found")) {
          const added = await this.addParticipant(entityId, roomId);
          if (!added) {
            throw new Error(`Failed to add participant ${entityId} to room ${roomId}`);
          }
          this.logger.debug(`Added participant ${entityId} to room ${roomId} directly`);
        } else {
          throw error;
        }
      }
      await this.ensureParticipantInRoom(this.agentId, roomId);
      this.logger.debug(`Success: Successfully connected entity ${entityId} in room ${roomId}`);
    } catch (error) {
      this.logger.error(
        `Failed to ensure connection: ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
  }
  async ensureParticipantInRoom(entityId, roomId) {
    const entity = await this.getEntityById(entityId);
    if (!entity && entityId !== this.agentId) {
      this.logger.warn(
        `Entity ${entityId} not directly accessible to agent ${this.agentId}. Will attempt to add as participant anyway.`
      );
    } else if (!entity && entityId === this.agentId) {
      throw new Error(`Agent entity ${entityId} not found, cannot add as participant.`);
    } else if (!entity) {
      throw new Error(`User entity ${entityId} not found, cannot add as participant.`);
    }
    const participants = await this.adapter.getParticipantsForRoom(roomId);
    if (!participants.includes(entityId)) {
      const added = await this.addParticipant(entityId, roomId);
      if (!added) {
        throw new Error(`Failed to add participant ${entityId} to room ${roomId}`);
      }
      if (entityId === this.agentId) {
        this.logger.debug(`Agent ${this.character.name} linked to room ${roomId} successfully.`);
      } else {
        this.logger.debug(`User ${entityId} linked to room ${roomId} successfully.`);
      }
    }
  }
  async removeParticipant(entityId, roomId) {
    return await this.adapter.removeParticipant(entityId, roomId);
  }
  async getParticipantsForEntity(entityId) {
    return await this.adapter.getParticipantsForEntity(entityId);
  }
  async getParticipantsForRoom(roomId) {
    return await this.adapter.getParticipantsForRoom(roomId);
  }
  async addParticipant(entityId, roomId) {
    return await this.adapter.addParticipantsRoom([entityId], roomId);
  }
  async addParticipantsRoom(entityIds, roomId) {
    return await this.adapter.addParticipantsRoom(entityIds, roomId);
  }
  /**
   * Ensure the existence of a world.
   */
  async ensureWorldExists({ id, name, serverId, metadata }) {
    const world = await this.getWorld(id);
    if (!world) {
      this.logger.debug("Creating world:", {
        id,
        name,
        serverId,
        agentId: this.agentId
      });
      await this.adapter.createWorld({
        id,
        name,
        agentId: this.agentId,
        serverId: serverId || "default",
        metadata
      });
      this.logger.debug(`World ${id} created successfully.`);
    }
  }
  async ensureRoomExists({ id, name, source, type, channelId, serverId, worldId, metadata }) {
    if (!worldId) throw new Error("worldId is required");
    const room = await this.getRoom(id);
    if (!room) {
      await this.createRoom({
        id,
        name,
        agentId: this.agentId,
        source,
        type,
        channelId,
        serverId,
        worldId,
        metadata
      });
      this.logger.debug(`Room ${id} created successfully.`);
    }
  }
  async composeState(message, includeList = null, onlyInclude = false, skipCache = false) {
    const filterList = onlyInclude ? includeList : null;
    const emptyObj = {
      values: {},
      data: {},
      text: ""
    };
    const cachedState = skipCache ? emptyObj : await this.stateCache.get(message.id) || emptyObj;
    const providerNames = /* @__PURE__ */ new Set();
    if (filterList && filterList.length > 0) {
      filterList.forEach((name) => providerNames.add(name));
    } else {
      this.providers.filter((p) => !p.private && !p.dynamic).forEach((p) => providerNames.add(p.name));
    }
    if (!filterList && includeList && includeList.length > 0) {
      includeList.forEach((name) => providerNames.add(name));
    }
    const providersToGet = Array.from(
      new Set(this.providers.filter((p) => providerNames.has(p.name)))
    ).sort((a, b) => (a.position || 0) - (b.position || 0));
    const providerData = await Promise.all(
      providersToGet.map(async (provider) => {
        const start = Date.now();
        try {
          const result = await provider.get(this, message, cachedState);
          const duration = Date.now() - start;
          this.logger.debug(`${provider.name} Provider took ${duration}ms to respond`);
          return {
            ...result,
            providerName: provider.name
          };
        } catch (error) {
          console.error("provider error", provider.name, error);
          return { values: {}, text: "", data: {}, providerName: provider.name };
        }
      })
    );
    const currentProviderResults = { ...cachedState.data?.providers || {} };
    for (const freshResult of providerData) {
      currentProviderResults[freshResult.providerName] = freshResult;
    }
    const orderedTexts = [];
    for (const provider of providersToGet) {
      const result = currentProviderResults[provider.name];
      if (result && result.text && result.text.trim() !== "") {
        orderedTexts.push(result.text);
      }
    }
    const providersText = orderedTexts.join("\n");
    const aggregatedStateValues = { ...cachedState.values || {} };
    for (const provider of providersToGet) {
      const providerResult = currentProviderResults[provider.name];
      if (providerResult && providerResult.values && typeof providerResult.values === "object") {
        Object.assign(aggregatedStateValues, providerResult.values);
      }
    }
    for (const providerName in currentProviderResults) {
      if (!providersToGet.some((p) => p.name === providerName)) {
        const providerResult = currentProviderResults[providerName];
        if (providerResult && providerResult.values && typeof providerResult.values === "object") {
          Object.assign(aggregatedStateValues, providerResult.values);
        }
      }
    }
    const newState = {
      values: {
        ...aggregatedStateValues,
        providers: providersText
      },
      data: {
        ...cachedState.data || {},
        providers: currentProviderResults
      },
      text: providersText
    };
    this.stateCache.set(message.id, newState);
    return newState;
  }
  getService(serviceName) {
    const serviceInstance = this.services.get(serviceName);
    if (!serviceInstance) {
      this.logger.debug(`Service ${serviceName} not found`);
      return null;
    }
    return serviceInstance;
  }
  /**
   * Type-safe service getter that ensures the correct service type is returned
   * @template T - The expected service class type
   * @param serviceName - The service type name
   * @returns The service instance with proper typing, or null if not found
   */
  getTypedService(serviceName) {
    return this.getService(serviceName);
  }
  /**
   * Get all registered service types
   * @returns Array of registered service type names
   */
  getRegisteredServiceTypes() {
    return Array.from(this.services.keys());
  }
  /**
   * Check if a service type is registered
   * @param serviceType - The service type to check
   * @returns true if the service is registered
   */
  hasService(serviceType) {
    return this.services.has(serviceType);
  }
  async registerService(serviceDef) {
    const serviceType = serviceDef.serviceType;
    if (!serviceType) {
      this.logger.warn(
        `Service ${serviceDef.name} is missing serviceType. Please define a static serviceType property.`
      );
      return;
    }
    this.logger.debug(
      `${this.character.name}(${this.agentId}) - Registering service:`,
      serviceType
    );
    if (this.services.has(serviceType)) {
      this.logger.warn(
        `${this.character.name}(${this.agentId}) - Service ${serviceType} is already registered. Skipping registration.`
      );
      return;
    }
    try {
      const serviceInstance = await serviceDef.start(this);
      this.services.set(serviceType, serviceInstance);
      this.serviceTypes.set(serviceType, serviceDef);
      if (typeof serviceDef.registerSendHandlers === "function") {
        serviceDef.registerSendHandlers(this, serviceInstance);
      }
      this.logger.debug(
        `${this.character.name}(${this.agentId}) - Service ${serviceType} registered successfully`
      );
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger.error(
        `${this.character.name}(${this.agentId}) - Failed to register service ${serviceType}: ${errorMessage}`
      );
      throw error;
    }
  }
  registerModel(modelType, handler, provider, priority) {
    const modelKey = typeof modelType === "string" ? modelType : ModelType2[modelType];
    if (!this.models.has(modelKey)) {
      this.models.set(modelKey, []);
    }
    const registrationOrder = Date.now();
    this.models.get(modelKey)?.push({
      handler,
      provider,
      priority: priority || 0,
      registrationOrder
    });
    this.models.get(modelKey)?.sort((a, b) => {
      if ((b.priority || 0) !== (a.priority || 0)) {
        return (b.priority || 0) - (a.priority || 0);
      }
      return a.registrationOrder - b.registrationOrder;
    });
  }
  getModel(modelType, provider) {
    const modelKey = typeof modelType === "string" ? modelType : ModelType2[modelType];
    const models = this.models.get(modelKey);
    if (!models?.length) {
      return void 0;
    }
    if (provider) {
      const modelWithProvider = models.find((m) => m.provider === provider);
      if (modelWithProvider) {
        this.logger.debug(
          `[AgentRuntime][${this.character.name}] Using model ${modelKey} from provider ${provider}`
        );
        return modelWithProvider.handler;
      } else {
        this.logger.warn(
          `[AgentRuntime][${this.character.name}] No model found for provider ${provider}`
        );
      }
    }
    this.logger.debug(
      `[AgentRuntime][${this.character.name}] Using model ${modelKey} from provider ${models[0].provider}`
    );
    return models[0].handler;
  }
  async useModel(modelType, params, provider) {
    const modelKey = typeof modelType === "string" ? modelType : ModelType2[modelType];
    const promptContent = params?.prompt || params?.input || (Array.isArray(params?.messages) ? JSON.stringify(params.messages) : null);
    const model = this.getModel(modelKey, provider);
    if (!model) {
      const errorMsg = `No handler found for delegate type: ${modelKey}`;
      throw new Error(errorMsg);
    }
    this.logger.debug(
      `[useModel] ${modelKey} input: ` + JSON.stringify(params, safeReplacer(), 2).replace(/\\n/g, "\n")
    );
    let paramsWithRuntime;
    if (params === null || params === void 0 || typeof params !== "object" || Array.isArray(params) || typeof Buffer !== "undefined" && Buffer.isBuffer(params)) {
      paramsWithRuntime = params;
    } else {
      paramsWithRuntime = {
        ...params,
        runtime: this
      };
    }
    const startTime = performance.now();
    try {
      const response = await model(this, paramsWithRuntime);
      const elapsedTime = performance.now() - startTime;
      this.logger.debug(
        `[useModel] ${modelKey} output (took ${Number(elapsedTime.toFixed(2)).toLocaleString()}ms):`,
        Array.isArray(response) ? `${JSON.stringify(response.slice(0, 5))}...${JSON.stringify(response.slice(-5))} (${response.length} items)` : JSON.stringify(response, safeReplacer(), 2).replace(/\\n/g, "\n")
      );
      if (modelKey !== ModelType2.TEXT_EMBEDDING && promptContent) {
        if (this.currentActionContext) {
          this.currentActionContext.prompts.push({
            modelType: modelKey,
            prompt: promptContent,
            timestamp: Date.now()
          });
        }
        await this.adapter.log({
          entityId: this.agentId,
          roomId: this.agentId,
          body: {
            modelType,
            modelKey,
            prompt: promptContent,
            runId: this.getCurrentRunId(),
            timestamp: Date.now(),
            executionTime: elapsedTime,
            provider: provider || this.models.get(modelKey)?.[0]?.provider || "unknown",
            actionContext: this.currentActionContext ? {
              actionName: this.currentActionContext.actionName,
              actionId: this.currentActionContext.actionId
            } : void 0
          },
          type: `prompt:${modelKey}`
        });
      }
      this.adapter.log({
        entityId: this.agentId,
        roomId: this.agentId,
        body: {
          modelType,
          modelKey,
          params: {
            ...typeof params === "object" && !Array.isArray(params) && params ? params : {},
            prompt: promptContent
          },
          response: Array.isArray(response) && response.every((x) => typeof x === "number") ? "[array]" : response
        },
        type: `useModel:${modelKey}`
      });
      return response;
    } catch (error) {
      throw error;
    }
  }
  registerEvent(event, handler) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event)?.push(handler);
  }
  getEvent(event) {
    return this.events.get(event);
  }
  async emitEvent(event, params) {
    const events = Array.isArray(event) ? event : [event];
    for (const eventName of events) {
      const eventHandlers = this.events.get(eventName);
      if (!eventHandlers) {
        continue;
      }
      try {
        await Promise.all(eventHandlers.map((handler) => handler(params)));
      } catch (error) {
        this.logger.error(`Error during emitEvent for ${eventName} (handler execution):`, error);
      }
    }
  }
  async ensureEmbeddingDimension() {
    this.logger.debug(`[AgentRuntime][${this.character.name}] Starting ensureEmbeddingDimension`);
    if (!this.adapter) {
      throw new Error(
        `[AgentRuntime][${this.character.name}] Database adapter not initialized before ensureEmbeddingDimension`
      );
    }
    try {
      const model = this.getModel(ModelType2.TEXT_EMBEDDING);
      if (!model) {
        throw new Error(
          `[AgentRuntime][${this.character.name}] No TEXT_EMBEDDING model registered`
        );
      }
      this.logger.debug(`[AgentRuntime][${this.character.name}] Getting embedding dimensions`);
      const embedding = await this.useModel(ModelType2.TEXT_EMBEDDING, null);
      if (!embedding || !embedding.length) {
        throw new Error(`[AgentRuntime][${this.character.name}] Invalid embedding received`);
      }
      this.logger.debug(
        `[AgentRuntime][${this.character.name}] Setting embedding dimension: ${embedding.length}`
      );
      await this.adapter.ensureEmbeddingDimension(embedding.length);
      this.logger.debug(
        `[AgentRuntime][${this.character.name}] Successfully set embedding dimension`
      );
    } catch (error) {
      this.logger.debug(
        `[AgentRuntime][${this.character.name}] Error in ensureEmbeddingDimension:`,
        error
      );
      throw error;
    }
  }
  registerTaskWorker(taskHandler) {
    if (this.taskWorkers.has(taskHandler.name)) {
      this.logger.warn(
        `Task definition ${taskHandler.name} already registered. Will be overwritten.`
      );
    }
    this.taskWorkers.set(taskHandler.name, taskHandler);
  }
  getTaskWorker(name) {
    return this.taskWorkers.get(name);
  }
  get db() {
    return this.adapter.db;
  }
  async init() {
    await this.adapter.init();
  }
  async close() {
    await this.adapter.close();
  }
  async getAgent(agentId) {
    return await this.adapter.getAgent(agentId);
  }
  async getAgents() {
    return await this.adapter.getAgents();
  }
  async createAgent(agent) {
    return await this.adapter.createAgent(agent);
  }
  async updateAgent(agentId, agent) {
    return await this.adapter.updateAgent(agentId, agent);
  }
  async deleteAgent(agentId) {
    return await this.adapter.deleteAgent(agentId);
  }
  async ensureAgentExists(agent) {
    if (!agent.name) {
      throw new Error("Agent name is required");
    }
    const agents = await this.adapter.getAgents();
    const existingAgentId = agents.find((a) => a.name === agent.name)?.id;
    if (existingAgentId) {
      const updatedAgent = {
        ...agent,
        id: existingAgentId,
        updatedAt: Date.now()
      };
      await this.adapter.updateAgent(existingAgentId, updatedAgent);
      const existingAgent = await this.adapter.getAgent(existingAgentId);
      if (!existingAgent) {
        throw new Error(`Failed to retrieve agent after update: ${existingAgentId}`);
      }
      this.logger.debug(`Updated existing agent ${agent.name} on restart`);
      return existingAgent;
    }
    const newAgent = {
      ...agent,
      id: stringToUuid(agent.name)
    };
    const created = await this.adapter.createAgent(newAgent);
    if (!created) {
      throw new Error(`Failed to create agent: ${agent.name}`);
    }
    this.logger.debug(`Created new agent ${agent.name}`);
    return newAgent;
  }
  async getEntityById(entityId) {
    const entities = await this.adapter.getEntityByIds([entityId]);
    if (!entities?.length) return null;
    return entities[0];
  }
  async getEntityByIds(entityIds) {
    return await this.adapter.getEntityByIds(entityIds);
  }
  async getEntitiesForRoom(roomId, includeComponents) {
    return await this.adapter.getEntitiesForRoom(roomId, includeComponents);
  }
  async createEntity(entity) {
    if (!entity.agentId) {
      entity.agentId = this.agentId;
    }
    return await this.createEntities([entity]);
  }
  async createEntities(entities) {
    entities.forEach((e) => {
      e.agentId = this.agentId;
    });
    return await this.adapter.createEntities(entities);
  }
  async updateEntity(entity) {
    await this.adapter.updateEntity(entity);
  }
  async getComponent(entityId, type, worldId, sourceEntityId) {
    return await this.adapter.getComponent(entityId, type, worldId, sourceEntityId);
  }
  async getComponents(entityId, worldId, sourceEntityId) {
    return await this.adapter.getComponents(entityId, worldId, sourceEntityId);
  }
  async createComponent(component) {
    return await this.adapter.createComponent(component);
  }
  async updateComponent(component) {
    await this.adapter.updateComponent(component);
  }
  async deleteComponent(componentId) {
    await this.adapter.deleteComponent(componentId);
  }
  async addEmbeddingToMemory(memory) {
    if (memory.embedding) {
      return memory;
    }
    const memoryText = memory.content.text;
    if (!memoryText) {
      throw new Error("Cannot generate embedding: Memory content is empty");
    }
    try {
      memory.embedding = await this.useModel(ModelType2.TEXT_EMBEDDING, {
        text: memoryText
      });
    } catch (error) {
      this.logger.error("Failed to generate embedding:", error);
      memory.embedding = await this.useModel(ModelType2.TEXT_EMBEDDING, null);
    }
    return memory;
  }
  async getMemories(params) {
    return await this.adapter.getMemories(params);
  }
  async getAllMemories() {
    const tables = ["memories", "messages", "facts", "documents"];
    const allMemories = [];
    for (const tableName of tables) {
      try {
        const memories = await this.adapter.getMemories({
          agentId: this.agentId,
          tableName,
          count: 1e4
          // Get a large number to fetch all
        });
        allMemories.push(...memories);
      } catch (error) {
        this.logger.debug(`Failed to get memories from table ${tableName}:`, error);
      }
    }
    return allMemories;
  }
  async getMemoryById(id) {
    return await this.adapter.getMemoryById(id);
  }
  async getMemoriesByIds(ids, tableName) {
    return await this.adapter.getMemoriesByIds(ids, tableName);
  }
  async getMemoriesByRoomIds(params) {
    return await this.adapter.getMemoriesByRoomIds(params);
  }
  async getCachedEmbeddings(params) {
    return await this.adapter.getCachedEmbeddings(params);
  }
  async log(params) {
    await this.adapter.log(params);
  }
  async searchMemories(params) {
    const memories = await this.adapter.searchMemories(params);
    if (params.query) {
      const rerankedMemories = await this.rerankMemories(params.query, memories);
      return rerankedMemories;
    }
    return memories;
  }
  async rerankMemories(query, memories) {
    const docs = memories.map((memory) => ({
      title: memory.id,
      content: memory.content.text
    }));
    const bm25 = new BM25(docs);
    const results = bm25.search(query, memories.length);
    return results.map((result) => memories[result.index]);
  }
  async createMemory(memory, tableName, unique) {
    return await this.adapter.createMemory(memory, tableName, unique);
  }
  async updateMemory(memory) {
    return await this.adapter.updateMemory(memory);
  }
  async deleteMemory(memoryId) {
    await this.adapter.deleteMemory(memoryId);
  }
  async deleteManyMemories(memoryIds) {
    await this.adapter.deleteManyMemories(memoryIds);
  }
  async clearAllAgentMemories() {
    this.logger.info(`Clearing all memories for agent ${this.character.name} (${this.agentId})`);
    const allMemories = await this.getAllMemories();
    const memoryIds = allMemories.map((memory) => memory.id);
    if (memoryIds.length === 0) {
      this.logger.info("No memories found to delete");
      return;
    }
    this.logger.info(`Found ${memoryIds.length} memories to delete`);
    await this.adapter.deleteManyMemories(memoryIds);
    this.logger.info(`Successfully cleared all ${memoryIds.length} memories for agent`);
  }
  async deleteAllMemories(roomId, tableName) {
    await this.adapter.deleteAllMemories(roomId, tableName);
  }
  async countMemories(roomId, unique, tableName) {
    return await this.adapter.countMemories(roomId, unique, tableName);
  }
  async getLogs(params) {
    return await this.adapter.getLogs(params);
  }
  async deleteLog(logId) {
    await this.adapter.deleteLog(logId);
  }
  async createWorld(world) {
    return await this.adapter.createWorld(world);
  }
  async getWorld(id) {
    return await this.adapter.getWorld(id);
  }
  async removeWorld(worldId) {
    await this.adapter.removeWorld(worldId);
  }
  async getAllWorlds() {
    return await this.adapter.getAllWorlds();
  }
  async updateWorld(world) {
    await this.adapter.updateWorld(world);
  }
  async getRoom(roomId) {
    const rooms = await this.adapter.getRoomsByIds([roomId]);
    if (!rooms?.length) return null;
    return rooms[0];
  }
  async getRoomsByIds(roomIds) {
    return await this.adapter.getRoomsByIds(roomIds);
  }
  async createRoom({ id, name, source, type, channelId, serverId, worldId }) {
    if (!worldId) throw new Error("worldId is required");
    const res = await this.adapter.createRooms([
      {
        id,
        name,
        source,
        type,
        channelId,
        serverId,
        worldId
      }
    ]);
    if (!res.length) return null;
    return res[0];
  }
  async createRooms(rooms) {
    return await this.adapter.createRooms(rooms);
  }
  async deleteRoom(roomId) {
    await this.adapter.deleteRoom(roomId);
  }
  async deleteRoomsByWorldId(worldId) {
    await this.adapter.deleteRoomsByWorldId(worldId);
  }
  async updateRoom(room) {
    await this.adapter.updateRoom(room);
  }
  async getRoomsForParticipant(entityId) {
    return await this.adapter.getRoomsForParticipant(entityId);
  }
  async getRoomsForParticipants(userIds) {
    return await this.adapter.getRoomsForParticipants(userIds);
  }
  // deprecate this one
  async getRooms(worldId) {
    return await this.adapter.getRoomsByWorld(worldId);
  }
  async getRoomsByWorld(worldId) {
    return await this.adapter.getRoomsByWorld(worldId);
  }
  async getParticipantUserState(roomId, entityId) {
    return await this.adapter.getParticipantUserState(roomId, entityId);
  }
  async setParticipantUserState(roomId, entityId, state) {
    await this.adapter.setParticipantUserState(roomId, entityId, state);
  }
  async createRelationship(params) {
    return await this.adapter.createRelationship(params);
  }
  async updateRelationship(relationship) {
    await this.adapter.updateRelationship(relationship);
  }
  async getRelationship(params) {
    return await this.adapter.getRelationship(params);
  }
  async getRelationships(params) {
    return await this.adapter.getRelationships(params);
  }
  async getCache(key) {
    return await this.adapter.getCache(key);
  }
  async setCache(key, value) {
    return await this.adapter.setCache(key, value);
  }
  async deleteCache(key) {
    return await this.adapter.deleteCache(key);
  }
  async createTask(task) {
    return await this.adapter.createTask(task);
  }
  async getTasks(params) {
    return await this.adapter.getTasks(params);
  }
  async getTask(id) {
    return await this.adapter.getTask(id);
  }
  async getTasksByName(name) {
    return await this.adapter.getTasksByName(name);
  }
  async updateTask(id, task) {
    await this.adapter.updateTask(id, task);
  }
  async deleteTask(id) {
    await this.adapter.deleteTask(id);
  }
  on(event, callback) {
    if (!this.eventHandlers.has(event)) {
      this.eventHandlers.set(event, []);
    }
    this.eventHandlers.get(event)?.push(callback);
  }
  off(event, callback) {
    if (!this.eventHandlers.has(event)) {
      return;
    }
    const handlers = this.eventHandlers.get(event);
    const index = handlers.indexOf(callback);
    if (index !== -1) {
      handlers.splice(index, 1);
    }
  }
  emit(event, data) {
    if (!this.eventHandlers.has(event)) {
      return;
    }
    for (const handler of this.eventHandlers.get(event)) {
      handler(data);
    }
  }
  async sendControlMessage(params) {
    try {
      const { roomId, action, target } = params;
      const controlMessage = {
        type: "control",
        payload: {
          action,
          target
        },
        roomId
      };
      await this.emitEvent("CONTROL_MESSAGE", {
        runtime: this,
        message: controlMessage,
        source: "agent"
      });
      this.logger.debug(`Sent control message: ${action} to room ${roomId}`);
    } catch (error) {
      this.logger.error(`Error sending control message: ${error}`);
    }
  }
  registerSendHandler(source, handler) {
    if (this.sendHandlers.has(source)) {
      this.logger.warn(`Send handler for source '${source}' already registered. Overwriting.`);
    }
    this.sendHandlers.set(source, handler);
    this.logger.info(`Registered send handler for source: ${source}`);
  }
  async sendMessageToTarget(target, content) {
    const handler = this.sendHandlers.get(target.source);
    if (!handler) {
      const errorMsg = `No send handler registered for source: ${target.source}`;
      this.logger.error(errorMsg);
      throw new Error(errorMsg);
    }
    try {
      await handler(this, target, content);
    } catch (error) {
      this.logger.error(`Error executing send handler for source ${target.source}:`, error);
      throw error;
    }
  }
  async getMemoriesByWorldId(params) {
    return await this.adapter.getMemoriesByWorldId(params);
  }
  async runMigrations(migrationsPaths) {
    if (this.adapter && "runMigrations" in this.adapter) {
      await this.adapter.runMigrations(migrationsPaths);
    } else {
      this.logger.warn("Database adapter does not support migrations.");
    }
  }
  async isReady() {
    if (!this.adapter) {
      throw new Error("Database adapter not registered");
    }
    return await this.adapter.isReady();
  }
};

// src/settings.ts
import crypto from "crypto-browserify";
function createSettingFromConfig(configSetting) {
  return {
    name: configSetting.name,
    description: configSetting.description,
    usageDescription: configSetting.usageDescription || "",
    value: null,
    required: configSetting.required,
    validation: configSetting.validation || null,
    public: configSetting.public || false,
    secret: configSetting.secret || false,
    dependsOn: configSetting.dependsOn || [],
    onSetAction: configSetting.onSetAction || null,
    visibleIf: configSetting.visibleIf || null
  };
}
function getSalt() {
  const secretSalt = (typeof process !== "undefined" ? process.env.SECRET_SALT : import.meta.env.SECRET_SALT) || "secretsalt";
  if (!secretSalt) {
    logger.error("SECRET_SALT is not set");
  }
  const salt = secretSalt;
  logger.debug(`Generated salt with length: ${salt.length} (truncated for security)`);
  return salt;
}
function encryptStringValue(value, salt) {
  if (value === void 0 || value === null) {
    logger.debug("Attempted to encrypt undefined or null value");
    return value;
  }
  if (typeof value === "boolean" || typeof value === "number") {
    logger.debug("Value is a boolean or number, returning as is");
    return value;
  }
  if (typeof value !== "string") {
    logger.debug(`Value is not a string (type: ${typeof value}), returning as is`);
    return value;
  }
  const parts = value.split(":");
  if (parts.length === 2) {
    try {
      const possibleIv = Buffer.from(parts[0], "hex");
      if (possibleIv.length === 16) {
        logger.debug("Value appears to be already encrypted, skipping re-encryption");
        return value;
      }
    } catch (e) {
    }
  }
  const key = crypto.createHash("sha256").update(salt).digest().slice(0, 32);
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv("aes-256-cbc", key, iv);
  let encrypted = cipher.update(value, "utf8", "hex");
  encrypted += cipher.final("hex");
  return `${iv.toString("hex")}:${encrypted}`;
}
function decryptStringValue(value, salt) {
  try {
    if (value === void 0 || value === null) {
      return value;
    }
    if (typeof value === "boolean" || typeof value === "number") {
      return value;
    }
    if (typeof value !== "string") {
      logger.debug(`Value is not a string (type: ${typeof value}), returning as is`);
      return value;
    }
    const parts = value.split(":");
    if (parts.length !== 2) {
      return value;
    }
    const iv = Buffer.from(parts[0], "hex");
    const encrypted = parts[1];
    if (iv.length !== 16) {
      if (iv.length) {
        logger.debug(`Invalid IV length (${iv.length}) - expected 16 bytes`);
      }
      return value;
    }
    const key = crypto.createHash("sha256").update(salt).digest().slice(0, 32);
    const decipher = crypto.createDecipheriv("aes-256-cbc", key, iv);
    let decrypted = decipher.update(encrypted, "hex", "utf8");
    decrypted += decipher.final("utf8");
    return decrypted;
  } catch (error) {
    logger.error(`Error decrypting value: ${error}`);
    return value;
  }
}
function saltSettingValue(setting, salt) {
  const settingCopy = { ...setting };
  if (setting.secret === true && typeof setting.value === "string" && setting.value) {
    settingCopy.value = encryptStringValue(setting.value, salt);
  }
  return settingCopy;
}
function unsaltSettingValue(setting, salt) {
  const settingCopy = { ...setting };
  if (setting.secret === true && typeof setting.value === "string" && setting.value) {
    settingCopy.value = decryptStringValue(setting.value, salt);
  }
  return settingCopy;
}
function saltWorldSettings(worldSettings, salt) {
  const saltedSettings = {};
  for (const [key, setting] of Object.entries(worldSettings)) {
    saltedSettings[key] = saltSettingValue(setting, salt);
  }
  return saltedSettings;
}
function unsaltWorldSettings(worldSettings, salt) {
  const unsaltedSettings = {};
  for (const [key, setting] of Object.entries(worldSettings)) {
    unsaltedSettings[key] = unsaltSettingValue(setting, salt);
  }
  return unsaltedSettings;
}
async function updateWorldSettings(runtime, serverId, worldSettings) {
  const worldId = createUniqueUuid(runtime, serverId);
  const world = await runtime.getWorld(worldId);
  if (!world) {
    logger.error(`No world found for server ${serverId}`);
    return false;
  }
  if (!world.metadata) {
    world.metadata = {};
  }
  const salt = getSalt();
  const saltedSettings = saltWorldSettings(worldSettings, salt);
  world.metadata.settings = saltedSettings;
  await runtime.updateWorld(world);
  return true;
}
async function getWorldSettings(runtime, serverId) {
  const worldId = createUniqueUuid(runtime, serverId);
  const world = await runtime.getWorld(worldId);
  if (!world || !world.metadata?.settings) {
    return null;
  }
  const saltedSettings = world.metadata.settings;
  const salt = getSalt();
  return unsaltWorldSettings(saltedSettings, salt);
}
async function initializeOnboarding(runtime, world, config) {
  if (world.metadata?.settings) {
    logger.info(`Onboarding state already exists for server ${world.serverId}`);
    const saltedSettings = world.metadata.settings;
    const salt = getSalt();
    return unsaltWorldSettings(saltedSettings, salt);
  }
  const worldSettings = {};
  if (config.settings) {
    for (const [key, configSetting] of Object.entries(config.settings)) {
      worldSettings[key] = createSettingFromConfig(configSetting);
    }
  }
  if (!world.metadata) {
    world.metadata = {};
  }
  world.metadata.settings = worldSettings;
  await runtime.updateWorld(world);
  logger.info(`Initialized settings config for server ${world.serverId}`);
  return worldSettings;
}
function encryptedCharacter(character) {
  const encryptedChar = JSON.parse(JSON.stringify(character));
  const salt = getSalt();
  if (encryptedChar.settings?.secrets) {
    encryptedChar.settings.secrets = encryptObjectValues(encryptedChar.settings.secrets, salt);
  }
  if (encryptedChar.secrets) {
    encryptedChar.secrets = encryptObjectValues(encryptedChar.secrets, salt);
  }
  return encryptedChar;
}
function decryptedCharacter(character, _runtime) {
  const decryptedChar = JSON.parse(JSON.stringify(character));
  const salt = getSalt();
  if (decryptedChar.settings?.secrets) {
    decryptedChar.settings.secrets = decryptObjectValues(decryptedChar.settings.secrets, salt);
  }
  if (decryptedChar.secrets) {
    decryptedChar.secrets = decryptObjectValues(decryptedChar.secrets, salt);
  }
  return decryptedChar;
}
function encryptObjectValues(obj, salt) {
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === "string" && value) {
      result[key] = encryptStringValue(value, salt);
    } else {
      result[key] = value;
    }
  }
  return result;
}
function decryptObjectValues(obj, salt) {
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === "string" && value) {
      result[key] = decryptStringValue(value, salt);
    } else {
      result[key] = value;
    }
  }
  return result;
}

// src/services.ts
var ServiceBuilder = class {
  constructor(serviceType) {
    this.serviceType = serviceType;
    this.description = "";
  }
  /**
   * Set the service description
   */
  withDescription(description) {
    this.description = description;
    return this;
  }
  /**
   * Set the start function for the service
   */
  withStart(startFn) {
    this.startFn = startFn;
    return this;
  }
  /**
   * Set the stop function for the service
   */
  withStop(stopFn) {
    this.stopFn = stopFn;
    return this;
  }
  /**
   * Build the service class with all configured properties
   */
  build() {
    const serviceType = this.serviceType;
    const description = this.description;
    const startFn = this.startFn;
    const stopFn = this.stopFn;
    return class extends Service3 {
      constructor() {
        super(...arguments);
        this.capabilityDescription = description;
      }
      static {
        this.serviceType = serviceType;
      }
      static async start(runtime) {
        if (!startFn) {
          throw new Error(`Start function not defined for service ${serviceType}`);
        }
        return startFn(runtime);
      }
      async stop() {
        if (stopFn) {
          await stopFn();
        }
      }
    };
  }
};
function createService(serviceType) {
  return new ServiceBuilder(serviceType);
}
function defineService(definition) {
  return createService(definition.serviceType).withDescription(definition.description).withStart(definition.start).withStop(definition.stop || (() => Promise.resolve())).build();
}

// src/specs/v1/index.ts
var v1_exports = {};
__export(v1_exports, {
  ActionTimelineType: () => ActionTimelineType,
  AgentRuntime: () => AgentRuntime3,
  CacheKeyPrefix: () => CacheKeyPrefix,
  CacheStore: () => CacheStore,
  GoalStatus: () => GoalStatus,
  IrysDataType: () => IrysDataType,
  IrysMessageType: () => IrysMessageType,
  KnowledgeScope: () => KnowledgeScope,
  LoggingLevel: () => LoggingLevel,
  ModelClass: () => ModelClass,
  ModelProviderName: () => ModelProviderName,
  Service: () => Service,
  ServiceType: () => ServiceType,
  TokenizerType: () => TokenizerType,
  TranscriptionProvider: () => TranscriptionProvider,
  asUUID: () => asUUID3,
  convertContentToV1: () => convertContentToV1,
  convertContentToV2: () => convertContentToV2,
  createTemplateFunction: () => createTemplateFunction,
  formatActors: () => formatActors,
  formatMessages: () => formatMessages3,
  formatPosts: () => formatPosts3,
  formatTimestamp: () => formatTimestamp3,
  fromV2ActionExample: () => fromV2ActionExample,
  fromV2Provider: () => fromV2Provider,
  fromV2State: () => fromV2State,
  generateUuidFromString: () => generateUuidFromString,
  getActorDetails: () => getActorDetails,
  getTemplateValues: () => getTemplateValues,
  processTemplate: () => processTemplate,
  toV2ActionExample: () => toV2ActionExample,
  toV2Provider: () => toV2Provider,
  toV2State: () => toV2State
});

// src/specs/v1/messages.ts
async function getActorDetails({
  runtime,
  roomId
}) {
  throw new Error("getActorDetails is not implemented.");
}
function formatActors({ actors }) {
  if (!actors || actors.length === 0) {
    return "No actors available.";
  }
  return actors.map((actor) => actor.name).join(", ");
}
var formatMessages3 = ({ messages, actors }) => {
  return formatMessages2(messages);
};
var formatTimestamp3 = (messageDate) => {
  return formatTimestamp2(messageDate);
};

// src/specs/v1/posts.ts
var formatPosts3 = ({
  messages,
  actors,
  conversationHeader = true
}) => {
  const entities = actors.map((actor) => ({
    id: actor.id,
    names: [actor.name, actor.username].filter(Boolean),
    metadata: actor.details,
    agentId: void 0
    // agentId is not available on v1 Actor and not used by coreFormatPosts
  }));
  return formatPosts2({
    messages,
    entities,
    conversationHeader
  });
};

// src/specs/v1/runtime.ts
var DEFAULT_SERVER_ID = "00000000-0000-0000-0000-000000000000";
var AgentRuntime3 = class {
  get agentId() {
    return this._runtime.agentId;
  }
  get serverUrl() {
    return this._runtime.serverUrl;
  }
  get databaseAdapter() {
    return this._runtime.databaseAdapter;
  }
  get token() {
    return this._runtime.token;
  }
  get character() {
    return this._runtime.character;
  }
  get actions() {
    return this._runtime.actions;
  }
  get evaluators() {
    return this._runtime.evaluators;
  }
  get providers() {
    return this._runtime.providers;
  }
  get plugins() {
    return this._runtime.plugins;
  }
  get modelProvider() {
    return this._runtime.modelProvider;
  }
  get imageModelProvider() {
    return this._runtime.imageModelProvider;
  }
  get imageVisionModelProvider() {
    return this._runtime.imageVisionModelProvider;
  }
  get messageManager() {
    return this._runtime.messageManager;
  }
  get routes() {
    return this._runtime.routes;
  }
  get services() {
    return this._runtime.services;
  }
  get events() {
    return this._runtime.events;
  }
  get descriptionManager() {
    return this._runtime.descriptionManager;
  }
  get documentsManager() {
    return this._runtime.documentsManager;
  }
  get knowledgeManager() {
    return this._runtime.knowledgeManager;
  }
  get ragKnowledgeManager() {
    return this._runtime.ragKnowledgeManager;
  }
  get loreManager() {
    return this._runtime.loreManager;
  }
  get cacheManager() {
    return this._runtime.cacheManager;
  }
  get clients() {
    return this._runtime.clients;
  }
  registerMemoryManager(_manager) {
  }
  getMemoryManager(_tableName) {
  }
  getService(service) {
    return this._runtime.getService(service);
  }
  async registerService(service) {
    return this._runtime.registerService(service);
  }
  /**
   * Creates an instance of AgentRuntime.
   * @param opts - The options for configuring the AgentRuntime.
   * @param opts.conversationLength - The number of messages to hold in the recent message cache.
   * @param opts.token - The JWT token, can be a JWT token if outside worker, or an OpenAI token if inside worker.
   * @param opts.serverUrl - The URL of the worker.
   * @param opts.actions - Optional custom actions.
   * @param opts.evaluators - Optional custom evaluators.
   * @param opts.services - Optional custom services.
   * @param opts.memoryManagers - Optional custom memory managers.
   * @param opts.providers - Optional context providers.
   * @param opts.model - The model to use for generateText.
   * @param opts.embeddingModel - The model to use for embedding.
   * @param opts.agentId - Optional ID of the agent.
   * @param opts.databaseAdapter - The database adapter used for interacting with the database.
   * @param opts.fetch - Custom fetch function to use for making requests.
   */
  constructor(opts) {
    this._runtime = new AgentRuntime2(opts);
  }
  //private async initializeDatabase() {}
  async initialize() {
    return this._runtime.initialize();
  }
  async stop() {
    return this._runtime.stop();
  }
  getSetting(key) {
    return this._runtime.getSetting(key);
  }
  /**
   * Get the number of messages that are kept in the conversation buffer.
   * @returns The number of recent messages to be kept in memory.
   */
  getConversationLength() {
    return this._runtime.getConversationLength();
  }
  /**
   * Register an action for the agent to perform.
   * @param action The action to register.
   */
  registerAction(action) {
    return this._runtime.registerAction(action);
  }
  /**
   * Register an evaluator to assess and guide the agent's responses.
   * @param evaluator The evaluator to register.
   */
  registerEvaluator(evaluator) {
    return this._runtime.registerEvaluator(evaluator);
  }
  /**
   * Register a context provider to provide context for message generation.
   * @param provider The context provider to register.
   */
  registerContextProvider(provider) {
    return this._runtime.registerProvider(provider);
  }
  /**
   * Register an adapter for the agent to use.
   * @param adapter The adapter to register.
   */
  registerAdapter(_adapter) {
  }
  /**
   * Process the actions of a message.
   * @param message The message to process.
   * @param content The content of the message to process actions from.
   */
  async processActions(message, responses, state, callback) {
    return this._runtime.processActions(
      message,
      responses,
      state,
      callback
    );
  }
  /**
   * Evaluate the message and state using the registered evaluators.
   * @param message The message to evaluate.
   * @param state The state of the agent.
   * @param didRespond Whether the agent responded to the message.~
   * @param callback The handler callback
   * @returns The results of the evaluation.
   */
  async evaluate(message, state, didRespond, callback) {
    return this._runtime.evaluate(message, state, didRespond, callback);
  }
  /**
   * Ensure the existence of a participant in the room. If the participant does not exist, they are added to the room.
   * @param userId - The user ID to ensure the existence of.
   * @throws An error if the participant cannot be added.
   */
  async ensureParticipantExists(_userId, _roomId) {
  }
  /**
   * Ensure the existence of a user in the database. If the user does not exist, they are added to the database.
   * @param userId - The user ID to ensure the existence of.
   * @param userName - The user name to ensure the existence of.
   * @returns
   */
  async ensureUserExists(_userId, _userName, _name, _email, _source) {
  }
  async ensureParticipantInRoom(userId, roomId) {
    return this._runtime.ensureParticipantInRoom(userId, roomId);
  }
  async ensureConnection(userId, roomId, userName, _userScreenName, source) {
    return this._runtime.ensureConnection({
      userId,
      roomId,
      userName,
      entityId: "",
      source
    });
  }
  /**
   * Ensure the existence of a room between the agent and a user. If no room exists, a new room is created and the user
   * and agent are added as participants. The room ID is returned.
   * @param roomId - The room ID to create a room with.
   * @returns The room ID of the room between the agent and the user.
   * @throws An error if the room cannot be created.
   */
  async ensureRoomExists(roomId) {
    return this._runtime.ensureRoomExists({
      id: roomId,
      name: "Unknown",
      source: "Unknown",
      type: "Unknown",
      channelId: roomId,
      serverId: DEFAULT_SERVER_ID,
      worldId: DEFAULT_SERVER_ID,
      metadata: {}
    });
  }
  /**
   * Compose the state of the agent into an object that can be passed or used for response generation.
   * @param message The message to compose the state from.
   * @returns The state of the agent.
   */
  async composeState(message, _additionalKeys = {}) {
    return this._runtime.composeState(message, []);
  }
  async updateRecentMessageState(state) {
    const conversationLength = this.getConversationLength();
    this._runtime.getMemories({
      roomId: state.roomId,
      count: conversationLength,
      unique: false,
      tableName: state.tableName
    });
    const recentMessages = formatMessages3({
      actors: state.actorsData ?? [],
      messages: state.recentMessagesData?.map((memory) => {
        const newMemory = { ...memory };
        delete newMemory.embedding;
        return newMemory;
      })
    });
    let allAttachments = [];
    if (state.recentMessagesData && Array.isArray(state.recentMessagesData)) {
      const lastMessageWithAttachment = state.recentMessagesData.find(
        (msg) => msg.content.attachments && msg.content.attachments.length > 0
      );
      if (lastMessageWithAttachment) {
        const lastMessageTime = lastMessageWithAttachment?.createdAt ?? Date.now();
        const oneHourBeforeLastMessage = lastMessageTime - 60 * 60 * 1e3;
        allAttachments = state.recentMessagesData.filter((msg) => {
          const msgTime = msg.createdAt ?? Date.now();
          return msgTime >= oneHourBeforeLastMessage;
        }).flatMap((msg) => msg.content.attachments || []);
      }
    }
    const formattedAttachments = allAttachments.map(
      (attachment) => `ID: ${attachment.id}
Name: ${attachment.title}
URL: ${attachment.url}
Type: ${attachment.source}
Description: ${attachment.description}
Text: ${attachment.text}
    `
    ).join("\n");
    return {
      ...state,
      recentMessages: addHeader2("# Conversation Messages", recentMessages),
      recentMessagesData: state.recentMessagesData,
      attachments: formattedAttachments
    };
  }
};

// src/specs/v1/uuid.ts
function asUUID3(id) {
  const validUuid = validateUuid2(id);
  if (!validUuid) {
    throw new Error(`Invalid UUID format: ${id}`);
  }
  return id.toLowerCase();
}
function generateUuidFromString(input) {
  return stringToUuid2(input);
}

// src/specs/index.ts
var defaultSpec = v2_exports;

// src/entities.ts
var entityResolutionTemplate = `# Task: Resolve Entity Name
Message Sender: {{senderName}} (ID: {{senderId}})
Agent: {{agentName}} (ID: {{agentId}})

# Entities in Room:
{{#if entitiesInRoom}}
{{entitiesInRoom}}
{{/if}}

{{recentMessages}}

# Instructions:
1. Analyze the context to identify which entity is being referenced
2. Consider special references like "me" (the message sender) or "you" (agent the message is directed to)
3. Look for usernames/handles in standard formats (e.g. @username, user#1234)
4. Consider context from recent messages for pronouns and references
5. If multiple matches exist, use context to disambiguate
6. Consider recent interactions and relationship strength when resolving ambiguity

Return a JSON object with:
\`\`\`json
{
  "entityId": "exact-id-if-known-otherwise-null",
  "type": "EXACT_MATCH | USERNAME_MATCH | NAME_MATCH | RELATIONSHIP_MATCH | AMBIGUOUS | UNKNOWN",
  "matches": [{
    "name": "matched-name",
    "reason": "why this entity matches"
  }]
}
\`\`\`

Make sure to include the \`\`\`json\`\`\` tags around the JSON object.
`;
async function getRecentInteractions(runtime, sourceEntityId, candidateEntities, roomId, relationships) {
  const results = [];
  const recentMessages = await runtime.getMemories({
    tableName: "messages",
    roomId,
    count: 20
    // Reduced from 100 since we only need context
  });
  for (const entity of candidateEntities) {
    const interactions = [];
    let interactionScore = 0;
    const directReplies = recentMessages.filter(
      (msg) => msg.entityId === sourceEntityId && msg.content.inReplyTo === entity.id || msg.entityId === entity.id && msg.content.inReplyTo === sourceEntityId
    );
    interactions.push(...directReplies);
    const relationship = relationships.find(
      (rel) => rel.sourceEntityId === sourceEntityId && rel.targetEntityId === entity.id || rel.targetEntityId === sourceEntityId && rel.sourceEntityId === entity.id
    );
    if (relationship?.metadata?.interactions) {
      interactionScore = relationship.metadata.interactions;
    }
    interactionScore += directReplies.length;
    const uniqueInteractions = [...new Set(interactions)];
    results.push({
      entity,
      interactions: uniqueInteractions.slice(-5),
      // Only keep last 5 messages for context
      count: Math.round(interactionScore)
    });
  }
  return results.sort((a, b) => b.count - a.count);
}
async function findEntityByName(runtime, message, state) {
  const room = state.data.room ?? await runtime.getRoom(message.roomId);
  if (!room) {
    logger.warn("Room not found for entity search");
    return null;
  }
  const world = room.worldId ? await runtime.getWorld(room.worldId) : null;
  const entitiesInRoom = await runtime.getEntitiesForRoom(room.id, true);
  const filteredEntities = await Promise.all(
    entitiesInRoom.map(async (entity) => {
      if (!entity.components) return entity;
      const worldRoles = world?.metadata?.roles || {};
      entity.components = entity.components.filter((component) => {
        if (component.sourceEntityId === message.entityId) return true;
        if (world && component.sourceEntityId) {
          const sourceRole = worldRoles[component.sourceEntityId];
          if (sourceRole === "OWNER" || sourceRole === "ADMIN") return true;
        }
        if (component.sourceEntityId === runtime.agentId) return true;
        return false;
      });
      return entity;
    })
  );
  const relationships = await runtime.getRelationships({
    entityId: message.entityId
  });
  const relationshipEntities = await Promise.all(
    relationships.map(async (rel) => {
      const entityId = rel.sourceEntityId === message.entityId ? rel.targetEntityId : rel.sourceEntityId;
      return runtime.getEntityById(entityId);
    })
  );
  const allEntities = [
    ...filteredEntities,
    ...relationshipEntities.filter((e) => e !== null)
  ];
  const interactionData = await getRecentInteractions(
    runtime,
    message.entityId,
    allEntities,
    room.id,
    relationships
  );
  const prompt = composePrompt({
    state: {
      roomName: room.name || room.id,
      worldName: world?.name || "Unknown",
      entitiesInRoom: JSON.stringify(filteredEntities, null, 2),
      entityId: message.entityId,
      senderId: message.entityId
    },
    template: entityResolutionTemplate
  });
  const result = await runtime.useModel(ModelType2.TEXT_SMALL, {
    prompt,
    stopSequences: []
  });
  const resolution = parseJSONObjectFromText(result);
  if (!resolution) {
    logger.warn("Failed to parse entity resolution result");
    return null;
  }
  if (resolution.type === "EXACT_MATCH" && resolution.entityId) {
    const entity = await runtime.getEntityById(resolution.entityId);
    if (entity) {
      if (entity.components) {
        const worldRoles = world?.metadata?.roles || {};
        entity.components = entity.components.filter((component) => {
          if (component.sourceEntityId === message.entityId) return true;
          if (world && component.sourceEntityId) {
            const sourceRole = worldRoles[component.sourceEntityId];
            if (sourceRole === "OWNER" || sourceRole === "ADMIN") return true;
          }
          if (component.sourceEntityId === runtime.agentId) return true;
          return false;
        });
      }
      return entity;
    }
  }
  if (resolution.matches?.[0]?.name) {
    const matchName = resolution.matches[0].name.toLowerCase();
    const matchingEntity = allEntities.find((entity) => {
      if (entity.names.some((n) => n.toLowerCase() === matchName)) return true;
      return entity.components?.some(
        (c) => c.data.username?.toLowerCase() === matchName || c.data.handle?.toLowerCase() === matchName
      );
    });
    if (matchingEntity) {
      if (resolution.type === "RELATIONSHIP_MATCH") {
        const interactionInfo = interactionData.find((d) => d.entity.id === matchingEntity.id);
        if (interactionInfo && interactionInfo.count > 0) {
          return matchingEntity;
        }
      } else {
        return matchingEntity;
      }
    }
  }
  return null;
}
var createUniqueUuid = (runtime, baseUserId) => {
  if (baseUserId === runtime.agentId) {
    return runtime.agentId;
  }
  const combinedString = `${baseUserId}:${runtime.agentId}`;
  return stringToUuid(combinedString);
};
async function getEntityDetails({
  runtime,
  roomId
}) {
  const [room, roomEntities] = await Promise.all([
    runtime.getRoom(roomId),
    runtime.getEntitiesForRoom(roomId, true)
  ]);
  const uniqueEntities = /* @__PURE__ */ new Map();
  for (const entity of roomEntities) {
    if (uniqueEntities.has(entity.id)) continue;
    const allData = {};
    for (const component of entity.components || []) {
      Object.assign(allData, component.data);
    }
    const mergedData = {};
    for (const [key, value] of Object.entries(allData)) {
      if (!mergedData[key]) {
        mergedData[key] = value;
        continue;
      }
      if (Array.isArray(mergedData[key]) && Array.isArray(value)) {
        mergedData[key] = [.../* @__PURE__ */ new Set([...mergedData[key], ...value])];
      } else if (typeof mergedData[key] === "object" && typeof value === "object") {
        mergedData[key] = { ...mergedData[key], ...value };
      }
    }
    uniqueEntities.set(entity.id, {
      id: entity.id,
      name: room?.source ? entity.metadata[room.source]?.name || entity.names[0] : entity.names[0],
      names: entity.names,
      data: JSON.stringify({ ...mergedData, ...entity.metadata })
    });
  }
  return Array.from(uniqueEntities.values());
}
function formatEntities({ entities }) {
  const entityStrings = entities.map((entity) => {
    const header = `"${entity.names.join('" aka "')}"
ID: ${entity.id}${entity.metadata && Object.keys(entity.metadata).length > 0 ? `
Data: ${JSON.stringify(entity.metadata)}
` : "\n"}`;
    return header;
  });
  return entityStrings.join("\n");
}

// src/specs/v2/entities.ts
async function findEntityByName2(runtime, message, state) {
  const rt = runtime;
  return findEntityByName(rt, message, state);
}
var createUniqueUuid2 = (runtime, baseUserId) => {
  return createUniqueUuid(runtime, baseUserId);
};
async function getEntityDetails2({
  runtime,
  roomId
}) {
  return getEntityDetails({ runtime, roomId });
}
function formatEntities2({ entities }) {
  return formatEntities({ entities });
}

// src/specs/v2/logger.ts
var logger2 = {
  trace: (...args) => {
    const [message = "", ...rest] = args;
    return logger.trace.apply(logger, [String(message), ...rest]);
  },
  debug: (...args) => {
    const [message = "", ...rest] = args;
    return logger.debug.apply(logger, [String(message), ...rest]);
  },
  success: (...args) => {
    const [message = "", ...rest] = args;
    return logger.debug.apply(logger, [String(message), ...rest]);
  },
  progress: (...args) => {
    const [message = "", ...rest] = args;
    return logger.debug.apply(logger, [String(message), ...rest]);
  },
  log: (...args) => {
    const [message = "", ...rest] = args;
    return logger.info.apply(logger, [String(message), ...rest]);
  },
  info: (...args) => {
    const [message = "", ...rest] = args;
    return logger.info.apply(logger, [String(message), ...rest]);
  },
  warn: (...args) => {
    const [message = "", ...rest] = args;
    return logger.warn.apply(logger, [String(message), ...rest]);
  },
  error: (...args) => {
    const [message = "", ...rest] = args;
    return logger.error.apply(logger, [String(message), ...rest]);
  },
  fatal: (...args) => {
    const [message = "", ...rest] = args;
    return logger.fatal.apply(logger, [String(message), ...rest]);
  },
  clear: (...args) => {
    const [message = "", ...rest] = args;
    return logger.clear.apply(logger, [String(message), ...rest]);
  }
};
var elizaLogger2 = logger2;

// src/specs/v2/prompts.ts
var shouldRespondTemplate2 = shouldRespondTemplate;
var messageHandlerTemplate2 = messageHandlerTemplate;
var postCreationTemplate2 = postCreationTemplate;
var booleanFooter2 = booleanFooter;
var imageDescriptionTemplate2 = imageDescriptionTemplate;

// src/specs/v2/roles.ts
async function getUserServerRole2(runtime, entityId, serverId) {
  return getUserServerRole(runtime, entityId, serverId);
}
async function findWorldsForOwner2(runtime, entityId) {
  return findWorldsForOwner(runtime, entityId);
}

// src/specs/v2/runtime.ts
var Semaphore2 = class {
  constructor(count) {
    this._semphonre = new Semaphore(count);
  }
  async acquire() {
    return this._semphonre.acquire();
  }
  release() {
    return this._semphonre.release();
  }
};
var AgentRuntime2 = class {
  get services() {
    return this._runtime.services;
  }
  get events() {
    if (this._runtime.events instanceof Map) {
      return this._runtime.events;
    }
    const eventsMap = /* @__PURE__ */ new Map();
    if (this._runtime.events && typeof this._runtime.events === "object") {
      Object.entries(this._runtime.events).forEach(([key, handlers]) => {
        eventsMap.set(key, handlers);
      });
    }
    return eventsMap;
  }
  get routes() {
    return this._runtime.routes;
  }
  get agentId() {
    return this._runtime.agentId;
  }
  get character() {
    return this._runtime.character;
  }
  get providers() {
    return this._runtime.providers;
  }
  get actions() {
    return this._runtime.actions;
  }
  get evaluators() {
    return this._runtime.evaluators;
  }
  get plugins() {
    return this._runtime.plugins;
  }
  get adapter() {
    return this._runtime.adapter;
  }
  constructor(opts) {
    this._runtime = new AgentRuntime(opts);
  }
  /**
   * Registers a plugin with the runtime and initializes its components
   * @param plugin The plugin to register
   */
  async registerPlugin(plugin) {
    const wrappedPlugin = {
      ...plugin,
      init: plugin.init ? async (config, _runtime) => {
        return plugin.init(config, this);
      } : void 0
    };
    return this._runtime.registerPlugin(wrappedPlugin);
  }
  getAllServices() {
    return this._runtime.services;
  }
  async stop() {
    return this._runtime.stop();
  }
  async initialize() {
    return this._runtime.initialize();
  }
  async getConnection() {
    return this._runtime.getConnection();
  }
  setSetting(key, value, secret = false) {
    return this._runtime.setSetting(key, value, secret);
  }
  getSetting(key) {
    return this._runtime.getSetting(key);
  }
  /**
   * Get the number of messages that are kept in the conversation buffer.
   * @returns The number of recent messages to be kept in memory.
   */
  getConversationLength() {
    return this._runtime.getConversationLength();
  }
  registerDatabaseAdapter(adapter) {
    return this._runtime.registerDatabaseAdapter(adapter);
  }
  /**
   * Register a provider for the agent to use.
   * @param provider The provider to register.
   */
  registerProvider(provider) {
    const wrappedProvider = {
      ...provider,
      get: async (_runtime, message, state) => {
        return provider.get(this, message, state);
      }
    };
    return this._runtime.registerProvider(wrappedProvider);
  }
  /**
   * Register an action for the agent to perform.
   * @param action The action to register.
   */
  registerAction(action) {
    const wrappedAction = {
      ...action,
      handler: async (_runtime, message, state, options2, callback, responses) => {
        return action.handler(this, message, state, options2, callback, responses);
      }
    };
    return this._runtime.registerAction(wrappedAction);
  }
  /**
   * Register an evaluator to assess and guide the agent's responses.
   * @param evaluator The evaluator to register.
   */
  registerEvaluator(evaluator) {
    return this._runtime.registerEvaluator(evaluator);
  }
  /**
   * Process the actions of a message.
   * @param message The message to process.
   * @param responses The array of response memories to process actions from.
   * @param state Optional state object for the action processing.
   * @param callback Optional callback handler for action results.
   */
  async processActions(message, responses, state, callback) {
    return this._runtime.processActions(message, responses, state, callback);
  }
  /**
   * Evaluate the message and state using the registered evaluators.
   * @param message The message to evaluate.
   * @param state The state of the agent.
   * @param didRespond Whether the agent responded to the message.~
   * @param callback The handler callback
   * @returns The results of the evaluation.
   */
  async evaluate(message, state, didRespond, callback, responses) {
    return this._runtime.evaluate(message, state, didRespond, callback, responses);
  }
  async ensureConnection({
    entityId,
    roomId,
    userName,
    name,
    source,
    type,
    channelId,
    serverId,
    worldId,
    userId
  }) {
    return this._runtime.ensureConnection({
      entityId,
      roomId,
      userName,
      name,
      source,
      type,
      channelId,
      serverId,
      worldId,
      userId
    });
  }
  /**
   * Ensures a participant is added to a room, checking that the entity exists first
   */
  async ensureParticipantInRoom(entityId, roomId) {
    return this._runtime.ensureParticipantInRoom(entityId, roomId);
  }
  async removeParticipant(entityId, roomId) {
    return this._runtime.removeParticipant(entityId, roomId);
  }
  async getParticipantsForEntity(entityId) {
    return this._runtime.getParticipantsForEntity(entityId);
  }
  async getParticipantsForRoom(roomId) {
    return this._runtime.getParticipantsForRoom(roomId);
  }
  async addParticipant(entityId, roomId) {
    return this._runtime.addParticipant(entityId, roomId);
  }
  async addParticipantsRoom(entityIds, roomId) {
    return this._runtime.addParticipantsRoom(entityIds, roomId);
  }
  /**
   * Ensure the existence of a world.
   */
  async ensureWorldExists({ id, name, serverId, metadata, agentId }) {
    return this._runtime.ensureWorldExists({
      id,
      name,
      serverId,
      metadata,
      agentId
    });
  }
  /**
   * Ensure the existence of a room between the agent and a user. If no room exists, a new room is created and the user
   * and agent are added as participants. The room ID is returned.
   * @param entityId - The user ID to create a room with.
   * @returns The room ID of the room between the agent and the user.
   * @throws An error if the room cannot be created.
   */
  async ensureRoomExists({ id, name, source, type, channelId, serverId, worldId, metadata }) {
    return this._runtime.ensureRoomExists({
      id,
      name,
      source,
      type,
      channelId,
      serverId,
      worldId,
      metadata
    });
  }
  /**
   * Composes the agent's state by gathering data from enabled providers.
   * @param message - The message to use as context for state composition
   * @param includeList - Optional list of provider names to include, filtering out all others
   * @param onlyInclude - Whether to only include the specified providers
   * @param skipCache - Whether to skip the cache
   * @returns A State object containing provider data, values, and text
   */
  async composeState(message, includeList = null, onlyInclude = false, skipCache = false) {
    return this._runtime.composeState(message, includeList, onlyInclude, skipCache);
  }
  getService(service) {
    return this._runtime.getService(service);
  }
  async registerService(service) {
    return this._runtime.registerService(service);
  }
  registerModel(modelType, handler, provider = "v2") {
    const wrappedHandler = async (_runtime, params) => {
      return handler(this, params);
    };
    return this._runtime.registerModel(modelType, wrappedHandler, provider);
  }
  getModel(modelType) {
    return this._runtime.getModel(modelType);
  }
  /**
   * Use a model with strongly typed parameters and return values based on model type
   * @template T - The model type to use
   * @template R - The expected return type, defaults to the type defined in ModelResultMap[T]
   * @param {T} modelType - The type of model to use
   * @param {ModelParamsMap[T] | any} params - The parameters for the model, typed based on model type
   * @returns {Promise<R>} - The model result, typed based on the provided generic type parameter
   */
  async useModel(modelType, params) {
    return this._runtime.useModel(modelType, params);
  }
  registerEvent(event, handler) {
    return this._runtime.registerEvent(event, handler);
  }
  getEvent(event) {
    return this._runtime.getEvent(event);
  }
  async emitEvent(event, params) {
    return this._runtime.emitEvent(event, params);
  }
  async ensureEmbeddingDimension() {
    return this._runtime.ensureEmbeddingDimension();
  }
  registerTaskWorker(taskHandler) {
    return this._runtime.registerTaskWorker(taskHandler);
  }
  /**
   * Get a task worker by name
   */
  getTaskWorker(name) {
    return this._runtime.getTaskWorker(name);
  }
  // Implement database adapter methods
  get db() {
    return this._runtime.db();
  }
  async init() {
    return this._runtime.init();
  }
  async close() {
    return this._runtime.close();
  }
  async getAgent(agentId) {
    return this._runtime.getAgent(agentId);
  }
  async getAgents() {
    return this._runtime.getAgents();
  }
  async createAgent(agent) {
    return this._runtime.createAgent(agent);
  }
  async updateAgent(agentId, agent) {
    return this._runtime.updateAgent(agentId, agent);
  }
  async deleteAgent(agentId) {
    return this._runtime.deleteAgent(agentId);
  }
  async ensureAgentExists(agent) {
    return this._runtime.ensureAgentExists(agent);
  }
  async getEntityById(entityId) {
    return this._runtime.getEntityById(entityId);
  }
  async getEntityByIds(entityIds) {
    return this._runtime.getEntityByIds(entityIds);
  }
  async getEntitiesForRoom(roomId, includeComponents) {
    return this._runtime.getEntitiesForRoom(roomId, includeComponents);
  }
  async createEntity(entity) {
    return this._runtime.createEntity(entity);
  }
  async createEntities(entities) {
    return this._runtime.createEntities(entities);
  }
  async updateEntity(entity) {
    return this._runtime.updateEntity(entity);
  }
  async getComponent(entityId, type, worldId, sourceEntityId) {
    return this._runtime.getComponent(entityId, type, worldId, sourceEntityId);
  }
  async getComponents(entityId, worldId, sourceEntityId) {
    return this._runtime.getComponents(entityId, worldId, sourceEntityId);
  }
  async createComponent(component) {
    return this._runtime.createComponent(component);
  }
  async updateComponent(component) {
    return this._runtime.updateComponent(component);
  }
  async deleteComponent(componentId) {
    return this._runtime.deleteComponent(componentId);
  }
  async addEmbeddingToMemory(memory) {
    return this._runtime.addEmbeddingToMemory(memory);
  }
  async getAllMemories() {
    return this._runtime.getAllMemories();
  }
  async clearAllAgentMemories() {
    return this._runtime.clearAllAgentMemories();
  }
  async getMemories(params) {
    return this._runtime.getMemories(params);
  }
  async getMemoryById(id) {
    return this._runtime.getMemoryById(id);
  }
  async getMemoriesByIds(ids, tableName) {
    return this._runtime.getMemoriesByIds(ids, tableName);
  }
  async getMemoriesByRoomIds(params) {
    return this._runtime.getMemoriesByRoomIds(params);
  }
  async getCachedEmbeddings(params) {
    return this._runtime.getCachedEmbeddings(params);
  }
  async log(params) {
    return this._runtime.log(params);
  }
  async searchMemories(params) {
    return this._runtime.searchMemories(params);
  }
  async createMemory(memory, tableName, unique) {
    return this._runtime.createMemory(memory, tableName, unique);
  }
  async updateMemory(memory) {
    return this._runtime.updateMemory(memory);
  }
  async deleteMemory(memoryId) {
    return this._runtime.deleteMemory(memoryId);
  }
  async deleteManyMemories(memoryIds) {
    return this._runtime.deleteManyMemories(memoryIds);
  }
  async deleteAllMemories(roomId, tableName) {
    return this._runtime.deleteAllMemories(roomId, tableName);
  }
  async countMemories(roomId, unique, tableName) {
    return this._runtime.countMemories(roomId, unique, tableName);
  }
  async getLogs(params) {
    return this._runtime.getLogs(params);
  }
  async deleteLog(logId) {
    return this._runtime.deleteLog(logId);
  }
  async createWorld(world) {
    return this._runtime.createWorld(world);
  }
  async getWorld(id) {
    return this._runtime.getWorld(id);
  }
  async removeWorld(worldId) {
    return this._runtime.removeWorld(worldId);
  }
  async getAllWorlds() {
    return this._runtime.getAllWorlds();
  }
  async updateWorld(world) {
    return this._runtime.updateWorld(world);
  }
  async getRoom(roomId) {
    return this._runtime.getRoom(roomId);
  }
  async getRoomsByIds(roomIds) {
    return this._runtime.getRoomsByIds(roomIds);
  }
  async createRoom({ id, name, source, type, channelId, serverId, worldId }) {
    return this._runtime.createRoom({
      id,
      name,
      source,
      type,
      channelId,
      serverId,
      worldId
    });
  }
  async createRooms(rooms) {
    return this._runtime.createRooms(rooms);
  }
  async deleteRoom(roomId) {
    return this._runtime.deleteRoom(roomId);
  }
  async deleteRoomsByWorldId(worldId) {
    return this._runtime.deleteRoomsByWorldId(worldId);
  }
  async updateRoom(room) {
    return this._runtime.updateRoom(room);
  }
  async getRoomsForParticipant(entityId) {
    return this._runtime.getRoomsForParticipant(entityId);
  }
  async getRoomsForParticipants(userIds) {
    return this._runtime.getRoomsForParticipants(userIds);
  }
  async getRooms(worldId) {
    return this._runtime.getRooms(worldId);
  }
  async getRoomsByWorld(worldId) {
    return this._runtime.getRoomsByWorld(worldId);
  }
  async getParticipantUserState(roomId, entityId) {
    return this._runtime.getParticipantUserState(roomId, entityId);
  }
  async setParticipantUserState(roomId, entityId, state) {
    return this._runtime.setParticipantUserState(roomId, entityId, state);
  }
  async createRelationship(params) {
    return this._runtime.createRelationship(params);
  }
  async updateRelationship(relationship) {
    return this._runtime.updateRelationship(relationship);
  }
  async getRelationship(params) {
    return this._runtime.getRelationship(params);
  }
  async getRelationships(params) {
    return this._runtime.getRelationships(params);
  }
  async getCache(key) {
    return this._runtime.getCache(key);
  }
  async setCache(key, value) {
    return this._runtime.setCache(key, value);
  }
  async deleteCache(key) {
    return this._runtime.deleteCache(key);
  }
  async createTask(task) {
    return this._runtime.createTask(task);
  }
  async getTasks(params) {
    return this._runtime.getTasks(params);
  }
  async getTask(id) {
    return this._runtime.getTask(id);
  }
  async getTasksByName(name) {
    return this._runtime.getTasksByName(name);
  }
  async updateTask(id, task) {
    return this._runtime.updateTask(id, task);
  }
  async deleteTask(id) {
    return this._runtime.deleteTask(id);
  }
  // Event emitter methods
  on(event, callback) {
    return this._runtime.on(event, callback);
  }
  off(event, callback) {
    return this._runtime.off(event, callback);
  }
  emit(event, data) {
    return this._runtime.emit(event, data);
  }
  async sendControlMessage(params) {
    return this._runtime.sendControlMessage(params);
  }
  /**
   * Register a message send handler for a specific source
   * @param source - The source identifier (e.g., 'discord', 'telegram')
   * @param handler - The handler function to send messages
   */
  registerSendHandler(source, handler) {
    this._runtime.registerSendHandler(source, handler);
  }
  /**
   * Send a message to a specific target
   * @param target - The target information including source and channel/user ID
   * @param content - The message content to send
   */
  async sendMessageToTarget(target, content) {
    return this._runtime.sendMessageToTarget(target, content);
  }
  async getMemoriesByWorldId(params) {
    return this._runtime.getMemoriesByWorldId(params);
  }
  // Run tracking methods
  createRunId() {
    return this._runtime.createRunId();
  }
  startRun() {
    return this._runtime.startRun();
  }
  endRun() {
    return this._runtime.endRun();
  }
  getCurrentRunId() {
    return this._runtime.getCurrentRunId();
  }
};

// src/specs/v2/settings.ts
function createSettingFromConfig2(configSetting) {
  return createSettingFromConfig(configSetting);
}
function getSalt2() {
  return getSalt();
}
function encryptStringValue2(value, salt) {
  return encryptStringValue(value, salt);
}
function decryptStringValue2(value, salt) {
  return decryptStringValue(value, salt);
}
function saltSettingValue2(setting, salt) {
  return saltSettingValue(setting, salt);
}
function unsaltSettingValue2(setting, salt) {
  return unsaltSettingValue(setting, salt);
}
function saltWorldSettings2(worldSettings, salt) {
  return saltWorldSettings(worldSettings, salt);
}
function unsaltWorldSettings2(worldSettings, salt) {
  return unsaltWorldSettings(worldSettings, salt);
}
async function updateWorldSettings2(runtime, serverId, worldSettings) {
  return updateWorldSettings(runtime, serverId, worldSettings);
}
async function getWorldSettings2(runtime, serverId) {
  return getWorldSettings(runtime, serverId);
}
async function initializeOnboarding2(runtime, world, config) {
  return initializeOnboarding(runtime, world, config);
}
function encryptedCharacter2(character) {
  return encryptedCharacter(character);
}
function decryptedCharacter2(character, runtime) {
  return decryptedCharacter(character, runtime);
}
function encryptObjectValues2(obj, salt) {
  return encryptObjectValues(obj, salt);
}
function decryptObjectValues2(obj, salt) {
  return decryptObjectValues(obj, salt);
}

// src/specs/v2/utils.ts
var composePrompt2 = ({
  state,
  template
}) => {
  return composePrompt({ state, template });
};
var composePromptFromState2 = ({
  state,
  template
}) => {
  return composePromptFromState({ state, template });
};
var addHeader2 = (header, body) => {
  return addHeader(header, body);
};
var formatPosts2 = ({
  messages,
  entities,
  conversationHeader = true
}) => {
  return formatPosts({ messages, entities, conversationHeader });
};
var formatMessages2 = ({
  messages,
  entities
}) => {
  return formatMessages({ messages, entities });
};
var formatTimestamp2 = (messageDate) => {
  return formatTimestamp(messageDate);
};
function validateUuid2(value) {
  return validateUuid(value);
}
function stringToUuid2(target) {
  return stringToUuid(target);
}
function truncateToCompleteSentence2(text, maxLength) {
  return truncateToCompleteSentence(text, maxLength);
}
function parseKeyValueXml2(text) {
  return parseKeyValueXml(text);
}
function parseJSONObjectFromText2(text) {
  return parseJSONObjectFromText(text);
}
function parseBooleanFromText3(text) {
  return parseBooleanFromText2(text);
}
function safeReplacer2() {
  return safeReplacer();
}
function trimTokens2(text, maxTokens, runtime) {
  return trimTokens(text, maxTokens, runtime);
}

// src/specs/v2/services.ts
var ServiceBuilder2 = class extends ServiceBuilder {
  constructor(serviceType) {
    super(serviceType);
    this.description = "";
  }
};
function createService2(serviceType) {
  return createService(serviceType);
}
function defineService2(definition) {
  return createService(definition.serviceType).withDescription(definition.description).withStart(definition.start).withStop(definition.stop || (() => Promise.resolve())).build();
}

export {
  asUUID2 as asUUID,
  ContentType2 as ContentType,
  MemoryType2 as MemoryType,
  createMessageMemory2 as createMessageMemory,
  isDocumentMetadata2 as isDocumentMetadata,
  isFragmentMetadata2 as isFragmentMetadata,
  isMessageMetadata2 as isMessageMetadata,
  isDescriptionMetadata2 as isDescriptionMetadata,
  isCustomMetadata2 as isCustomMetadata,
  isDocumentMemory2 as isDocumentMemory,
  isFragmentMemory2 as isFragmentMemory,
  getMemoryText2 as getMemoryText,
  KnowledgeScope3 as KnowledgeScope,
  CacheKeyPrefix3 as CacheKeyPrefix,
  Role2 as Role,
  ChannelType2 as ChannelType,
  AgentStatus2 as AgentStatus,
  ServiceType3 as ServiceType,
  Service3 as Service,
  getTypedService2 as getTypedService,
  createServiceError2 as createServiceError,
  ModelType2 as ModelType,
  VECTOR_DIMS2 as VECTOR_DIMS,
  EventType2 as EventType,
  PlatformPrefix2 as PlatformPrefix,
  TEEMode2 as TEEMode,
  TeeType2 as TeeType,
  ITokenDataService,
  SOCKET_MESSAGE_TYPE2 as SOCKET_MESSAGE_TYPE,
  IWalletService,
  ILpService,
  Sentry,
  createLogger,
  logger,
  elizaLogger,
  composePrompt,
  composePromptFromState,
  addHeader,
  formatPosts,
  formatMessages,
  formatTimestamp,
  parseKeyValueXml,
  parseJSONObjectFromText,
  normalizeJsonString,
  truncateToCompleteSentence,
  splitChunks,
  trimTokens,
  safeReplacer,
  parseBooleanFromText2 as parseBooleanFromText,
  validateUuid,
  stringToUuid,
  getContentTypeFromMimeType,
  getLocalServerUrl,
  characterSchema,
  validateCharacter,
  parseAndValidateCharacter,
  isValidCharacter,
  composeActionExamples2 as composeActionExamples,
  formatActionNames2 as formatActionNames,
  formatActions2 as formatActions,
  DatabaseAdapter2 as DatabaseAdapter,
  findEntityByName,
  createUniqueUuid,
  getEntityDetails,
  formatEntities,
  shouldRespondTemplate,
  messageHandlerTemplate,
  postCreationTemplate,
  booleanFooter,
  imageDescriptionTemplate,
  getUserServerRole,
  findWorldsForOwner,
  Semaphore,
  AgentRuntime,
  createSettingFromConfig,
  getSalt,
  encryptStringValue,
  decryptStringValue,
  saltSettingValue,
  unsaltSettingValue,
  saltWorldSettings,
  unsaltWorldSettings,
  updateWorldSettings,
  getWorldSettings,
  initializeOnboarding,
  encryptedCharacter,
  decryptedCharacter,
  encryptObjectValues,
  decryptObjectValues,
  ServiceBuilder,
  createService,
  defineService,
  asUUID as asUUID2,
  ModelType as ModelType2,
  ServiceType2,
  MemoryType as MemoryType2,
  ContentType as ContentType2,
  ChannelType as ChannelType2,
  AgentStatus as AgentStatus2,
  KnowledgeScope2,
  CacheKeyPrefix2,
  TEEMode as TEEMode2,
  TeeType as TeeType2,
  Role as Role2,
  EventType as EventType2,
  PlatformPrefix as PlatformPrefix2,
  SOCKET_MESSAGE_TYPE as SOCKET_MESSAGE_TYPE2,
  createMessageMemory as createMessageMemory2,
  getTypedService as getTypedService2,
  isDocumentMetadata as isDocumentMetadata2,
  isFragmentMetadata as isFragmentMetadata2,
  isMessageMetadata as isMessageMetadata2,
  isDescriptionMetadata as isDescriptionMetadata2,
  isCustomMetadata as isCustomMetadata2,
  isDocumentMemory as isDocumentMemory2,
  isFragmentMemory as isFragmentMemory2,
  getMemoryText as getMemoryText2,
  createServiceError as createServiceError2,
  VECTOR_DIMS as VECTOR_DIMS2,
  Service2,
  composeActionExamples as composeActionExamples2,
  formatActionNames as formatActionNames2,
  formatActions as formatActions2,
  DatabaseAdapter as DatabaseAdapter2,
  findEntityByName2,
  createUniqueUuid2,
  getEntityDetails2,
  formatEntities2,
  logger2,
  elizaLogger2,
  shouldRespondTemplate2,
  messageHandlerTemplate2,
  postCreationTemplate2,
  booleanFooter2,
  imageDescriptionTemplate2,
  getUserServerRole2,
  findWorldsForOwner2,
  Semaphore2,
  AgentRuntime2,
  createSettingFromConfig2,
  getSalt2,
  encryptStringValue2,
  decryptStringValue2,
  saltSettingValue2,
  unsaltSettingValue2,
  saltWorldSettings2,
  unsaltWorldSettings2,
  updateWorldSettings2,
  getWorldSettings2,
  initializeOnboarding2,
  encryptedCharacter2,
  decryptedCharacter2,
  encryptObjectValues2,
  decryptObjectValues2,
  composePrompt2,
  composePromptFromState2,
  addHeader2,
  formatPosts2,
  formatMessages2,
  formatTimestamp2,
  validateUuid2,
  stringToUuid2,
  truncateToCompleteSentence2,
  parseKeyValueXml2,
  parseJSONObjectFromText2,
  parseBooleanFromText3 as parseBooleanFromText2,
  safeReplacer2,
  trimTokens2,
  ServiceBuilder2,
  createService2,
  defineService2,
  v2_exports,
  getActorDetails,
  formatActors,
  formatMessages3,
  formatTimestamp3,
  formatPosts3,
  AgentRuntime3,
  asUUID3,
  generateUuidFromString,
  v1_exports,
  defaultSpec
};
